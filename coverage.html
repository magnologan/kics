
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>flags: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Checkmarx/kics/internal/console/flags/flags.go (35.0%)</option>
				
				<option value="file1">github.com/Checkmarx/kics/internal/console/flags/validate.go (50.0%)</option>
				
				<option value="file2">github.com/Checkmarx/kics/internal/console/flags/validate_multi_str.go (100.0%)</option>
				
				<option value="file3">github.com/Checkmarx/kics/internal/console/flags/validate_str.go (100.0%)</option>
				
				<option value="file4">github.com/Checkmarx/kics/internal/console/generate_id.go (80.0%)</option>
				
				<option value="file5">github.com/Checkmarx/kics/internal/console/helpers/exit_handler.go (100.0%)</option>
				
				<option value="file6">github.com/Checkmarx/kics/internal/console/helpers/helpers.go (82.9%)</option>
				
				<option value="file7">github.com/Checkmarx/kics/internal/console/kics.go (77.8%)</option>
				
				<option value="file8">github.com/Checkmarx/kics/internal/console/list_platforms.go (100.0%)</option>
				
				<option value="file9">github.com/Checkmarx/kics/internal/console/printer/printer.go (55.6%)</option>
				
				<option value="file10">github.com/Checkmarx/kics/internal/console/scan.go (74.2%)</option>
				
				<option value="file11">github.com/Checkmarx/kics/internal/console/version.go (100.0%)</option>
				
				<option value="file12">github.com/Checkmarx/kics/internal/constants/constants.go (100.0%)</option>
				
				<option value="file13">github.com/Checkmarx/kics/internal/metrics/cpu_metric.go (91.7%)</option>
				
				<option value="file14">github.com/Checkmarx/kics/internal/metrics/mem_metric.go (92.9%)</option>
				
				<option value="file15">github.com/Checkmarx/kics/internal/metrics/metrics.go (90.3%)</option>
				
				<option value="file16">github.com/Checkmarx/kics/internal/storage/memory.go (94.7%)</option>
				
				<option value="file17">github.com/Checkmarx/kics/internal/tracker/ci.go (84.6%)</option>
				
				<option value="file18">github.com/Checkmarx/kics/pkg/analyzer/analyzer.go (93.9%)</option>
				
				<option value="file19">github.com/Checkmarx/kics/pkg/builder/engine/engine.go (71.8%)</option>
				
				<option value="file20">github.com/Checkmarx/kics/pkg/builder/model/model.go (100.0%)</option>
				
				<option value="file21">github.com/Checkmarx/kics/pkg/builder/parser/tag/tag_parser.go (92.0%)</option>
				
				<option value="file22">github.com/Checkmarx/kics/pkg/builder/writer/rego.go (89.8%)</option>
				
				<option value="file23">github.com/Checkmarx/kics/pkg/descriptions/client.go (54.0%)</option>
				
				<option value="file24">github.com/Checkmarx/kics/pkg/descriptions/descriptions.go (85.7%)</option>
				
				<option value="file25">github.com/Checkmarx/kics/pkg/detector/default_detect.go (100.0%)</option>
				
				<option value="file26">github.com/Checkmarx/kics/pkg/detector/detector.go (53.8%)</option>
				
				<option value="file27">github.com/Checkmarx/kics/pkg/detector/docker/docker_detect.go (85.0%)</option>
				
				<option value="file28">github.com/Checkmarx/kics/pkg/detector/helm/helm_detect.go (88.2%)</option>
				
				<option value="file29">github.com/Checkmarx/kics/pkg/detector/helper.go (93.9%)</option>
				
				<option value="file30">github.com/Checkmarx/kics/pkg/detector/search_line_detector.go (95.0%)</option>
				
				<option value="file31">github.com/Checkmarx/kics/pkg/engine/inspector.go (78.5%)</option>
				
				<option value="file32">github.com/Checkmarx/kics/pkg/engine/provider/extract.go (89.0%)</option>
				
				<option value="file33">github.com/Checkmarx/kics/pkg/engine/provider/filesystem.go (78.0%)</option>
				
				<option value="file34">github.com/Checkmarx/kics/pkg/engine/secrets/inspector.go (87.1%)</option>
				
				<option value="file35">github.com/Checkmarx/kics/pkg/engine/similarity/similarity_id.go (94.7%)</option>
				
				<option value="file36">github.com/Checkmarx/kics/pkg/engine/source/filesystem.go (66.1%)</option>
				
				<option value="file37">github.com/Checkmarx/kics/pkg/engine/source/source.go (67.9%)</option>
				
				<option value="file38">github.com/Checkmarx/kics/pkg/engine/vulnerability_builder.go (85.0%)</option>
				
				<option value="file39">github.com/Checkmarx/kics/pkg/engine/vulnerability_utils.go (84.1%)</option>
				
				<option value="file40">github.com/Checkmarx/kics/pkg/kics/resolver_sink.go (0.0%)</option>
				
				<option value="file41">github.com/Checkmarx/kics/pkg/kics/service.go (29.7%)</option>
				
				<option value="file42">github.com/Checkmarx/kics/pkg/kics/sink.go (0.0%)</option>
				
				<option value="file43">github.com/Checkmarx/kics/pkg/model/model.go (89.7%)</option>
				
				<option value="file44">github.com/Checkmarx/kics/pkg/model/model_easyjson.go (34.7%)</option>
				
				<option value="file45">github.com/Checkmarx/kics/pkg/model/model_yaml.go (93.5%)</option>
				
				<option value="file46">github.com/Checkmarx/kics/pkg/model/summary.go (89.8%)</option>
				
				<option value="file47">github.com/Checkmarx/kics/pkg/parser/docker/parser.go (90.9%)</option>
				
				<option value="file48">github.com/Checkmarx/kics/pkg/parser/json/json_line.go (91.5%)</option>
				
				<option value="file49">github.com/Checkmarx/kics/pkg/parser/json/parser.go (78.6%)</option>
				
				<option value="file50">github.com/Checkmarx/kics/pkg/parser/parser.go (73.4%)</option>
				
				<option value="file51">github.com/Checkmarx/kics/pkg/parser/terraform/converter/default.go (79.5%)</option>
				
				<option value="file52">github.com/Checkmarx/kics/pkg/parser/terraform/terraform.go (82.9%)</option>
				
				<option value="file53">github.com/Checkmarx/kics/pkg/parser/terraform/variables.go (92.2%)</option>
				
				<option value="file54">github.com/Checkmarx/kics/pkg/parser/utils/certificate_utils.go (81.6%)</option>
				
				<option value="file55">github.com/Checkmarx/kics/pkg/parser/utils/file_utils.go (64.0%)</option>
				
				<option value="file56">github.com/Checkmarx/kics/pkg/parser/utils/swagger_utils.go (84.6%)</option>
				
				<option value="file57">github.com/Checkmarx/kics/pkg/parser/yaml/parser.go (84.6%)</option>
				
				<option value="file58">github.com/Checkmarx/kics/pkg/progress/circle/circle_progress.go (71.4%)</option>
				
				<option value="file59">github.com/Checkmarx/kics/pkg/progress/counter/counter_progress.go (90.9%)</option>
				
				<option value="file60">github.com/Checkmarx/kics/pkg/progress/progress.go (100.0%)</option>
				
				<option value="file61">github.com/Checkmarx/kics/pkg/report/commons.go (81.6%)</option>
				
				<option value="file62">github.com/Checkmarx/kics/pkg/report/gitlab_sast.go (93.3%)</option>
				
				<option value="file63">github.com/Checkmarx/kics/pkg/report/html.go (90.0%)</option>
				
				<option value="file64">github.com/Checkmarx/kics/pkg/report/json.go (92.3%)</option>
				
				<option value="file65">github.com/Checkmarx/kics/pkg/report/model/gitlab_sast.go (75.0%)</option>
				
				<option value="file66">github.com/Checkmarx/kics/pkg/report/model/sarif.go (93.6%)</option>
				
				<option value="file67">github.com/Checkmarx/kics/pkg/report/model/sarif_categories.go (100.0%)</option>
				
				<option value="file68">github.com/Checkmarx/kics/pkg/report/pdf.go (83.3%)</option>
				
				<option value="file69">github.com/Checkmarx/kics/pkg/report/sarif.go (90.9%)</option>
				
				<option value="file70">github.com/Checkmarx/kics/pkg/resolver/helm/helm.go (88.7%)</option>
				
				<option value="file71">github.com/Checkmarx/kics/pkg/resolver/helm/resolver.go (89.4%)</option>
				
				<option value="file72">github.com/Checkmarx/kics/pkg/resolver/resolver.go (90.5%)</option>
				
				<option value="file73">github.com/Checkmarx/kics/pkg/scanner/scanner.go (56.4%)</option>
				
				<option value="file74">github.com/Checkmarx/kics/pkg/utils/map.go (100.0%)</option>
				
				<option value="file75">github.com/Checkmarx/kics/test/helpers.go (15.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package flags

import (
        "encoding/json"
        "regexp"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/internal/console/helpers"
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
)

var (
        flagsMultiStrReferences = make(map[string]*[]string)
        flagsStrReferences      = make(map[string]*string)
        flagsBoolReferences     = make(map[string]*bool)
        flagsIntReferences      = make(map[string]*int)

        validations = make(map[string][]string)
)

type flagJSON struct {
        FlagType       string
        ShorthandFlag  string
        DefaultValue   *string
        Usage          string
        Hidden         bool
        Deprecated     bool
        DeprecatedInfo string
        Validation     string
}

func evalUsage(usage string) string <span class="cov5" title="3">{
        variables := map[string]string{
                "sliceInstructions":  "can be provided multiple times or as a comma separated string",
                "supportedLogLevels": strings.Join(constants.AvailableLogLevels, ","),
                "supportedPlatforms": strings.Join(source.ListSupportedPlatforms(), ", "),
                "supportedProviders": strings.Join(source.ListSupportedCloudProviders(), ", "),
                "supportedReports":   strings.Join(append([]string{"all"}, helpers.ListReportFormats()...), ", "),
                "defaultLogFile":     constants.DefaultLogFile,
                "logFormatPretty":    constants.LogFormatPretty,
                "logFormatJSON":      constants.LogFormatJSON,
        }
        variableRegex := regexp.MustCompile(`\$\{(\w+)\}`)
        match := variableRegex.FindAllStringSubmatch(usage, -1)
        for i := range match </span><span class="cov5" title="3">{
                usage = strings.ReplaceAll(usage, "${"+match[i][1]+"}", variables[match[i][1]])
        }</span>
        <span class="cov5" title="3">return usage</span>
}

func checkHiddenAndDeprecated(flagSet *pflag.FlagSet, flagName string, flagProps flagJSON) error <span class="cov0" title="0">{ //nolint:gocritic
        if flagProps.Hidden </span><span class="cov0" title="0">{
                err := flagSet.MarkHidden(flagName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Loading flags: could not mark flag as hidden")
                        return err
                }</span>
        }
        <span class="cov0" title="0">if flagProps.Deprecated </span><span class="cov0" title="0">{
                err := flagSet.MarkDeprecated(flagName, flagProps.DeprecatedInfo)
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Loading flags: could not mark flag as deprecated")
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// InitJSONFlags initialize cobra flags
func InitJSONFlags(cmd *cobra.Command, flagsListContent string, persistentFlag bool) error <span class="cov0" title="0">{
        var flagsList map[string]flagJSON
        err := json.Unmarshal([]byte(flagsListContent), &amp;flagsList)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Loading flags: could not unmarshal flags")
                return err
        }</span>

        <span class="cov0" title="0">flagSet := cmd.Flags()
        if persistentFlag </span><span class="cov0" title="0">{
                flagSet = cmd.PersistentFlags()
        }</span>

        <span class="cov0" title="0">for flagName, flagProps := range flagsList </span><span class="cov0" title="0">{
                flagProps.Usage = evalUsage(flagProps.Usage)

                switch flagProps.FlagType </span>{
                case "multiStr":<span class="cov0" title="0">
                        var flag []string
                        flagsMultiStrReferences[flagName] = &amp;flag
                        defaultValues := make([]string, 0)
                        if flagProps.DefaultValue != nil </span><span class="cov0" title="0">{
                                defaultValues = strings.Split(*flagProps.DefaultValue, ",")
                        }</span>
                        <span class="cov0" title="0">flagSet.StringSliceVarP(flagsMultiStrReferences[flagName], flagName, flagProps.ShorthandFlag, defaultValues, flagProps.Usage)</span>
                case "str":<span class="cov0" title="0">
                        var flag string
                        flagsStrReferences[flagName] = &amp;flag
                        flagSet.StringVarP(flagsStrReferences[flagName], flagName, flagProps.ShorthandFlag, *flagProps.DefaultValue, flagProps.Usage)</span>
                case "bool":<span class="cov0" title="0">
                        var flag bool
                        flagsBoolReferences[flagName] = &amp;flag
                        defaultValue, err := strconv.ParseBool(*flagProps.DefaultValue)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Err(err).Msg("Loading flags: could not convert default values")
                                return err
                        }</span>
                        <span class="cov0" title="0">flagSet.BoolVarP(flagsBoolReferences[flagName], flagName, flagProps.ShorthandFlag, defaultValue, flagProps.Usage)</span>
                case "int":<span class="cov0" title="0">
                        var flag int
                        flagsIntReferences[flagName] = &amp;flag
                        defaultValue, err := strconv.Atoi(*flagProps.DefaultValue)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Err(err).Msg("Loading flags: could not convert default values")
                                return err
                        }</span>
                        <span class="cov0" title="0">flagSet.IntVarP(flagsIntReferences[flagName], flagName, flagProps.ShorthandFlag, defaultValue, flagProps.Usage)</span>
                default:<span class="cov0" title="0">
                        log.Error().Msgf("Flag %s has unknown type %s", flagName, flagProps.FlagType)</span>
                }

                <span class="cov0" title="0">err := checkHiddenAndDeprecated(flagSet, flagName, flagProps)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if flagProps.Validation != "" </span><span class="cov0" title="0">{
                        validations[flagName] = strings.Split(flagProps.Validation, ",")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetStrFlag get a string flag by its name
func GetStrFlag(flagName string) string <span class="cov7" title="6">{
        if value, ok := flagsStrReferences[flagName]; ok </span><span class="cov6" title="4">{
                return *value
        }</span>
        <span class="cov3" title="2">log.Debug().Msgf("Could not find string flag %s", flagName)
        return ""</span>
}

// GetMultiStrFlag get a slice of strings flag by its name
func GetMultiStrFlag(flagName string) []string <span class="cov10" title="11">{
        if value, ok := flagsMultiStrReferences[flagName]; ok </span><span class="cov9" title="9">{
                return *value
        }</span>
        <span class="cov3" title="2">log.Debug().Msgf("Could not find string slice flag %s", flagName)
        return []string{}</span>
}

// GetBoolFlag get a boolean flag by its name
func GetBoolFlag(flagName string) bool <span class="cov3" title="2">{
        if value, ok := flagsBoolReferences[flagName]; ok </span><span class="cov1" title="1">{
                return *value
        }</span>
        <span class="cov1" title="1">log.Debug().Msgf("Could not find boolean flag %s", flagName)
        return false</span>
}

// GetIntFlag get a integer flag by its name
func GetIntFlag(flagName string) int <span class="cov3" title="2">{
        if value, ok := flagsIntReferences[flagName]; ok </span><span class="cov1" title="1">{
                return *value
        }</span>
        <span class="cov1" title="1">log.Debug().Msgf("Could not find integer flag %s", flagName)
        return -1</span>
}

// SetStrFlag set a string flag using its name
func SetStrFlag(flagName, value string) <span class="cov3" title="2">{
        if _, ok := flagsStrReferences[flagName]; ok </span><span class="cov1" title="1">{
                *flagsStrReferences[flagName] = value
        }</span> else<span class="cov1" title="1"> {
                log.Debug().Msgf("Could not set string flag %s", flagName)
        }</span>
}

// SetMultiStrFlag set a slice of strings flag using its name
func SetMultiStrFlag(flagName string, value []string) <span class="cov3" title="2">{
        if _, ok := flagsMultiStrReferences[flagName]; ok </span><span class="cov1" title="1">{
                *flagsMultiStrReferences[flagName] = value
        }</span> else<span class="cov1" title="1"> {
                log.Debug().Msgf("Could not set string slice flag %s", flagName)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package flags

import "regexp"

type flagValidationFuncsMap map[string]func(flagName string) error

var flagValidationFuncs = flagValidationFuncsMap{
        "sliceFlagsShouldNotStartWithFlags": sliceFlagsShouldNotStartWithFlags,
        "validateMultiStrEnum":              validateMultiStrEnum,
        "validateStrEnum":                   validateStrEnum,
        "allQueriesID":                      allQueriesID,
}

func isQueryID(id string) bool <span class="cov5" title="5">{
        re := regexp.MustCompile(`^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$`)
        return re.MatchString(id)
}</span>

func convertSliceToDummyMap(slice []string) map[string]string <span class="cov5" title="5">{
        returnMap := make(map[string]string, len(slice))
        for _, element := range slice </span><span class="cov10" title="22">{
                returnMap[element] = ""
        }</span>
        <span class="cov5" title="5">return returnMap</span>
}

// Validate validate if flag values are ok, if not, returns an error
func Validate() error <span class="cov0" title="0">{
        for validation, validationFuncs := range validations </span><span class="cov0" title="0">{
                for _, validationFunc := range validationFuncs </span><span class="cov0" title="0">{
                        if function, ok := flagValidationFuncs[validationFunc]; ok </span><span class="cov0" title="0">{
                                if err := function(validation); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package flags

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/Checkmarx/kics/internal/console/helpers"
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/utils"
)

var validMultiStrEnums = map[string]map[string]string{
        CloudProviderFlag:     constants.AvailableCloudProviders,
        ExcludeCategoriesFlag: constants.AvailableCategories,
        ExcludeSeveritiesFlag: convertSliceToDummyMap(constants.AvailableSeverities),
        FailOnFlag:            convertSliceToDummyMap(constants.AvailableSeverities),
        ReportFormatsFlag:     convertSliceToDummyMap(append([]string{"all"}, helpers.ListReportFormats()...)),
        TypeFlag:              constants.AvailablePlatforms,
}

func sliceFlagsShouldNotStartWithFlags(flagName string) error <span class="cov3" title="3">{
        values := GetMultiStrFlag(flagName)
        re := regexp.MustCompile(`^--[a-z-]+$`)
        if len(values) &gt; 0 </span><span class="cov3" title="3">{
                firstArg := values[0]
                if strings.HasPrefix(firstArg, "-") &amp;&amp; len(firstArg) == 2 || re.MatchString(firstArg) </span><span class="cov2" title="2">{
                        return fmt.Errorf("flag needs an argument: %s", flagName)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func allQueriesID(flagName string) error <span class="cov2" title="2">{
        queriesID := GetMultiStrFlag(flagName)
        for _, queryID := range queriesID </span><span class="cov3" title="3">{
                if !isQueryID(queryID) </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid argument --%s: %s is not a valid query ID", flagName, queryID)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func validateMultiStrEnum(flagName string) error <span class="cov2" title="2">{
        enums := GetMultiStrFlag(flagName)
        invalidEnum := make([]string, 0)
        caseInsensitiveMap := make(map[string]string)
        for key, value := range validMultiStrEnums[flagName] </span><span class="cov10" title="28">{
                caseInsensitiveMap[strings.ToLower(key)] = value
        }</span>
        <span class="cov2" title="2">for _, enum := range enums </span><span class="cov3" title="3">{
                if _, ok := caseInsensitiveMap[strings.ToLower(enum)]; enum != "" &amp;&amp; !ok </span><span class="cov1" title="1">{
                        invalidEnum = append(invalidEnum, enum)
                }</span>
        }
        <span class="cov2" title="2">validEnumsValues := utils.SortedKeys(validMultiStrEnums[flagName])
        if len(invalidEnum) &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf(
                        "unknown argument(s) for --%s: %s\nvalid arguments:\n  %s",
                        flagName,
                        strings.Join(invalidEnum, ", "),
                        strings.Join(validEnumsValues, "\n  "),
                )
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package flags

import (
        "fmt"
        "strings"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/utils"
)

var validStrEnums = map[string]map[string]string{
        LogLevelFlag: convertSliceToDummyMap(constants.AvailableLogLevels),
}

func validateStrEnum(flagName string) error <span class="cov3" title="2">{
        value := GetStrFlag(flagName)
        caseInsensitiveMap := make(map[string]string)
        for key, value := range validStrEnums[flagName] </span><span class="cov10" title="12">{
                caseInsensitiveMap[strings.ToLower(key)] = value
        }</span>
        <span class="cov3" title="2">validEnumsValues := utils.SortedKeys(validStrEnums[flagName])
        if _, ok := caseInsensitiveMap[strings.ToLower(value)]; value != "" &amp;&amp; !ok </span><span class="cov1" title="1">{
                return fmt.Errorf(
                        "unknown argument for --%s: %s\nvalid arguments:\n  %s",
                        flagName,
                        value,
                        strings.Join(validEnumsValues, "\n  "),
                )
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package console

import (
        "fmt"

        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
)

// NewGenerateIDCmd creates a new instance of the generate-id Command
func NewGenerateIDCmd() *cobra.Command <span class="cov10" title="12">{
        return &amp;cobra.Command{
                Use:   "generate-id",
                Short: "Generates uuid for query",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        _, err := fmt.Fprintln(cmd.OutOrStdout(), uuid.New().String())
                        if err != nil </span><span class="cov0" title="0">{
                                log.Err(err).Msg("failed to get uuid")
                        }</span>
                        <span class="cov1" title="1">return err</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package helpers

import (
        "fmt"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
)

var shouldIgnore string
var shouldFail map[string]struct{}

// ResultsExitCode calculate exit code base on severity of results, returns 0 if no results was reported
func ResultsExitCode(summary *model.Summary) int <span class="cov5" title="4">{
        // severityArr is needed to make sure 'for' cycle is made in an ordered fashion
        severityArr := []model.Severity{"HIGH", "MEDIUM", "LOW", "INFO"}
        codeMap := map[model.Severity]int{"HIGH": 50, "MEDIUM": 40, "LOW": 30, "INFO": 20}
        exitMap := summary.SeveritySummary.SeverityCounters
        for _, severity := range severityArr </span><span class="cov7" title="8">{
                if _, reportSeverity := shouldFail[strings.ToLower(string(severity))]; !reportSeverity </span><span class="cov5" title="4">{
                        continue</span>
                }
                <span class="cov5" title="4">if exitMap[severity] &gt; 0 </span><span class="cov4" title="3">{
                        return codeMap[severity]
                }</span>
        }
        <span class="cov1" title="1">return 0</span>
}

// InitShouldIgnoreArg initializes what kind of errors should be used on exit codes
func InitShouldIgnoreArg(arg string) error <span class="cov7" title="7">{
        validArgs := []string{"none", "all", "results", "errors"}
        for _, validArg := range validArgs </span><span class="cov10" title="16">{
                if strings.EqualFold(validArg, arg) </span><span class="cov6" title="6">{
                        shouldIgnore = strings.ToLower(arg)
                        return nil
                }</span>
        }
        <span class="cov1" title="1">return fmt.Errorf("unknown argument for --ignore-on-exit: %s\nvalid arguments:\n  %s", arg, strings.Join(validArgs, "\n  "))</span>
}

// InitShouldFailArg initializes which kind of vulnerability severity should changes exit code
func InitShouldFailArg(args []string) error <span class="cov5" title="4">{
        possibleArgs := map[string]struct{}{
                "high":   {},
                "medium": {},
                "low":    {},
                "info":   {},
        }
        if len(args) == 0 </span><span class="cov1" title="1">{
                shouldFail = possibleArgs
                return nil
        }</span>

        <span class="cov4" title="3">argsConverted := make(map[string]struct{})
        for _, arg := range args </span><span class="cov6" title="6">{
                if _, ok := possibleArgs[strings.ToLower(arg)]; !ok </span><span class="cov1" title="1">{
                        validArgs := []string{"high", "medium", "low", "info"}
                        return fmt.Errorf("unknown argument for --fail-on: %s\nvalid arguments:\n  %s", arg, strings.Join(validArgs, "\n  "))
                }</span>
                <span class="cov6" title="5">argsConverted[strings.ToLower(arg)] = struct{}{}</span>
        }

        <span class="cov3" title="2">shouldFail = argsConverted
        return nil</span>
}

// ShowError returns true if should show error, otherwise returns false
func ShowError(kind string) bool <span class="cov5" title="4">{
        return strings.EqualFold(shouldIgnore, "none") || (!strings.EqualFold(shouldIgnore, "all") &amp;&amp; !strings.EqualFold(shouldIgnore, kind))
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package helpers

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "github.com/BurntSushi/toml"
        "github.com/Checkmarx/kics/internal/metrics"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/progress"
        "github.com/Checkmarx/kics/pkg/report"
        "github.com/gookit/color"
        "github.com/hashicorp/hcl"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "gopkg.in/yaml.v3"
)

const (
        wordWrapCount = 5
)

var reportGenerators = map[string]func(path, filename string, body interface{}) error{
        "json":   report.PrintJSONReport,
        "sarif":  report.PrintSarifReport,
        "html":   report.PrintHTMLReport,
        "glsast": report.PrintGitlabSASTReport,
        "pdf":    report.PrintPdfReport,
}

// Printer wil print console output with colors
// Medium is for medium sevevity results
// High is for high sevevity results
// Low is for low sevevity results
// Info is for info sevevity results
// Success is for successful prints
// Line is the color to print the line with the vulnerability
// minVersion is a bool that if true will print the results output in a minimum version
type Printer struct {
        Medium  color.RGBColor
        High    color.RGBColor
        Low     color.RGBColor
        Info    color.RGBColor
        Success color.RGBColor
        Line    color.RGBColor
        minimal bool
}

// WordWrap Wraps text at the specified number of words
func WordWrap(s, identation string, limit int) string <span class="cov4" title="3">{
        if strings.TrimSpace(s) == "" </span><span class="cov1" title="1">{
                return s
        }</span>

        <span class="cov3" title="2">wordSlice := strings.Fields(s)
        var result string

        for len(wordSlice) &gt;= 1 </span><span class="cov4" title="3">{
                result = result + identation + strings.Join(wordSlice[:limit], " ") + "\r\n"

                wordSlice = wordSlice[limit:]
                if len(wordSlice) &lt; limit </span><span class="cov3" title="2">{
                        limit = len(wordSlice)
                }</span>
        }
        <span class="cov3" title="2">return result</span>
}

// PrintResult prints on output the summary results
func PrintResult(summary *model.Summary, failedQueries map[string]error, printer *Printer) error <span class="cov3" title="2">{
        log.Debug().Msg("helpers.PrintResult()")
        fmt.Printf("Files scanned: %d\n", summary.ScannedFiles)
        fmt.Printf("Parsed files: %d\n", summary.ParsedFiles)
        fmt.Printf("Queries loaded: %d\n", summary.TotalQueries)

        fmt.Printf("Queries failed to execute: %d\n\n", summary.FailedToExecuteQueries)
        for queryName, err := range failedQueries </span><span class="cov0" title="0">{
                fmt.Printf("\t- %s:\n", queryName)
                fmt.Printf("%s", WordWrap(err.Error(), "\t\t", wordWrapCount))
        }</span>
        <span class="cov3" title="2">fmt.Printf("------------------------------------\n\n")
        for index := range summary.Queries </span><span class="cov5" title="4">{
                idx := len(summary.Queries) - index - 1
                fmt.Printf(
                        "%s, Severity: %s, Results: %d\n",
                        printer.PrintBySev(summary.Queries[idx].QueryName, string(summary.Queries[idx].Severity)),
                        printer.PrintBySev(string(summary.Queries[idx].Severity), string(summary.Queries[idx].Severity)),
                        len(summary.Queries[idx].Files),
                )
                if !printer.minimal </span><span class="cov3" title="2">{
                        if summary.Queries[idx].CISDescriptionID != "" </span><span class="cov0" title="0">{
                                fmt.Printf("%s %s\n", printer.Bold("CIS ID:"), summary.Queries[idx].CISDescriptionIDFormatted)
                                fmt.Printf("%s %s\n", printer.Bold("Title:"), summary.Queries[idx].CISDescriptionTitle)
                                fmt.Printf("%s %s\n", printer.Bold("Description:"), summary.Queries[idx].CISDescriptionTextFormatted)
                        }</span> else<span class="cov3" title="2"> {
                                fmt.Printf("%s %s\n", printer.Bold("Description:"), summary.Queries[idx].Description)
                        }</span>
                        <span class="cov3" title="2">fmt.Printf("%s %s\n\n", printer.Bold("Platform:"), summary.Queries[idx].Platform)</span>
                }
                <span class="cov5" title="4">printFiles(&amp;summary.Queries[idx], printer)</span>
        }
        <span class="cov3" title="2">fmt.Printf("\nResults Summary:\n")
        printSeverityCounter(model.SeverityHigh, summary.SeveritySummary.SeverityCounters[model.SeverityHigh], printer.High)
        printSeverityCounter(model.SeverityMedium, summary.SeveritySummary.SeverityCounters[model.SeverityMedium], printer.Medium)
        printSeverityCounter(model.SeverityLow, summary.SeveritySummary.SeverityCounters[model.SeverityLow], printer.Low)
        printSeverityCounter(model.SeverityInfo, summary.SeveritySummary.SeverityCounters[model.SeverityInfo], printer.Info)
        fmt.Printf("TOTAL: %d\n\n", summary.SeveritySummary.TotalCounter)

        log.Info().Msgf("Files scanned: %d", summary.ScannedFiles)
        log.Info().Msgf("Parsed files: %d", summary.ParsedFiles)
        log.Info().Msgf("Queries loaded: %d", summary.TotalQueries)
        log.Info().Msgf("Queries failed to execute: %d", summary.FailedToExecuteQueries)
        log.Info().Msg("Inspector stopped")

        return nil</span>
}

func printSeverityCounter(severity string, counter int, printColor color.RGBColor) <span class="cov7" title="8">{
        fmt.Printf("%s: %d\n", printColor.Sprint(severity), counter)
}</span>

func printFiles(query *model.VulnerableQuery, printer *Printer) <span class="cov5" title="4">{
        for fileIdx := range query.Files </span><span class="cov6" title="6">{
                fmt.Printf("\t%s %s:%s\n", printer.PrintBySev(fmt.Sprintf("[%d]:", fileIdx+1), string(query.Severity)),
                        query.Files[fileIdx].FileName, printer.Success.Sprint(query.Files[fileIdx].Line))
                if !printer.minimal </span><span class="cov4" title="3">{
                        fmt.Println()
                        for _, line := range query.Files[fileIdx].VulnLines </span><span class="cov0" title="0">{
                                if line.Position == query.Files[fileIdx].Line </span><span class="cov0" title="0">{
                                        printer.Line.Printf("\t\t%03d: %s\n", line.Position, line.Line)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("\t\t%03d: %s\n", line.Position, line.Line)
                                }</span>
                        }
                        <span class="cov4" title="3">fmt.Print("\n\n")</span>
                }
        }
}

// CustomConsoleWriter creates an output to print log in a files
func CustomConsoleWriter(fileLogger *zerolog.ConsoleWriter) zerolog.ConsoleWriter <span class="cov0" title="0">{
        fileLogger.FormatLevel = func(i interface{}) string </span><span class="cov0" title="0">{
                return strings.ToUpper(fmt.Sprintf("| %-6s|", i))
        }</span>

        <span class="cov0" title="0">fileLogger.FormatFieldName = func(i interface{}) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:", i)
        }</span>

        <span class="cov0" title="0">fileLogger.FormatErrFieldName = func(i interface{}) string </span><span class="cov0" title="0">{
                return "ERROR:"
        }</span>

        <span class="cov0" title="0">fileLogger.FormatFieldValue = func(i interface{}) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s", i)
        }</span>

        <span class="cov0" title="0">return *fileLogger</span>
}

// FileAnalyzer determines the type of extension in the passed config file by its content
func FileAnalyzer(path string) (string, error) <span class="cov8" title="11">{
        ostat, err := os.Open(filepath.Clean(path))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="11">rc, err := io.ReadAll(ostat)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="11">var temp map[string]interface{}

        // CxSAST query under review
        if err := json.Unmarshal(rc, &amp;temp); err == nil </span><span class="cov3" title="2">{
                return "json", nil
        }</span>

        // CxSAST query under review
        <span class="cov7" title="9">if err := yaml.Unmarshal(rc, &amp;temp); err == nil </span><span class="cov4" title="3">{
                return "yaml", nil
        }</span>

        // CxSAST query under review
        <span class="cov6" title="6">if _, err := toml.Decode(string(rc), &amp;temp); err == nil </span><span class="cov3" title="2">{
                return "toml", nil
        }</span>

        // CxSAST query under review
        <span class="cov5" title="4">if c, err := hcl.Parse(string(rc)); err == nil </span><span class="cov3" title="2">{
                if err = hcl.DecodeObject(&amp;temp, c); err == nil </span><span class="cov3" title="2">{
                        return "hcl", nil
                }</span>
        }

        <span class="cov3" title="2">return "", errors.New("invalid configuration file format")</span>
}

// GenerateReport execute each report function to generate report
func GenerateReport(path, filename string, body interface{}, formats []string, proBarBuilder progress.PbBuilder) error <span class="cov5" title="4">{
        log.Debug().Msgf("helpers.GenerateReport()")
        metrics.Metric.Start("generate_report")

        progressBar := proBarBuilder.BuildCircle("Generating Reports: ")

        var err error = nil
        progressBar.Start()
        defer progressBar.Close()

        for _, format := range formats </span><span class="cov5" title="4">{
                if err = reportGenerators[format](path, filename, body); err != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("Failed to generate %s report", format)
                        break</span>
                }
        }
        <span class="cov5" title="4">metrics.Metric.Stop()
        return err</span>
}

// GetExecutableDirectory - returns the path to the directory containing KICS executable
func GetExecutableDirectory() string <span class="cov3" title="2">{
        log.Debug().Msg("helpers.GetExecutableDirectory()")
        path, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
        }</span>
        <span class="cov3" title="2">return filepath.Dir(path)</span>
}

// GetDefaultQueryPath - returns the default query path
func GetDefaultQueryPath(queriesPath string) (string, error) <span class="cov3" title="2">{
        log.Debug().Msg("helpers.GetDefaultQueryPath()")
        executableDirPath := GetExecutableDirectory()
        queriesDirectory := filepath.Join(executableDirPath, queriesPath)
        if _, err := os.Stat(queriesDirectory); os.IsNotExist(err) </span><span class="cov3" title="2">{
                currentWorkDir, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov3" title="2">idx := strings.Index(currentWorkDir, "kics")
                if idx != -1 </span><span class="cov3" title="2">{
                        currentWorkDir = currentWorkDir[:strings.LastIndex(currentWorkDir, "kics")] + "kics"
                }</span>
                <span class="cov3" title="2">queriesDirectory = filepath.Join(currentWorkDir, queriesPath)
                if _, err := os.Stat(queriesDirectory); os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return "", err
                }</span>
        }

        <span class="cov1" title="1">log.Debug().Msgf("Queries found in %s", queriesDirectory)
        return queriesDirectory, nil</span>
}

// ListReportFormats return a slice with all supported report formats
func ListReportFormats() []string <span class="cov1" title="1">{
        supportedFormats := make([]string, 0, len(reportGenerators))
        for reportFormats := range reportGenerators </span><span class="cov5" title="5">{
                supportedFormats = append(supportedFormats, reportFormats)
        }</span>
        <span class="cov1" title="1">sort.Strings(supportedFormats)
        return supportedFormats</span>
}

// NewPrinter initializes a new Printer
func NewPrinter(minimal bool) *Printer <span class="cov4" title="3">{
        return &amp;Printer{
                Medium:  color.HEX("#ff7213"),
                High:    color.HEX("#bb2124"),
                Low:     color.HEX("#edd57e"),
                Success: color.HEX("#22bb33"),
                Info:    color.HEX("#5bc0de"),
                Line:    color.HEX("#f0ad4e"),
                minimal: minimal,
        }
}</span>

// PrintBySev will print the output with the specific severity color given the severity of the result
func (p *Printer) PrintBySev(content, sev string) string <span class="cov10" title="19">{
        switch strings.ToUpper(sev) </span>{
        case model.SeverityHigh:<span class="cov7" title="9">
                return p.High.Sprintf(content)</span>
        case model.SeverityMedium:<span class="cov6" title="7">
                return p.Medium.Sprintf(content)</span>
        case model.SeverityLow:<span class="cov1" title="1">
                return p.Low.Sprintf(content)</span>
        case model.SeverityInfo:<span class="cov1" title="1">
                return p.Info.Sprintf(content)</span>
        }
        <span class="cov1" title="1">return content</span>
}

// Bold returns the output in a bold format
func (p *Printer) Bold(content string) string <span class="cov5" title="4">{
        return color.Bold.Sprintf(content)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package console

import (
        "context"
        _ "embed" // Embed kics flags
        "os"
        "time"

        "github.com/Checkmarx/kics/internal/console/flags"
        "github.com/Checkmarx/kics/internal/console/printer"
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/getsentry/sentry-go"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

const (
        scanID = "console"
)

var (
        //go:embed assets/kics-flags.json
        kicsFlagsListContent string

        // warnings - a buffer to accumulate warnings before the printer gets initialized
        warnings = make([]string, 0)

        ctx = context.Background()
)

// NewKICSCmd creates a new instance of the kics Command
func NewKICSCmd() *cobra.Command <span class="cov10" title="12">{
        return &amp;cobra.Command{
                Use:   "kics",
                Short: constants.Fullname,
        }
}</span>

func initialize(rootCmd *cobra.Command) error <span class="cov10" title="12">{
        scanCmd := NewScanCmd()
        rootCmd.AddCommand(NewVersionCmd())
        rootCmd.AddCommand(NewGenerateIDCmd())
        rootCmd.AddCommand(scanCmd)
        rootCmd.AddCommand(NewListPlatformsCmd())

        if err := flags.InitJSONFlags(rootCmd, kicsFlagsListContent, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="12">if err := viper.BindPFlags(rootCmd.PersistentFlags()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="12">return initScanCmd(scanCmd)</span>
}

// Execute starts kics execution
func Execute() error <span class="cov10" title="12">{
        zerolog.SetGlobalLevel(zerolog.InfoLevel)

        enableCrashReport()

        rootCmd := NewKICSCmd()

        if err := initialize(rootCmd); err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Err(err).Msg("Failed to initialize CLI")
                return err
        }</span>

        <span class="cov10" title="12">if err := rootCmd.ExecuteContext(ctx); err != nil </span><span class="cov3" title="2">{
                sentry.CaptureException(err)
                if printer.IsInitialized() </span><span class="cov3" title="2">{
                        log.Err(err).Msg("Failed to run application")
                }</span>
                <span class="cov3" title="2">return err</span>
        }

        <span class="cov9" title="10">return nil</span>
}

func enableCrashReport() <span class="cov10" title="12">{
        enableCrashReport, found := os.LookupEnv("DISABLE_CRASH_REPORT")
        if found &amp;&amp; (enableCrashReport == "0" || enableCrashReport == "false") </span><span class="cov0" title="0">{
                initSentry("")
        }</span> else<span class="cov10" title="12"> {
                initSentry(constants.SentryDSN)
        }</span>
}

func initSentry(dsn string) <span class="cov10" title="12">{
        var err error
        if dsn == "" </span><span class="cov10" title="12">{
                warnings = append(warnings, "KICS crash report disabled")
                err = sentry.Init(sentry.ClientOptions{
                        Release: constants.GetRelease(),
                })
        }</span> else<span class="cov0" title="0"> {
                err = sentry.Init(sentry.ClientOptions{
                        Dsn:     dsn,
                        Release: constants.GetRelease(),
                })
        }</span>
        <span class="cov10" title="12">if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Failed to initialize sentry")
        }</span>
        <span class="cov10" title="12">sentry.Flush(constants.SentryRefreshRate * time.Second)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package console

import (
        "fmt"

        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/spf13/cobra"
)

// NewListPlatformsCmd creates a new instance of the list-platforms Command
func NewListPlatformsCmd() *cobra.Command <span class="cov10" title="12">{
        return &amp;cobra.Command{
                Use:   "list-platforms",
                Short: "List supported platforms",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        for _, v := range source.ListSupportedPlatforms() </span><span class="cov8" title="7">{
                                fmt.Fprintf(cmd.OutOrStdout(), "%s\n", v)
                        }</span>
                        <span class="cov1" title="1">return nil</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package printer

import (
        "io"
        "os"
        "path/filepath"
        "sort"
        "strconv"
        "strings"

        consoleFlags "github.com/Checkmarx/kics/internal/console/flags"
        consoleHelpers "github.com/Checkmarx/kics/internal/console/helpers"
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/gookit/color"
        "github.com/pkg/errors"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/pflag"
)

var (
        optionsMap = map[string]func(opt interface{}, changed bool) error{
                consoleFlags.CIFlag: func(opt interface{}, changed bool) error <span class="cov0" title="0">{
                        return nil
                }</span>,
                consoleFlags.LogFileFlag:  LogFile,
                consoleFlags.LogLevelFlag: LogLevel,
                consoleFlags.LogPathFlag:  LogPath,
                consoleFlags.SilentFlag: func(opt interface{}, changed bool) error <span class="cov0" title="0">{
                        return nil
                }</span>,
                consoleFlags.VerboseFlag: Verbose,
                consoleFlags.LogFormatFlag: func(opt interface{}, changed bool) error <span class="cov0" title="0">{
                        return nil
                }</span>,
                consoleFlags.NoColorFlag: NoColor,
        }

        optionsOrderMap = map[int]string{
                1: consoleFlags.CIFlag,
                2: consoleFlags.LogFileFlag,
                3: consoleFlags.LogLevelFlag,
                4: consoleFlags.LogPathFlag,
                5: consoleFlags.SilentFlag,
                6: consoleFlags.VerboseFlag,
                7: consoleFlags.LogFormatFlag,
                8: consoleFlags.NoColorFlag,
        }

        consoleLogger = zerolog.ConsoleWriter{Out: io.Discard}
        fileLogger    = zerolog.ConsoleWriter{Out: io.Discard}

        outFileLogger    interface{}
        outConsoleLogger = io.Discard

        loggerFile  interface{}
        initialized bool
)

// SetupPrinter - configures stdout and log options with given FlagSet
func SetupPrinter(flags *pflag.FlagSet) error <span class="cov0" title="0">{
        err := validateFlags()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">keys := make([]int, 0, len(optionsOrderMap))
        for k := range optionsOrderMap </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>

        <span class="cov0" title="0">sort.Ints(keys)

        for _, key := range keys </span><span class="cov0" title="0">{
                f := flags.Lookup(optionsOrderMap[key])
                switch f.Value.Type() </span>{
                case "string":<span class="cov0" title="0">
                        value := f.Value.String()
                        err = optionsMap[optionsOrderMap[key]](value, f.Changed)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case "bool":<span class="cov0" title="0">
                        value, errBool := strconv.ParseBool(f.Value.String())
                        if errBool != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">err = optionsMap[optionsOrderMap[key]](value, f.Changed)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // LogFormat needs to be the last option
        <span class="cov0" title="0">logFormat := strings.ToLower(consoleFlags.GetStrFlag(consoleFlags.LogFormatFlag))
        err = LogFormat(logFormat)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = Silent(consoleFlags.GetBoolFlag(consoleFlags.SilentFlag))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = CI(consoleFlags.GetBoolFlag(consoleFlags.CIFlag))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">initialized = true
        return nil</span>
}

// IsInitialized returns true if printer is ready, false otherwise
func IsInitialized() bool <span class="cov1" title="1">{
        return initialized
}</span>

func validateFlags() error <span class="cov0" title="0">{
        if consoleFlags.GetBoolFlag(consoleFlags.VerboseFlag) &amp;&amp; consoleFlags.GetBoolFlag(consoleFlags.SilentFlag) </span><span class="cov0" title="0">{
                return errors.New("can't provide 'silent' and 'verbose' flags simultaneously")
        }</span>

        <span class="cov0" title="0">if consoleFlags.GetBoolFlag(consoleFlags.VerboseFlag) &amp;&amp; consoleFlags.GetBoolFlag(consoleFlags.CIFlag) </span><span class="cov0" title="0">{
                return errors.New("can't provide 'verbose' and 'ci' flags simultaneously")
        }</span>

        <span class="cov0" title="0">if consoleFlags.GetBoolFlag(consoleFlags.CIFlag) &amp;&amp; consoleFlags.GetBoolFlag(consoleFlags.SilentFlag) </span><span class="cov0" title="0">{
                return errors.New("can't provide 'silent' and 'ci' flags simultaneously")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NoColor - disables ASCII color codes
func NoColor(opt interface{}, changed bool) error <span class="cov1" title="1">{
        noColor := opt.(bool)
        if noColor </span><span class="cov1" title="1">{
                color.Disable()
                consoleLogger.NoColor = true
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Verbose - redirects log entries to stdout
func Verbose(opt interface{}, changed bool) error <span class="cov1" title="1">{
        verbose := opt.(bool)
        if verbose </span><span class="cov1" title="1">{
                consoleLogger = zerolog.ConsoleWriter{Out: os.Stdout}
                outConsoleLogger = os.Stdout
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Silent - disables stdout output
func Silent(opt interface{}) error <span class="cov1" title="1">{
        silent := opt.(bool)
        if silent </span><span class="cov1" title="1">{
                color.SetOutput(io.Discard)
                os.Stdout = nil
                log.Logger = log.Output(zerolog.MultiLevelWriter(io.Discard, outFileLogger.(io.Writer)))
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// CI - enable only log messages to CLI output
func CI(opt interface{}) error <span class="cov1" title="1">{
        ci := opt.(bool)
        if ci </span><span class="cov1" title="1">{
                color.SetOutput(io.Discard)
                log.Logger = log.Output(zerolog.MultiLevelWriter(outConsoleLogger, outFileLogger.(io.Writer)))
                os.Stdout = nil
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// LogFormat - configures the logs format (JSON,pretty).
func LogFormat(logFormat string) error <span class="cov6" title="3">{
        if logFormat == constants.LogFormatJSON </span><span class="cov1" title="1">{
                log.Logger = log.Output(zerolog.MultiLevelWriter(outConsoleLogger, loggerFile.(io.Writer)))
                outFileLogger = loggerFile
                outConsoleLogger = os.Stdout
        }</span> else<span class="cov4" title="2"> if logFormat == constants.LogFormatPretty </span><span class="cov1" title="1">{
                fileLogger = consoleHelpers.CustomConsoleWriter(&amp;zerolog.ConsoleWriter{Out: loggerFile.(io.Writer), NoColor: true})
                log.Logger = log.Output(zerolog.MultiLevelWriter(consoleLogger, fileLogger))
                outFileLogger = fileLogger
                outConsoleLogger = zerolog.ConsoleWriter{Out: os.Stdout, NoColor: true}
        }</span> else<span class="cov1" title="1"> {
                return errors.New("invalid log format")
        }</span>
        <span class="cov4" title="2">return nil</span>
}

// LogPath - sets the log files location
func LogPath(opt interface{}, changed bool) error <span class="cov4" title="2">{
        logPath := opt.(string)
        var err error
        if !changed </span><span class="cov0" title="0">{
                if loggerFile == nil </span><span class="cov0" title="0">{
                        loggerFile = io.Discard
                        return nil
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov4" title="2">if logPath == "" </span><span class="cov1" title="1">{
                logPath, err = getDefaultLogPath()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov1" title="1"> if filepath.Dir(logPath) != "." </span><span class="cov1" title="1">{
                if createErr := os.MkdirAll(filepath.Dir(logPath), os.ModePerm); createErr != nil </span><span class="cov0" title="0">{
                        return createErr
                }</span>
        }

        <span class="cov4" title="2">loggerFile, err = os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="2">return nil</span>
}

// LogFile - enables write to log file
func LogFile(opt interface{}, changed bool) error <span class="cov1" title="1">{
        logFile := opt.(bool)
        if logFile </span><span class="cov1" title="1">{
                logPath, err := getDefaultLogPath()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">loggerFile, err = os.OpenFile(filepath.Clean(logPath), os.O_CREATE|os.O_WRONLY, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">fileLogger = consoleHelpers.CustomConsoleWriter(&amp;zerolog.ConsoleWriter{Out: loggerFile.(io.Writer), NoColor: true})</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// LogLevel - sets log level
func LogLevel(opt interface{}, changed bool) error <span class="cov10" title="6">{
        logLevel := opt.(string)
        switch strings.ToUpper(logLevel) </span>{
        case "TRACE":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.TraceLevel)</span>
        case "DEBUG":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.DebugLevel)</span>
        case "INFO":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.InfoLevel)</span>
        case "WARN":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.WarnLevel)</span>
        case "ERROR":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.ErrorLevel)</span>
        case "FATAL":<span class="cov1" title="1">
                zerolog.SetGlobalLevel(zerolog.FatalLevel)</span>
        }
        <span class="cov10" title="6">return nil</span>
}

func getDefaultLogPath() (string, error) <span class="cov4" title="2">{
        currentWorkDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov4" title="2">return filepath.Join(currentWorkDir, constants.DefaultLogFile), nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package console

import (
        _ "embed" // Embed kics CLI img and scan-flags
        "fmt"
        "os"
        "os/signal"
        "path/filepath"
        "strings"
        "syscall"
        "time"

        "github.com/Checkmarx/kics/assets"
        "github.com/Checkmarx/kics/internal/console/flags"
        consoleHelpers "github.com/Checkmarx/kics/internal/console/helpers"
        internalPrinter "github.com/Checkmarx/kics/internal/console/printer"
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/internal/metrics"
        "github.com/Checkmarx/kics/internal/storage"
        "github.com/Checkmarx/kics/internal/tracker"
        "github.com/Checkmarx/kics/pkg/analyzer"
        "github.com/Checkmarx/kics/pkg/descriptions"
        "github.com/Checkmarx/kics/pkg/engine"
        "github.com/Checkmarx/kics/pkg/engine/provider"
        "github.com/Checkmarx/kics/pkg/engine/secrets"
        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/Checkmarx/kics/pkg/kics"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser"
        dockerParser "github.com/Checkmarx/kics/pkg/parser/docker"
        jsonParser "github.com/Checkmarx/kics/pkg/parser/json"
        terraformParser "github.com/Checkmarx/kics/pkg/parser/terraform"
        yamlParser "github.com/Checkmarx/kics/pkg/parser/yaml"
        "github.com/Checkmarx/kics/pkg/progress"
        "github.com/Checkmarx/kics/pkg/report"
        "github.com/Checkmarx/kics/pkg/resolver"
        "github.com/Checkmarx/kics/pkg/resolver/helm"
        "github.com/Checkmarx/kics/pkg/scanner"
        "github.com/getsentry/sentry-go"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "github.com/spf13/viper"
        "golang.org/x/term"
)

var (
        //go:embed assets/kics-console
        banner string

        //go:embed assets/scan-flags.json
        scanFlagsListContent string
)

const (
        scanCommandStr = "scan"
        initError      = "initialization error - "
)

// NewScanCmd creates a new instance of the scan Command
func NewScanCmd() *cobra.Command <span class="cov4" title="12">{
        return &amp;cobra.Command{
                Use:   scanCommandStr,
                Short: "Executes a scan analysis",
                PersistentPreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov4" title="8">{
                        return preRun(cmd)
                }</span>,
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov3" title="7">{
                        return run(cmd)
                }</span>,
        }
}

func run(cmd *cobra.Command) error <span class="cov3" title="7">{
        changedDefaultQueryPath := cmd.Flags().Lookup(flags.QueriesPath).Changed
        changedDefaultLibrariesPath := cmd.Flags().Lookup(flags.LibrariesPath).Changed
        if err := consoleHelpers.InitShouldIgnoreArg(flags.GetStrFlag(flags.IgnoreOnExitFlag)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="7">if err := consoleHelpers.InitShouldFailArg(flags.GetMultiStrFlag(flags.FailOnFlag)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="7">if flags.GetStrFlag(flags.OutputPathFlag) != "" </span><span class="cov1" title="1">{
                updateReportFormats()
                flags.SetStrFlag(flags.OutputNameFlag, filepath.Base(flags.GetStrFlag(flags.OutputNameFlag)))
                if filepath.Ext(flags.GetStrFlag(flags.OutputPathFlag)) != "" </span><span class="cov1" title="1">{
                        flags.SetStrFlag(flags.OutputPathFlag, filepath.Join(flags.GetStrFlag(flags.OutputPathFlag), string(os.PathSeparator)))
                }</span>
                <span class="cov1" title="1">if err := os.MkdirAll(flags.GetStrFlag(flags.OutputPathFlag), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov3" title="7">if flags.GetStrFlag(flags.PayloadPathFlag) != "" &amp;&amp; filepath.Dir(flags.GetStrFlag(flags.PayloadPathFlag)) != "." </span><span class="cov0" title="0">{
                if err := os.MkdirAll(filepath.Dir(flags.GetStrFlag(flags.PayloadPathFlag)), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov3" title="7">gracefulShutdown()
        return scan(changedDefaultQueryPath, changedDefaultLibrariesPath)</span>
}

func preRun(cmd *cobra.Command) error <span class="cov4" title="8">{
        err := initializeConfig(cmd)
        if err != nil </span><span class="cov1" title="1">{
                return errors.New(initError + err.Error())
        }</span>

        <span class="cov3" title="7">err = flags.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="7">err = validateQuerySelectionFlags()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="7">err = internalPrinter.SetupPrinter(cmd.InheritedFlags())
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(initError + err.Error())
        }</span>
        <span class="cov3" title="7">err = metrics.InitializeMetrics(flags.GetStrFlag(flags.ProfilingFlag), flags.GetStrFlag(flags.CIFlag))
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(initError + err.Error())
        }</span>
        <span class="cov3" title="7">return nil</span>
}

func formatNewError(flag1, flag2 string) error <span class="cov0" title="0">{
        return errors.Errorf("can't provide '%s' and '%s' flags simultaneously",
                flag1,
                flag2)
}</span>

func updateReportFormats() <span class="cov1" title="1">{
        for _, format := range flags.GetMultiStrFlag(flags.ReportFormatsFlag) </span><span class="cov1" title="1">{
                if format == "all" </span><span class="cov0" title="0">{
                        flags.SetMultiStrFlag(flags.ReportFormatsFlag, consoleHelpers.ListReportFormats())
                        break</span>
                }
        }
}

func validateQuerySelectionFlags() error <span class="cov3" title="7">{
        if len(flags.GetMultiStrFlag(flags.IncludeQueriesFlag)) &gt; 0 &amp;&amp; len(flags.GetMultiStrFlag(flags.ExcludeQueriesFlag)) &gt; 0 </span><span class="cov0" title="0">{
                return formatNewError(flags.IncludeQueriesFlag, flags.ExcludeQueriesFlag)
        }</span>
        <span class="cov3" title="7">if len(flags.GetMultiStrFlag(flags.IncludeQueriesFlag)) &gt; 0 &amp;&amp; len(flags.GetMultiStrFlag(flags.ExcludeCategoriesFlag)) &gt; 0 </span><span class="cov0" title="0">{
                return formatNewError(flags.IncludeQueriesFlag, flags.ExcludeCategoriesFlag)
        }</span>
        <span class="cov3" title="7">return nil</span>
}

func initializeConfig(cmd *cobra.Command) error <span class="cov4" title="8">{
        log.Debug().Msg("console.initializeConfig()")

        v := viper.New()
        v.SetEnvPrefix("KICS")
        v.AutomaticEnv()
        errBind := bindFlags(cmd, v)
        if errBind != nil </span><span class="cov0" title="0">{
                return errBind
        }</span>

        <span class="cov4" title="8">exit, err := setupCfgFile()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="8">if exit </span><span class="cov3" title="6">{
                return nil
        }</span>

        <span class="cov2" title="2">base := filepath.Base(flags.GetStrFlag(flags.ConfigFlag))
        v.SetConfigName(base)
        v.AddConfigPath(filepath.Dir(flags.GetStrFlag(flags.ConfigFlag)))
        ext, err := consoleHelpers.FileAnalyzer(flags.GetStrFlag(flags.ConfigFlag))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">v.SetConfigType(ext)
        if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="2">errBind = bindFlags(cmd, v)
        if errBind != nil </span><span class="cov1" title="1">{
                return errBind
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func setupCfgFile() (bool, error) <span class="cov4" title="8">{
        if flags.GetStrFlag(flags.ConfigFlag) == "" </span><span class="cov3" title="6">{
                path := flags.GetMultiStrFlag(flags.PathFlag)
                if len(path) == 0 </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
                <span class="cov3" title="6">if len(path) &gt; 1 </span><span class="cov1" title="1">{
                        warnings = append(warnings, "Any kics.config file will be ignored, please use --config if kics.config is wanted")
                        return true, nil
                }</span>
                <span class="cov3" title="5">configPath := path[0]
                info, err := os.Stat(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
                <span class="cov3" title="5">if !info.IsDir() </span><span class="cov3" title="4">{
                        configPath = filepath.Dir(configPath)
                }</span>
                <span class="cov3" title="5">_, err = os.Stat(filepath.ToSlash(filepath.Join(configPath, constants.DefaultConfigFilename)))
                if err != nil </span><span class="cov3" title="5">{
                        if os.IsNotExist(err) </span><span class="cov3" title="5">{
                                return true, nil
                        }</span>
                        <span class="cov0" title="0">return true, err</span>
                }
                <span class="cov0" title="0">flags.SetStrFlag(flags.ConfigFlag, filepath.ToSlash(filepath.Join(configPath, constants.DefaultConfigFilename)))</span>
        }
        <span class="cov2" title="2">return false, nil</span>
}

func bindFlags(cmd *cobra.Command, v *viper.Viper) error <span class="cov4" title="10">{
        log.Debug().Msg("console.bindFlags()")
        settingsMap := v.AllSettings()
        cmd.Flags().VisitAll(func(f *pflag.Flag) </span><span class="cov10" title="380">{
                settingsMap[f.Name] = true
                if strings.Contains(f.Name, "-") </span><span class="cov9" title="290">{
                        envVarSuffix := strings.ToUpper(strings.ReplaceAll(f.Name, "-", "_"))
                        variableName := fmt.Sprintf("%s_%s", "KICS", envVarSuffix)
                        if err := v.BindEnv(f.Name, variableName); err != nil </span><span class="cov0" title="0">{
                                log.Err(err).Msg("Failed to bind Viper flags")
                        }</span>
                }
                <span class="cov10" title="380">if !f.Changed &amp;&amp; v.IsSet(f.Name) </span><span class="cov3" title="6">{
                        val := v.Get(f.Name)
                        setBoundFlags(f.Name, val, cmd)
                }</span>
        })
        <span class="cov4" title="10">for key, val := range settingsMap </span><span class="cov9" title="357">{
                if val == true </span><span class="cov9" title="356">{
                        continue</span>
                } else<span class="cov1" title="1"> {
                        return fmt.Errorf("unknown configuration key: '%s'\nShowing help for '%s' command", key, cmd.Name())
                }</span>
        }
        <span class="cov4" title="9">return nil</span>
}

func setBoundFlags(flagName string, val interface{}, cmd *cobra.Command) <span class="cov3" title="6">{
        switch t := val.(type) </span>{
        case []interface{}:<span class="cov2" title="2">
                var paramSlice []string
                for _, param := range t </span><span class="cov3" title="4">{
                        paramSlice = append(paramSlice, param.(string))
                }</span>
                <span class="cov2" title="2">valStr := strings.Join(paramSlice, ",")
                if err := cmd.Flags().Set(flagName, fmt.Sprintf("%v", valStr)); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Failed to get Viper flags")
                }</span>
        default:<span class="cov3" title="4">
                if err := cmd.Flags().Set(flagName, fmt.Sprintf("%v", val)); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).Msg("Failed to get Viper flags")
                }</span>
        }
}

func initScanCmd(scanCmd *cobra.Command) error <span class="cov4" title="12">{
        if err := flags.InitJSONFlags(scanCmd, scanFlagsListContent, false); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="12">if err := scanCmd.MarkFlagRequired(flags.PathFlag); err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Err(err).Msg("Failed to add command required flags")
        }</span>
        <span class="cov4" title="12">return nil</span>
}

func getFileSystemSourceProvider(paths []string) (*provider.FileSystemSourceProvider, error) <span class="cov3" title="7">{
        var excludePaths []string
        if flags.GetStrFlag(flags.PayloadPathFlag) != "" </span><span class="cov1" title="1">{
                excludePaths = append(excludePaths, flags.GetStrFlag(flags.PayloadPathFlag))
        }</span>

        <span class="cov3" title="7">if len(flags.GetMultiStrFlag(flags.ExcludePathsFlag)) &gt; 0 </span><span class="cov1" title="1">{
                excludePaths = append(excludePaths, flags.GetMultiStrFlag(flags.ExcludePathsFlag)...)
        }</span>

        <span class="cov3" title="7">filesSource, err := provider.NewFileSystemSourceProvider(paths, excludePaths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="7">return filesSource, nil</span>
}

func getExcludeResultsMap(excludeResults []string) map[string]bool <span class="cov3" title="7">{
        excludeResultsMap := make(map[string]bool)
        for _, er := range excludeResults </span><span class="cov1" title="1">{
                excludeResultsMap[er] = true
        }</span>
        <span class="cov3" title="7">return excludeResultsMap</span>
}

// analyzePaths will analyze the paths to scan to determine which type of queries to load
// and which files should be ignored, it then updates the types and exclude flags variables
// with the results found
func analyzePaths(paths, types, exclude []string) (typesRes, excludeRes []string, errRes error) <span class="cov3" title="7">{
        var err error
        exc := make([]string, 0)
        if types[0] == "" </span><span class="cov3" title="6">{ // if '--type' flag was given skip file analyzing
                types, exc, err = analyzer.Analyze(paths)
                if err != nil </span><span class="cov0" title="0">{
                        log.Err(err)
                        return []string{}, []string{}, err
                }</span>
                <span class="cov3" title="6">log.Info().Msgf("Loading queries of type: %s", strings.Join(types, ", "))</span>
        }
        <span class="cov3" title="7">exclude = append(exclude, exc...)
        return types, exclude, nil</span>
}

func createService(
        inspector *engine.Inspector,
        secretsInspector *secrets.Inspector,
        paths []string,
        t kics.Tracker,
        store kics.Storage,
        querySource *source.FilesystemSource) ([]*kics.Service, error) <span class="cov3" title="7">{
        filesSource, err := getFileSystemSourceProvider(paths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="7">combinedParser, err := parser.NewBuilder().
                Add(&amp;jsonParser.Parser{}).
                Add(&amp;yamlParser.Parser{}).
                Add(terraformParser.NewDefault()).
                Add(&amp;dockerParser.Parser{}).
                Build(querySource.Types, querySource.CloudProviders)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // combinedResolver to be used to resolve files and templates
        <span class="cov3" title="7">combinedResolver, err := resolver.NewBuilder().
                Add(&amp;helm.Resolver{}).
                Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="7">services := make([]*kics.Service, 0, len(combinedParser))

        for _, parser := range combinedParser </span><span class="cov4" title="9">{
                services = append(
                        services,
                        &amp;kics.Service{
                                SourceProvider:   filesSource,
                                Storage:          store,
                                Parser:           parser,
                                Inspector:        inspector,
                                SecretsInspector: secretsInspector,
                                Tracker:          t,
                                Resolver:         combinedResolver,
                        },
                )
        }</span>
        <span class="cov3" title="7">return services, nil</span>
}

type startServiceParameters struct {
        t              *tracker.CITracker
        store          kics.Storage
        extractedPaths []string
        progressBar    progress.PBar
        pbBuilder      *progress.PbBuilder
        excludeResults map[string]bool
}

func createQueryFilter() *source.QueryInspectorParameters <span class="cov3" title="7">{
        excludeQueries := source.ExcludeQueries{
                ByIDs:        flags.GetMultiStrFlag(flags.ExcludeQueriesFlag),
                ByCategories: flags.GetMultiStrFlag(flags.ExcludeCategoriesFlag),
                BySeverities: flags.GetMultiStrFlag(flags.ExcludeSeveritiesFlag),
        }

        includeQueries := source.IncludeQueries{
                ByIDs: flags.GetMultiStrFlag(flags.IncludeQueriesFlag),
        }

        queryFilter := source.QueryInspectorParameters{
                IncludeQueries: includeQueries,
                ExcludeQueries: excludeQueries,
                InputDataPath:  flags.GetStrFlag(flags.InputDataFlag),
        }

        return &amp;queryFilter
}</span>

func getSecretsRegexRules(regexRulesPath string) (regexRulesContent string, err error) <span class="cov3" title="7">{
        if len(regexRulesPath) &gt; 0 </span><span class="cov0" title="0">{
                b, err := os.ReadFile(regexRulesPath)
                if err != nil </span><span class="cov0" title="0">{
                        return regexRulesContent, err
                }</span>
                <span class="cov0" title="0">regexRulesContent = string(b)</span>
        } else<span class="cov3" title="7"> {
                regexRulesContent = assets.SecretsQueryRegexRulesJSON
        }</span>

        <span class="cov3" title="7">return regexRulesContent, nil</span>
}

func createServiceAndStartScan(params *startServiceParameters) (failedQueries map[string]error, err error) <span class="cov3" title="7">{
        querySource := source.NewFilesystemSource(
                flags.GetStrFlag(flags.QueriesPath),
                flags.GetMultiStrFlag(flags.TypeFlag),
                flags.GetMultiStrFlag(flags.CloudProviderFlag),
                flags.GetStrFlag(flags.LibrariesPath))

        queryFilter := createQueryFilter()
        inspector, err := engine.NewInspector(ctx,
                querySource,
                engine.DefaultVulnerabilityBuilder,
                params.t,
                queryFilter,
                params.excludeResults,
                flags.GetIntFlag(flags.QueryExecTimeoutFlag),
        )
        if err != nil </span><span class="cov0" title="0">{
                return failedQueries, err
        }</span>

        <span class="cov3" title="7">secretsRegexRulesContent, err := getSecretsRegexRules(flags.GetStrFlag(flags.SecretsRegexesPathFlag))
        if err != nil </span><span class="cov0" title="0">{
                return failedQueries, err
        }</span>

        <span class="cov3" title="7">secretsInspector, err := secrets.NewInspector(
                ctx,
                params.excludeResults,
                params.t,
                queryFilter,
                flags.GetBoolFlag(flags.DisableSecretsFlag),
                flags.GetIntFlag(flags.QueryExecTimeoutFlag),
                secretsRegexRulesContent,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return failedQueries, err
        }</span>

        <span class="cov3" title="7">services, err := createService(
                inspector,
                secretsInspector,
                params.extractedPaths,
                params.t,
                params.store,
                querySource,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return failedQueries, err
        }</span>
        <span class="cov3" title="7">params.progressBar.Close()

        if err = scanner.PrepareAndScan(ctx, scanID, *params.pbBuilder, services); err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return failedQueries, err
        }</span>
        <span class="cov3" title="7">failedQueries = inspector.GetFailedQueries()
        return failedQueries, nil</span>
}

func resolvePath(flagName string) (string, error) <span class="cov3" title="7">{
        extractedPath, errExtractPath := provider.GetSources([]string{flags.GetStrFlag(flagName)})
        if errExtractPath != nil </span><span class="cov0" title="0">{
                return "", errExtractPath
        }</span>
        <span class="cov3" title="7">if len(extractedPath.Path) != 1 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not find a valid path (--%s) on %s", flagName, flags.GetStrFlag(flagName))
        }</span>
        <span class="cov3" title="7">log.Debug().Msgf("Trying to load path (--%s) from %s", flagName, flags.GetStrFlag(flagName))
        return extractedPath.Path[0], nil</span>
}

func getQueryPath(changedDefaultQueryPath bool) error <span class="cov3" title="7">{
        if changedDefaultQueryPath </span><span class="cov3" title="7">{
                extractedQueriesPath, errExtractQueries := resolvePath(flags.QueriesPath)
                if errExtractQueries != nil </span><span class="cov0" title="0">{
                        return errExtractQueries
                }</span>
                <span class="cov3" title="7">flags.SetStrFlag(flags.QueriesPath, extractedQueriesPath)</span>
        } else<span class="cov0" title="0"> {
                log.Debug().Msgf("Looking for queries in executable path and in current work directory")
                defaultQueryPath, errDefaultQueryPath := consoleHelpers.GetDefaultQueryPath(flags.GetStrFlag(flags.QueriesPath))
                if errDefaultQueryPath != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(errDefaultQueryPath, "unable to find queries")
                }</span>
                <span class="cov0" title="0">flags.SetStrFlag(flags.QueriesPath, defaultQueryPath)</span>
        }
        <span class="cov3" title="7">return nil</span>
}

func getLibraryPath(changedDefaultLibrariesPath bool) error <span class="cov3" title="7">{
        if changedDefaultLibrariesPath </span><span class="cov0" title="0">{
                extractedLibrariesPath, errExtractLibraries := resolvePath(flags.LibrariesPath)
                if errExtractLibraries != nil </span><span class="cov0" title="0">{
                        return errExtractLibraries
                }</span>
                <span class="cov0" title="0">flags.SetStrFlag(flags.LibrariesPath, extractedLibrariesPath)</span>
        }
        <span class="cov3" title="7">return nil</span>
}

func preparePaths(changedDefaultQueryPath, changedDefaultLibrariesPath bool) error <span class="cov3" title="7">{
        var err error
        err = getQueryPath(changedDefaultQueryPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="7">err = getLibraryPath(changedDefaultLibrariesPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="7">return nil</span>
}

func prepareAndAnalyzePaths(changedDefaultQueryPath, changedDefaultLibrariesPath bool) (extractedPaths provider.ExtractedPath, err error) <span class="cov3" title="7">{
        err = preparePaths(changedDefaultQueryPath, changedDefaultLibrariesPath)
        if err != nil </span><span class="cov0" title="0">{
                return extractedPaths, err
        }</span>

        <span class="cov3" title="7">extractedPaths, err = provider.GetSources(flags.GetMultiStrFlag(flags.PathFlag))
        if err != nil </span><span class="cov0" title="0">{
                return extractedPaths, err
        }</span>

        <span class="cov3" title="7">newTypeFlagValue, newExcludePathsFlagValue, errAnalyze :=
                analyzePaths(
                        extractedPaths.Path,
                        flags.GetMultiStrFlag(flags.TypeFlag),
                        flags.GetMultiStrFlag(flags.ExcludePathsFlag),
                )
        if errAnalyze != nil </span><span class="cov0" title="0">{
                return extractedPaths, errAnalyze
        }</span>
        <span class="cov3" title="7">flags.SetMultiStrFlag(flags.TypeFlag, newTypeFlagValue)
        flags.SetMultiStrFlag(flags.ExcludePathsFlag, newExcludePathsFlagValue)
        return extractedPaths, nil</span>
}

func scan(changedDefaultQueryPath, changedDefaultLibrariesPath bool) error <span class="cov3" title="7">{
        log.Debug().Msg("console.scan()")
        for _, warn := range warnings </span><span class="cov6" title="30">{
                log.Warn().Msgf(warn)
        }</span>

        <span class="cov3" title="7">printer := consoleHelpers.NewPrinter(flags.GetBoolFlag(flags.MinimalUIFlag))
        printer.Success.Printf("\n%s\n", banner)

        versionMsg := fmt.Sprintf("\nScanning with %s\n\n", constants.GetVersion())
        fmt.Println(versionMsg)
        log.Info().Msgf(strings.ReplaceAll(versionMsg, "\n", ""))

        noProgress := flags.GetBoolFlag(flags.NoProgressFlag)
        if !term.IsTerminal(int(os.Stdin.Fd())) </span><span class="cov3" title="7">{
                noProgress = true
        }</span>

        <span class="cov3" title="7">proBarBuilder := progress.InitializePbBuilder(
                noProgress,
                flags.GetBoolFlag(flags.CIFlag),
                flags.GetBoolFlag(flags.SilentFlag))

        scanStartTime := time.Now()
        progressBar := proBarBuilder.BuildCircle("Preparing Scan Assets: ")
        progressBar.Start()

        t, err := tracker.NewTracker(flags.GetIntFlag(flags.PreviewLinesFlag))
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov3" title="7">store := storage.NewMemoryStorage()
        extractedPaths, err := prepareAndAnalyzePaths(changedDefaultQueryPath, changedDefaultLibrariesPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov3" title="7">excludeResultsMap := getExcludeResultsMap(flags.GetMultiStrFlag(flags.ExcludeResultsFlag))
        failedQueries, err := createServiceAndStartScan(&amp;startServiceParameters{
                t:              t,
                store:          store,
                progressBar:    progressBar,
                extractedPaths: extractedPaths.Path,
                pbBuilder:      proBarBuilder,
                excludeResults: excludeResultsMap,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="7">results, err := store.GetVulnerabilities(ctx, scanID)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov3" title="7">files, err := store.GetFiles(ctx, scanID)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov3" title="7">summary := getSummary(t, results, scanStartTime, time.Now(), model.PathParameters{
                ScannedPaths:      flags.GetMultiStrFlag(flags.PathFlag),
                PathExtractionMap: extractedPaths.ExtractionMap,
        })

        if err := resolveOutputs(
                &amp;summary,
                files.Combine(flags.GetBoolFlag(flags.LineInfoPayloadFlag)),
                failedQueries,
                printer,
                *proBarBuilder); err != nil </span><span class="cov0" title="0">{
                log.Err(err)
                return err
        }</span>

        <span class="cov3" title="7">printScanDuration(time.Since(scanStartTime))

        exitCode := consoleHelpers.ResultsExitCode(&amp;summary)
        if consoleHelpers.ShowError("results") &amp;&amp; exitCode != 0 </span><span class="cov0" title="0">{
                os.Exit(exitCode)
        }</span>
        <span class="cov3" title="7">return nil</span>
}

func printScanDuration(elapsed time.Duration) <span class="cov3" title="7">{
        if flags.GetBoolFlag(flags.CIFlag) </span><span class="cov0" title="0">{
                elapsedStrFormat := "Scan duration: %vms\n"
                fmt.Printf(elapsedStrFormat, elapsed.Milliseconds())
                log.Info().Msgf(elapsedStrFormat, elapsed.Milliseconds())
        }</span> else<span class="cov3" title="7"> {
                elapsedStrFormat := "Scan duration: %v\n"
                fmt.Printf(elapsedStrFormat, elapsed)
                log.Info().Msgf(elapsedStrFormat, elapsed)
        }</span>
}

func getSummary(t *tracker.CITracker, results []model.Vulnerability, start, end time.Time,
        pathParameters model.PathParameters) model.Summary <span class="cov3" title="7">{
        counters := model.Counters{
                ScannedFiles:           t.FoundFiles,
                ParsedFiles:            t.ParsedFiles,
                TotalQueries:           t.LoadedQueries,
                FailedToExecuteQueries: t.ExecutingQueries - t.ExecutedQueries,
                FailedSimilarityID:     t.FailedSimilarityID,
        }

        summary := model.CreateSummary(counters, results, scanID, pathParameters.PathExtractionMap)
        summary.Times = model.Times{
                Start: start,
                End:   end,
        }

        if flags.GetBoolFlag(flags.DisableCISDescFlag) || flags.GetBoolFlag(flags.DisableFullDescFlag) </span><span class="cov0" title="0">{
                log.Warn().Msg("Skipping CIS descriptions because provided disable flag is set")
        }</span> else<span class="cov3" title="7"> {
                err := descriptions.RequestAndOverrideDescriptions(&amp;summary)
                if err != nil </span><span class="cov3" title="7">{
                        log.Warn().Msgf("Unable to get descriptions: %s", err)
                        log.Warn().Msgf("Using default descriptions")
                }</span>
        }

        <span class="cov3" title="7">return summary</span>
}

func resolveOutputs(
        summary *model.Summary,
        documents model.Documents,
        failedQueries map[string]error,
        printer *consoleHelpers.Printer,
        proBarBuilder progress.PbBuilder,
) error <span class="cov3" title="7">{
        log.Debug().Msg("console.resolveOutputs()")

        if err := consoleHelpers.PrintResult(summary, failedQueries, printer); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="7">if flags.GetStrFlag(flags.PayloadPathFlag) != "" </span><span class="cov1" title="1">{
                if err := report.ExportJSONReport(
                        filepath.Dir(flags.GetStrFlag(flags.PayloadPathFlag)),
                        filepath.Base(flags.GetStrFlag(flags.PayloadPathFlag)),
                        documents,
                ); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov3" title="7">return printOutput(
                flags.GetStrFlag(flags.OutputPathFlag),
                flags.GetStrFlag(flags.OutputNameFlag),
                summary, flags.GetMultiStrFlag(flags.ReportFormatsFlag),
                proBarBuilder,
        )</span>
}

func printOutput(outputPath, filename string, body interface{}, formats []string, proBarBuilder progress.PbBuilder) error <span class="cov3" title="7">{
        log.Debug().Msg("console.printOutput()")
        if outputPath == "" </span><span class="cov3" title="6">{
                return nil
        }</span>
        <span class="cov1" title="1">if len(formats) == 0 </span><span class="cov0" title="0">{
                formats = []string{"json"}
        }</span>

        <span class="cov1" title="1">log.Debug().Msgf("Output formats provided [%v]", strings.Join(formats, ","))
        err := consoleHelpers.GenerateReport(outputPath, filename, body, formats, proBarBuilder)

        return err</span>
}

// gracefulShutdown catches signal interrupt and returns the appropriate exit code
func gracefulShutdown() <span class="cov3" title="7">{
        c := make(chan os.Signal)
        // This line should not be lint, since golangci-lint has an issue about it (https://github.com/golang/go/issues/45043)
        signal.Notify(c, os.Interrupt, syscall.SIGTERM) // nolint
        showErrors := consoleHelpers.ShowError("errors")
        interruptCode := constants.SignalInterruptCode
        go func(showErrors bool, interruptCode int) </span><span class="cov3" title="7">{
                &lt;-c
                if showErrors </span><span class="cov0" title="0">{
                        os.Exit(interruptCode)
                }</span>
        }(showErrors, interruptCode)
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package console

import (
        "fmt"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/spf13/cobra"
)

// NewVersionCmd creates a new instance of the version Command
func NewVersionCmd() *cobra.Command <span class="cov10" title="12">{
        return &amp;cobra.Command{
                Use:   "version",
                Short: "Displays the current version",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        fmt.Fprintf(cmd.OutOrStdout(), "%s\n", constants.GetVersion())
                        return nil
                }</span>,
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package constants

import (
        "fmt"
        "math"
)

var (
        // Version - current KICS version
        Version = "development"
        // SCMCommit - Source control management commit identifier
        SCMCommit = "NOCOMMIT"
        // SentryDSN - sentry DSN, unset for disabling
        SentryDSN = ""
        // BaseURL - CIS descriptions endpoint URL
        BaseURL = ""
        // APIScanner - API scanner feature switch
        APIScanner = ""

        // AvailableCategories - All categories and its identifies
        AvailableCategories = map[string]string{
                "Access Control":          "CAT001",
                "Availability":            "CAT002",
                "Backup":                  "CAT003",
                "Best Practices":          "CAT004",
                "Build Process":           "CAT005",
                "Encryption":              "CAT006",
                "Insecure Configurations": "CAT007",
                "Insecure Defaults":       "CAT008",
                "Networking and Firewall": "CAT009",
                "Observability":           "CAT010",
                "Resource Management":     "CAT011",
                "Secret Management":       "CAT012",
                "Supply-Chain":            "CAT013",
                "Structure and Semantics": "CAT014",
        }

        // AvailablePlatforms - All platforms available
        AvailablePlatforms = map[string]string{
                "Ansible":              "ansible",
                "CloudFormation":       "cloudformation",
                "Dockerfile":           "dockerfile",
                "Kubernetes":           "k8s",
                "Terraform":            "terraform",
                "OpenAPI":              "openapi",
                "AzureResourceManager": "azureresourcemanager",
        }

        // AvailableSeverities - All severities available
        AvailableSeverities = []string{
                "high",
                "medium",
                "low",
                "info",
        }

        // AvailableLogLevels - All log levels available
        AvailableLogLevels = []string{
                "TRACE",
                "DEBUG",
                "INFO",
                "WARN",
                "ERROR",
                "FATAL",
        }

        // AvailableCloudProviders - All cloud providers available
        AvailableCloudProviders = map[string]string{
                "aws":   "",
                "azure": "",
                "gcp":   "",
        }
)

const (
        // Fullname - KICS fullname
        Fullname = "Keeping Infrastructure as Code Secure"

        // URL - KICS url
        URL = "https://www.kics.io/"

        // DefaultLogFile - logfile name
        DefaultLogFile = "info.log"

        // DefaultConfigFilename - default configuration filename
        DefaultConfigFilename = "kics.config"

        // MinimumPreviewLines - default minimum preview lines number
        MinimumPreviewLines = 1

        // MaximumPreviewLines - default maximum preview lines number
        MaximumPreviewLines = 30

        // EngineErrorCode - Exit Status code for error in engine
        EngineErrorCode = 126

        // SignalInterruptCode - Exit Status code for a signal interrupt
        SignalInterruptCode = 130

        // MaxInteger - max possible integer in golang
        MaxInteger = math.MaxInt64

        // SentryRefreshRate - sentry crash report refresh rate
        SentryRefreshRate = 2

        // LogFormatJSON - print log as json
        LogFormatJSON = "json"

        // LogFormatPretty - print log more readable
        LogFormatPretty = "pretty"
)

// GetRelease - returns the current release in the format 'kics@version' to be used by sentry
func GetRelease() string <span class="cov8" title="1">{
        return fmt.Sprintf("kics@%s", Version)
}</span>

// GetVersion - returns the current version in the format 'Keeping Infrastructure as Code Secure &lt;version&gt;'
func GetVersion() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s %s", Fullname, Version)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package metrics

import (
        "bytes"
        "runtime/pprof"
        "time"

        "github.com/rs/zerolog/log"
)

type cpuMetric struct {
        close   func()
        writer  *bytes.Buffer
        idx     int
        typeMap map[string]float64
}

var cpuMap = map[string]float64{
        "ns":  float64(time.Nanosecond),
        "us":  float64(time.Microsecond),
        "ms":  float64(time.Millisecond),
        "s":   float64(time.Second),
        "hrs": float64(time.Hour),
}

func (c *cpuMetric) getDefault() string <span class="cov8" title="1">{
        return "ms"
}</span>

// Start - start gathering metrics for CPU usage
func (c *cpuMetric) start() <span class="cov8" title="1">{
        c.idx = 1
        c.typeMap = cpuMap

        c.writer = bytes.NewBuffer([]byte{})

        if err := pprof.StartCPUProfile(c.writer); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to write cpu profile")
        }</span>
        <span class="cov8" title="1">c.close = func() </span><span class="cov8" title="1">{
                pprof.StopCPUProfile()
        }</span>
}

// Stop - stop gathering metrics for CPU usage
func (c *cpuMetric) stop() <span class="cov8" title="1">{
        c.close()
}</span>

// getWriter returns the profile buffer
func (c *cpuMetric) getWriter() *bytes.Buffer <span class="cov8" title="1">{
        return c.writer
}</span>

// getIndex returns the cpu sample index
func (c *cpuMetric) getIndex() int <span class="cov8" title="1">{
        return c.idx
}</span>

// getMap returns the map used to format total value
func (c *cpuMetric) getMap() map[string]float64 <span class="cov8" title="1">{
        return c.typeMap
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package metrics

import (
        "bytes"
        "runtime"
        "runtime/pprof"

        "github.com/rs/zerolog/log"
)

type memMetric struct {
        close   func()
        writer  *bytes.Buffer
        idx     int
        typeMap map[string]float64
}

var (
        b  = 1
        kb = 10
        mb = 20
        gb = 30
        tb = 40
        pb = 50
)

var memoryMap = map[string]float64{
        "B":  float64(b),
        "kB": float64(b &lt;&lt; kb),
        "MB": float64(b &lt;&lt; mb),
        "GB": float64(b &lt;&lt; gb),
        "TB": float64(b &lt;&lt; tb),
        "PB": float64(b &lt;&lt; pb),
}

// Start - start gathering metrics for Memory usage
func (c *memMetric) start() <span class="cov8" title="1">{
        c.idx = 3
        c.typeMap = memoryMap

        old := runtime.MemProfileRate
        runtime.MemProfileRate = 4096 // set default memory rate

        c.writer = bytes.NewBuffer([]byte{})
        c.close = func() </span><span class="cov8" title="1">{
                if err := pprof.Lookup("heap").WriteTo(c.writer, 0); err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to write mem profile")
                }</span>

                <span class="cov8" title="1">runtime.MemProfileRate = old</span>
        }
}

func (c *memMetric) getDefault() string <span class="cov8" title="1">{
        return "B"
}</span>

// Stop - stop gathering metrics for Memory usage
func (c *memMetric) stop() <span class="cov8" title="1">{
        c.close()
}</span>

// getWriter returns the profile buffer
func (c *memMetric) getWriter() *bytes.Buffer <span class="cov8" title="1">{
        return c.writer
}</span>

// getIndex returns the memory sample index
func (c *memMetric) getIndex() int <span class="cov8" title="1">{
        return c.idx
}</span>

// getMap returns the map used to format total value
func (c *memMetric) getMap() map[string]float64 <span class="cov8" title="1">{
        return c.typeMap
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package metrics

import (
        "bytes"
        "fmt"
        "math"
        "strconv"
        "strings"

        "github.com/google/pprof/profile"
        "github.com/rs/zerolog/log"
)

var (
        // Metric is the global metrics object
        Metric = &amp;Metrics{
                Disable: true,
        }
)

// Start - starts gathering metrics based on the type of metrics and writes metrics to string
// Stop - stops gathering metrics for the type of metrics specified
type metricType interface {
        start()
        stop()
        getWriter() *bytes.Buffer
        getIndex() int
        getMap() map[string]float64
        getDefault() string
}

// Metrics - structure to keep information relevant to the metrics calculation
// Disable - disables metric calculations
type Metrics struct {
        metric    metricType
        metricsID string
        location  string
        Disable   bool
        total     int64
        ci        bool
}

// InitializeMetrics - creates a new instance of a Metrics based on the type of metrics specified
func InitializeMetrics(metric, ci string) error <span class="cov5" title="7">{
        var err error
        switch strings.ToLower(metric) </span>{
        case "cpu":<span class="cov2" title="2">
                Metric.Disable = false
                Metric.metric = &amp;cpuMetric{}
                Metric.total = 0</span>
        case "mem":<span class="cov2" title="2">
                Metric.total = 0
                Metric.metric = &amp;memMetric{}
                Metric.Disable = false</span>
        case "":<span class="cov2" title="2">
                Metric.total = 0
                Metric.Disable = true</span>
        default:<span class="cov1" title="1">
                Metric.total = 0
                Metric.Disable = true
                err = fmt.Errorf("unknonwn metric: %s (available metrics: CPU, MEM)", metric)</span>
        }

        // Create temporary dir to keep pprof file
        <span class="cov5" title="7">if !Metric.Disable </span><span class="cov4" title="4">{
                Metric.metricsID = metric
                Metric.ci, _ = strconv.ParseBool(ci)
        }</span>

        <span class="cov5" title="7">return err</span>
}

// Start - starts gathering metrics for the location specified
func (m *Metrics) Start(location string) <span class="cov3" title="3">{
        if m.Disable </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov2" title="2">log.Debug().Msgf("Started %s profiling for %s", m.metricsID, location)

        m.location = location
        m.metric.start()</span>
}

// Stop - stops gathering metrics and logs the result
func (m *Metrics) Stop() <span class="cov3" title="3">{
        if m.Disable </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov2" title="2">log.Debug().Msgf("Stopped %s profiling for %s", m.metricsID, m.location)

        m.metric.stop()

        p, err := profile.Parse(m.metric.getWriter())
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to parse profile on %s: %s", m.location, err)
        }</span>

        <span class="cov2" title="2">if err := p.CheckValid(); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("invalid profile on %s: %s", m.location, err)
        }</span>

        <span class="cov2" title="2">total := getTotal(p, m.metric.getIndex())
        log.Info().
                Msgf("Total %s usage for %s: %s", strings.ToUpper(m.metricsID),
                        m.location, m.formatTotal(total, m.metric.getMap(), m.metric.getDefault()))
        m.total = total</span>
}

// getTotal goes through the profile samples summing their values according to
// the type of profile
func getTotal(prof *profile.Profile, idx int) int64 <span class="cov2" title="2">{
        var total, diffTotal int64
        for _, sample := range prof.Sample </span><span class="cov8" title="35">{
                var v int64
                v = sample.Value[idx]
                if v &lt; 0 </span><span class="cov0" title="0">{
                        v = -v
                }</span>
                <span class="cov8" title="35">total += v
                if sample.DiffBaseSample() </span><span class="cov0" title="0">{
                        diffTotal += v
                }</span>
        }
        <span class="cov2" title="2">if diffTotal &gt; 0 </span><span class="cov0" title="0">{
                total = diffTotal
        }</span>

        <span class="cov2" title="2">return total</span>
}

// formatTotal parses total value into a human readble way
func (m *Metrics) formatTotal(b int64, typeMap map[string]float64, defaultMetric string) string <span class="cov6" title="11">{
        value := float64(b)
        var formatter float64
        var mesure string
        if m.ci </span><span class="cov1" title="1">{
                metric := value / typeMap[defaultMetric]
                if math.IsNaN(metric) </span><span class="cov0" title="0">{
                        metric = 0
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf("%.f%s", metric, defaultMetric)</span>
        }
        <span class="cov6" title="10">for k, u := range typeMap </span><span class="cov10" title="55">{
                if u &gt;= formatter &amp;&amp; (value/u) &gt;= 1.0 </span><span class="cov7" title="18">{
                        formatter = u
                        mesure = k
                }</span>
        }

        <span class="cov6" title="10">metric := value / formatter
        if math.IsNaN(metric) </span><span class="cov2" title="2">{
                metric = 0
        }</span>

        <span class="cov6" title="10">return fmt.Sprintf("%.2f%s", metric, mesure)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package storage

import (
        "context"
        "fmt"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

// MemoryStorage is scans' results representation
type MemoryStorage struct {
        vulnerabilities []model.Vulnerability
        allFiles        model.FileMetadatas
}

// SaveFile adds a new file metadata to files collection
func (m *MemoryStorage) SaveFile(_ context.Context, metadata *model.FileMetadata) error <span class="cov8" title="1">{
        m.allFiles = append(m.allFiles, *metadata)
        return nil
}</span>

// GetFiles returns a collection of files saved on MemoryStorage
func (m *MemoryStorage) GetFiles(_ context.Context, _ string) (model.FileMetadatas, error) <span class="cov8" title="1">{
        return m.allFiles, nil
}</span>

// SaveVulnerabilities adds a list of vulnerabilities to vulnerabilities collection
func (m *MemoryStorage) SaveVulnerabilities(_ context.Context, vulnerabilities []model.Vulnerability) error <span class="cov8" title="1">{
        m.vulnerabilities = append(m.vulnerabilities, vulnerabilities...)
        return nil
}</span>

// GetVulnerabilities returns a collection of vulnerabilities saved on MemoryStorage
func (m *MemoryStorage) GetVulnerabilities(_ context.Context, _ string) ([]model.Vulnerability, error) <span class="cov8" title="1">{
        return m.getUniqueVulnerabilities(), nil
}</span>

func (m *MemoryStorage) getUniqueVulnerabilities() []model.Vulnerability <span class="cov8" title="1">{
        vulnDictionary := make(map[string]model.Vulnerability)
        for i := range m.vulnerabilities </span><span class="cov8" title="1">{
                key := fmt.Sprintf("%s:%s:%d:%s:%s:%s",
                        m.vulnerabilities[i].QueryID,
                        m.vulnerabilities[i].FileName,
                        m.vulnerabilities[i].Line,
                        m.vulnerabilities[i].SimilarityID,
                        m.vulnerabilities[i].SearchKey,
                        m.vulnerabilities[i].KeyActualValue,
                )
                vulnDictionary[key] = m.vulnerabilities[i]
        }</span>

        <span class="cov8" title="1">var uniqueVulnerabilities []model.Vulnerability
        for key := range vulnDictionary </span><span class="cov8" title="1">{
                uniqueVulnerabilities = append(uniqueVulnerabilities, vulnDictionary[key])
        }</span>
        <span class="cov8" title="1">if len(uniqueVulnerabilities) == 0 </span><span class="cov0" title="0">{
                return m.vulnerabilities
        }</span>
        <span class="cov8" title="1">return uniqueVulnerabilities</span>
}

// GetScanSummary is not supported by MemoryStorage
func (m *MemoryStorage) GetScanSummary(_ context.Context, _ []string) ([]model.SeveritySummary, error) <span class="cov8" title="1">{
        return nil, nil
}</span>

// NewMemoryStorage creates a new MemoryStorage empty and returns it
func NewMemoryStorage() *MemoryStorage <span class="cov8" title="1">{
        log.Debug().Msg("storage.NewMemoryStorage()")
        return &amp;MemoryStorage{
                allFiles:        make(model.FileMetadatas, 0),
                vulnerabilities: make([]model.Vulnerability, 0),
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package tracker

import (
        "fmt"

        "github.com/Checkmarx/kics/internal/constants"
)

// CITracker contains information of how many queries were loaded and executed
// and how many files were found and executed
type CITracker struct {
        ExecutingQueries   int
        ExecutedQueries    int
        FoundFiles         int
        FailedSimilarityID int
        LoadedQueries      int
        ParsedFiles        int
        ScanSecrets        int
        ScanPaths          int
        lines              int
}

// NewTracker will create a new instance of a tracker with the number of lines to display in results output
// number of lines can not be smaller than 1
func NewTracker(previewLines int) (*CITracker, error) <span class="cov10" title="2">{
        if previewLines &lt; constants.MinimumPreviewLines || previewLines &gt; constants.MaximumPreviewLines </span><span class="cov1" title="1">{
                return &amp;CITracker{},
                        fmt.Errorf("output lines minimum is %v and maximum is %v", constants.MinimumPreviewLines, constants.MaximumPreviewLines)
        }</span>
        <span class="cov1" title="1">return &amp;CITracker{
                lines: previewLines,
        }, nil</span>
}

// GetOutputLines returns the number of lines to display in results output
func (c *CITracker) GetOutputLines() int <span class="cov1" title="1">{
        return c.lines
}</span>

// TrackQueryLoad adds a loaded query
func (c *CITracker) TrackQueryLoad(queryAggregation int) <span class="cov1" title="1">{
        c.LoadedQueries += queryAggregation
}</span>

// TrackQueryExecuting adds a executing queries
func (c *CITracker) TrackQueryExecuting(queryAggregation int) <span class="cov1" title="1">{
        c.ExecutingQueries += queryAggregation
}</span>

// TrackQueryExecution adds a query executed
func (c *CITracker) TrackQueryExecution(queryAggregation int) <span class="cov1" title="1">{
        c.ExecutedQueries += queryAggregation
}</span>

// TrackFileFound adds a found file to be scanned
func (c *CITracker) TrackFileFound() <span class="cov1" title="1">{
        c.FoundFiles++
}</span>

// TrackFileParse adds a successful parsed file to be scanned
func (c *CITracker) TrackFileParse() <span class="cov1" title="1">{
        c.ParsedFiles++
}</span>

// FailedDetectLine - queries that fail to detect line are counted as failed to execute queries
func (c *CITracker) FailedDetectLine() <span class="cov1" title="1">{
        c.ExecutedQueries--
}</span>

// FailedComputeSimilarityID - queries that failed to compute similarity ID
func (c *CITracker) FailedComputeSimilarityID() <span class="cov1" title="1">{
        c.FailedSimilarityID++
}</span>

func (c *CITracker) TrackScanSecret() <span class="cov0" title="0">{
        c.ScanSecrets++
}</span>

func (c *CITracker) TrackScanPath() <span class="cov0" title="0">{
        c.ScanPaths++
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package analyzer

import (
        "os"
        "path/filepath"
        "regexp"
        "sort"
        "sync"

        "github.com/Checkmarx/kics/internal/metrics"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// openAPIRegex - Regex that finds OpenAPI defining property "openapi"
// openAPIRegexInfo - Regex that finds OpenAPI defining property "info"
// openAPIRegexPath - Regex that finds OpenAPI defining property "paths"
// cloudRegex - Regex that finds Cloud Formation defining property "Resources"
// k8sRegex - Regex that finds Kubernetes defining property "apiVersion"
// k8sRegexKind - Regex that finds Kubernetes defining property "kind"
// k8sRegexMetadata - Regex that finds Kubernetes defining property "metadata"
// k8sRegexSpec - Regex that finds Kubernetes defining property "spec"
var (
        openAPIRegex           = regexp.MustCompile("(\\s*\"openapi\":)|(\\s*openapi:)|(\\s*\"swagger\":)|(\\s*swagger:)")
        openAPIRegexInfo       = regexp.MustCompile("(\\s*\"info\":)|(\\s*info:)")
        openAPIRegexPath       = regexp.MustCompile("(\\s*\"paths\":)|(\\s*paths:)")
        armRegexContentVersion = regexp.MustCompile("\\s*\"contentVersion\":")
        armRegexResources      = regexp.MustCompile("\\s*\"resources\":")
        cloudRegex             = regexp.MustCompile("(\\s*\"Resources\":)|(\\s*Resources:)")
        k8sRegex               = regexp.MustCompile("(\\s*\"apiVersion\":)|(\\s*apiVersion:)")
        k8sRegexKind           = regexp.MustCompile("(\\s*\"kind\":)|(\\s*kind:)")
        k8sRegexMetadata       = regexp.MustCompile("(\\s*\"metadata\":)|(\\s*metadata:)")
        ansibleVaultRegex      = regexp.MustCompile(`^\s*\$ANSIBLE_VAULT.*`)
)

const (
        yml  = ".yml"
        yaml = ".yaml"
)

// Analyze will go through the slice paths given and determine what type of queries should be loaded
// should be loaded based on the extension of the file and the content
func Analyze(paths []string) (typesRes, excludeRes []string, errRes error) <span class="cov4" title="6">{
        // start metrics for file analyzer
        metrics.Metric.Start("file_type_analyzer")

        var files []string
        var wg sync.WaitGroup
        // results is the channel shared by the workers that contains the types found
        results := make(chan string)

        // get all the files inside the given paths
        for _, path := range paths </span><span class="cov5" title="7">{
                if _, err := os.Stat(path); err != nil </span><span class="cov1" title="1">{
                        return []string{}, []string{}, errors.Wrap(err, "failed to analyze path")
                }</span>
                <span class="cov4" title="6">if err := filepath.Walk(path, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="30">{
                        if !info.IsDir() </span><span class="cov7" title="23">{
                                files = append(files, path)
                        }</span>
                        <span class="cov8" title="30">return nil</span>
                }); err != nil <span class="cov0" title="0">{
                        log.Error().Msgf("failed to analize path %s: %s", path, err)
                }</span>
        }

        // unwanted is the channel shared by the workers that contains the unwanted files that the parser will ignore
        <span class="cov4" title="5">unwanted := make(chan string, len(files))

        for _, file := range files </span><span class="cov7" title="23">{
                wg.Add(1)
                // analyze the files concurrently
                go worker(file, results, unwanted, &amp;wg)
        }</span>

        <span class="cov4" title="5">go func() </span><span class="cov4" title="5">{
                // close channel results when the worker has finished writing into it
                defer func() </span><span class="cov4" title="5">{
                        close(unwanted)
                        close(results)
                }</span>()
                <span class="cov4" title="5">wg.Wait()</span>
        }()

        <span class="cov4" title="5">availableTypes := createSlice(results)
        unwantedPaths := createSlice(unwanted)

        // stop metrics for file analyzer
        metrics.Metric.Stop()
        return availableTypes, unwantedPaths, nil</span>
}

// worker determines the type of the file by ext (dockerfile and terraform)/content and
// writes the answer to the results channel
// if no types were found, the worker will write the path of the file in the unwanted channel
func worker(path string, results, unwanted chan&lt;- string, wg *sync.WaitGroup) <span class="cov7" title="23">{
        defer wg.Done()
        ext := filepath.Ext(path)
        if ext == "" </span><span class="cov2" title="2">{
                ext = filepath.Base(path)
        }</span>
        <span class="cov7" title="23">switch ext </span>{
        // Dockerfile
        case ".dockerfile", "Dockerfile":<span class="cov2" title="2">
                results &lt;- "dockerfile"</span>
        // Terraform
        case ".tf":<span class="cov2" title="2">
                results &lt;- "terraform"</span>
        // Cloud Formation, Ansible, OpenAPI
        case yaml, yml, ".json":<span class="cov6" title="13">
                checkContent(path, results, unwanted, ext)</span>
        }
}

// regexSlice is a struct to contain a slice of regex
type regexSlice struct {
        regex []*regexp.Regexp
}

// types is a map that contains the regex by type
var types = map[string]regexSlice{
        "openapi": {
                regex: []*regexp.Regexp{
                        openAPIRegex,
                        openAPIRegexInfo,
                        openAPIRegexPath,
                },
        },
        "kubernetes": {
                regex: []*regexp.Regexp{
                        k8sRegex,
                        k8sRegexKind,
                        k8sRegexMetadata,
                },
        },
        "cloudformation": {
                regex: []*regexp.Regexp{
                        cloudRegex,
                },
        },
        "azureresourcemanager": {
                []*regexp.Regexp{
                        armRegexContentVersion,
                        armRegexResources,
                },
        },
}

// checkContent will determine the file type by content when worker was unable to
// determine by ext, if no type was determined checkContent adds it to unwanted channel
func checkContent(path string, results, unwanted chan&lt;- string, ext string) <span class="cov6" title="13">{
        // get file content
        content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to analyze file: %s", err)
                return
        }</span>

        <span class="cov6" title="13">returnType := ""

        // Sort map so that CloudFormation (type that as less requireds) goes last
        keys := make([]string, 0, len(types))
        for k := range types </span><span class="cov9" title="52">{
                keys = append(keys, k)
        }</span>

        <span class="cov6" title="13">sort.Sort(sort.Reverse(sort.StringSlice(keys)))

        for _, key := range keys </span><span class="cov9" title="52">{
                check := true
                for _, typeRegex := range types[key].regex </span><span class="cov10" title="67">{
                        if res := typeRegex.Match(content); !res </span><span class="cov9" title="42">{
                                check = false
                                break</span>
                        }
                }
                // If all regexs passed and there wasn't a type already assigned
                <span class="cov9" title="52">if check &amp;&amp; returnType == "" </span><span class="cov5" title="8">{
                        returnType = key
                }</span>
        }

        <span class="cov6" title="13">if returnType != "" </span><span class="cov5" title="8">{
                // write to channel type of file
                results &lt;- returnType
        }</span> else<span class="cov4" title="5"> if ext == yaml || ext == yml </span><span class="cov3" title="4">{
                // check if it is an ansible vault
                if res := ansibleVaultRegex.Match(content); res </span><span class="cov0" title="0">{
                        unwanted &lt;- path
                }</span> else<span class="cov3" title="4"> {
                        // Since Ansible has no defining property
                        // and no other type matched for YAML file extension, assume the file type is Ansible
                        results &lt;- "ansible"
                }</span>
        } else<span class="cov1" title="1"> {
                // No type was determined (ignore on parser)
                unwanted &lt;- path
        }</span>
}

// createSlice creates a slice from the channel given removing any duplicates
func createSlice(chanel chan string) []string <span class="cov5" title="10">{
        slice := make([]string, 0)
        for i := range chanel </span><span class="cov7" title="17">{
                if !contains(slice, i) </span><span class="cov6" title="13">{
                        slice = append(slice, i)
                }</span>
        }
        <span class="cov5" title="10">return slice</span>
}

// contains is a simple method to check if a slice
// contains an entry
func contains(s []string, e string) bool <span class="cov7" title="17">{
        for _, a := range s </span><span class="cov8" title="38">{
                if a == e </span><span class="cov3" title="4">{
                        return true
                }</span>
        }
        <span class="cov6" title="13">return false</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package engine

import (
        "fmt"
        "strings"

        build "github.com/Checkmarx/kics/pkg/builder/model"
        commentParser "github.com/Checkmarx/kics/pkg/builder/parser/comment"
        tagParser "github.com/Checkmarx/kics/pkg/builder/parser/tag"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
        ctyConvert "github.com/zclconf/go-cty/cty/convert"
)

const resourceLabelsCount = 2

// Engine contains the conditions of rules and comments positions
type Engine struct {
        commentParser *commentParser.Parser
        conditions    []build.Condition
}

// Run parses files and execute engine.Run
func Run(src []byte, filename string) ([]build.Rule, error) <span class="cov1" title="1">{
        cp, err := commentParser.NewParser(src, filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">file, diags := hclsyntax.ParseConfig(src, filename, hcl.Pos{Byte: 0, Line: 1, Column: 1})
        if diags != nil &amp;&amp; diags.HasErrors() </span><span class="cov0" title="0">{
                return nil, diags.Errs()[0]
        }</span>
        <span class="cov1" title="1">if file == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid parse result")
        }</span>

        <span class="cov1" title="1">e := &amp;Engine{
                commentParser: cp,
        }

        return e.Run(file.Body.(*hclsyntax.Body))</span>
}

// Run initializes rules for Engine and returns it
func (e *Engine) Run(body *hclsyntax.Body) ([]build.Rule, error) <span class="cov1" title="1">{
        e.conditions = make([]build.Condition, 0)
        if err := e.walkBody(body, []build.PathItem{}); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">rules := make([]build.Rule, 0)
        conditionGroups := make(map[string][]build.Condition)
        for _, condition := range e.conditions </span><span class="cov1" title="1">{
                group, ok := condition.AttrAsString("group")
                if !ok </span><span class="cov1" title="1">{
                        rules = append(rules, build.Rule{
                                Conditions: []build.Condition{condition},
                        })
                        continue</span>
                }

                <span class="cov0" title="0">conditionGroups[group] = append(conditionGroups[group], condition)</span>
        }

        <span class="cov1" title="1">for _, conditionGroup := range conditionGroups </span><span class="cov0" title="0">{
                rules = append(rules, build.Rule{
                        Conditions: conditionGroup,
                })
        }</span>
        <span class="cov1" title="1">return rules, nil</span>
}

func (e *Engine) walkBody(body *hclsyntax.Body, walkHistory []build.PathItem) error <span class="cov5" title="3">{
        for _, attribute := range body.Attributes </span><span class="cov6" title="4">{
                if err := e.walkAttribute(attribute, walkHistory); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="3">for _, block := range body.Blocks </span><span class="cov3" title="2">{
                if err := e.walkBlock(block, walkHistory); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="3">return nil</span>
}

func (e *Engine) walkBlock(block *hclsyntax.Block, walkHistory []build.PathItem) error <span class="cov3" title="2">{
        if len(block.Labels) == resourceLabelsCount </span><span class="cov1" title="1">{
                walkHistory = append(walkHistory,
                        build.PathItem{Type: build.PathTypeResource, Name: block.Type},
                        build.PathItem{Type: build.PathTypeResourceType, Name: block.Labels[0]},
                        build.PathItem{Type: build.PathTypeResourceName, Name: block.Type},
                )
        }</span> else<span class="cov1" title="1"> {
                walkHistory = append(walkHistory, build.PathItem{Type: build.PathTypeDefault, Name: block.Type})
        }</span>

        <span class="cov3" title="2">e.checkComment(block.Range(), walkHistory, nil)

        return e.walkBody(block.Body, walkHistory)</span>
}

func (e *Engine) walkAttribute(attr *hclsyntax.Attribute, walkHistory []build.PathItem) error <span class="cov6" title="4">{
        walkHistory = append(walkHistory, build.PathItem{Type: build.PathTypeDefault, Name: attr.Name})

        switch exp := attr.Expr.(type) </span>{
        case *hclsyntax.TemplateExpr,
                *hclsyntax.TemplateWrapExpr,
                *hclsyntax.LiteralValueExpr,
                *hclsyntax.ScopeTraversalExpr:<span class="cov5" title="3">

                v, err := e.expToString(attr.Expr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov5" title="3">e.checkComment(attr.Range(), walkHistory, &amp;v)</span>
        case *hclsyntax.ObjectConsExpr:<span class="cov1" title="1">
                e.checkComment(attr.Range(), walkHistory, nil)

                for _, item := range exp.Items </span><span class="cov3" title="2">{
                        if err := e.walkConstantItem(item, walkHistory); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        default:<span class="cov0" title="0">
                e.checkComment(attr.Range(), walkHistory, nil)</span>
        }

        <span class="cov6" title="4">return nil</span>
}

func (e *Engine) expToString(expr hclsyntax.Expression) (string, error) <span class="cov10" title="9">{
        switch t := expr.(type) </span>{
        case *hclsyntax.LiteralValueExpr:<span class="cov1" title="1">
                s, err := ctyConvert.Convert(t.Val, cty.String)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov1" title="1">return s.AsString(), nil</span>
        case *hclsyntax.TemplateExpr:<span class="cov6" title="4">
                if t.IsStringLiteral() </span><span class="cov6" title="4">{
                        v, err := t.Value(nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov6" title="4">return v.AsString(), nil</span>
                }
                <span class="cov0" title="0">builder, err := e.buildString(t.Parts)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">return builder.String(), nil</span>
        case *hclsyntax.TemplateWrapExpr:<span class="cov0" title="0">
                return e.expToString(t.Wrapped)</span>
        case *hclsyntax.ObjectConsKeyExpr:<span class="cov3" title="2">
                return e.expToString(t.Wrapped)</span>
        case *hclsyntax.ScopeTraversalExpr:<span class="cov3" title="2">
                var items []string
                for _, part := range t.Traversal </span><span class="cov3" title="2">{
                        switch tt := part.(type) </span>{
                        case hcl.TraverseAttr:<span class="cov0" title="0">
                                items = append(items, tt.Name)</span>
                        case hcl.TraverseRoot:<span class="cov3" title="2">
                                items = append(items, tt.Name)</span>
                        case hcl.TraverseIndex:<span class="cov0" title="0">
                                items = append(items, tt.Key.AsString())</span>
                        }
                }
                <span class="cov3" title="2">return strings.Join(items, "."), nil</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("can't convert expression %T to string", expr)</span>
}

func (e *Engine) buildString(parts []hclsyntax.Expression) (strings.Builder, error) <span class="cov1" title="1">{
        var builder strings.Builder
        for _, part := range parts </span><span class="cov0" title="0">{
                s, err := e.expToString(part)
                if err != nil </span><span class="cov0" title="0">{
                        return strings.Builder{}, err
                }</span>
                <span class="cov0" title="0">builder.WriteString(s)</span>
        }
        <span class="cov1" title="1">return builder, nil</span>
}

func (e *Engine) walkConstantItem(item hclsyntax.ObjectConsItem, walkHistory []build.PathItem) error <span class="cov3" title="2">{
        k, err := e.expToString(item.KeyExpr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">walkHistory = append(walkHistory, build.PathItem{Type: build.PathTypeDefault, Name: k})

        v, err := e.expToString(item.ValueExpr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="2">e.checkComment(item.ValueExpr.Range(), walkHistory, &amp;v)

        return nil</span>
}

func (e *Engine) checkComment(rg hcl.Range, walkHistory []build.PathItem, actualValue *string) <span class="cov9" title="8">{
        leadComment, endLineComment := e.commentParser.ParseCommentsForNode(rg)
        if !leadComment.IsEmpty() </span><span class="cov1" title="1">{
                e.addRule(walkHistory, leadComment, actualValue)
        }</span>
        <span class="cov9" title="8">if !endLineComment.IsEmpty() </span><span class="cov1" title="1">{
                e.addRule(walkHistory, endLineComment, actualValue)
        }</span>
}

func (e *Engine) addRule(walkHistory []build.PathItem, comment commentParser.Comment, actualValue *string) <span class="cov3" title="2">{
        tags, err := tagParser.Parse(comment.Value(), model.AllIssueTypesAsString)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("Line %d: failed to parse comment '%s'", comment.Line(), comment.Value())
                return
        }</span>

        <span class="cov3" title="2">if len(tags) == 0 </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov1" title="1">cp := make([]build.PathItem, len(walkHistory))
        copy(cp, walkHistory)

        for _, t := range tags </span><span class="cov1" title="1">{
                e.conditions = append(e.conditions, build.Condition{
                        Line:       comment.Line(),
                        IssueType:  model.IssueType(t.Name),
                        Path:       cp,
                        Value:      actualValue,
                        Attributes: t.Attributes,
                })
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package model

import "github.com/Checkmarx/kics/pkg/model"

// PathItemType represents which type of path that item belongs on json representation
type PathItemType string

// Constants for kinds of PathItemTypes
const (
        PathTypeDefault      PathItemType = "DEFAULT"
        PathTypeResource     PathItemType = "RESOURCE"
        PathTypeResourceType PathItemType = "RESOURCE_TYPE"
        PathTypeResourceName PathItemType = "RESOURCE_NAME"
)

// PathItem represents json's element name and type
type PathItem struct {
        Name string
        Type PathItemType
}

// Condition represents a condition from a rule that should be checked
type Condition struct {
        Line int

        IssueType  model.IssueType
        Path       []PathItem
        Value      interface{}
        Attributes map[string]interface{}
}

// Rule represents a list of conditions to validate a rule
type Rule struct {
        Conditions []Condition
}

// Attr add some configurations to the condition to return the condition to be matched
func (c Condition) Attr(name string) (interface{}, bool) <span class="cov6" title="2">{
        v, ok := c.Attributes[name]
        if !ok </span><span class="cov1" title="1">{
                return nil, false
        }</span>

        <span class="cov1" title="1">return v, true</span>
}

// AttrAsString gets Attr and converts to string
func (c Condition) AttrAsString(name string) (string, bool) <span class="cov10" title="3">{
        v, ok := c.Attributes[name]
        if !ok </span><span class="cov1" title="1">{
                return "", false
        }</span>

        <span class="cov6" title="2">if vv, ok := v.(string); ok </span><span class="cov1" title="1">{
                return vv, true
        }</span>

        <span class="cov1" title="1">return "", false</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package tag

import (
        "bytes"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "text/scanner"
)

const (
        base      = 10
        bitSize64 = 64
)

// Tag contains the tag name reference and its atributtes
type Tag struct {
        Name       string
        Attributes map[string]interface{}
}

// Parse tag from following structure
// name1:"expected=private,test=false" name2:"attr=1"
func Parse(s string, supportedNames []string) ([]Tag, error) <span class="cov7" title="15">{
        s = strings.TrimLeft(strings.TrimLeft(strings.TrimSpace(s), "/"), " ")
        var tags []Tag
        for _, si := range strings.Split(s, " ") </span><span class="cov7" title="18">{
                cleanSi := strings.TrimSpace(si)
                if cleanSi == "" </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov7" title="17">for _, supportedName := range supportedNames </span><span class="cov8" title="22">{
                        if !strings.HasPrefix(cleanSi, supportedName) </span><span class="cov5" title="6">{
                                continue</span>
                        }

                        <span class="cov7" title="16">tag, err := parseTag(cleanSi, supportedName)
                        if err != nil </span><span class="cov5" title="6">{
                                return nil, err
                        }</span>

                        <span class="cov6" title="10">tags = append(tags, tag)</span>
                }
        }

        <span class="cov6" title="9">return tags, nil</span>
}

func parseTag(s, name string) (Tag, error) <span class="cov7" title="16">{
        t := Tag{
                Name:       name,
                Attributes: make(map[string]interface{}),
        }

        attributePart := strings.TrimPrefix(s, name)
        attributePart = strings.TrimPrefix(attributePart, ":")
        attributePart = strings.TrimPrefix(attributePart, "\"")
        attributePart = strings.TrimSuffix(attributePart, "\"")

        if attributePart == "" </span><span class="cov4" title="4">{
                return t, nil
        }</span>

        <span class="cov6" title="12">sc := &amp;scanner.Scanner{}
        sc.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanFloats | scanner.ScanStrings
        sc.Init(strings.NewReader(attributePart))

        for </span><span class="cov10" title="43">{
                tok := sc.Scan()
                switch tok </span>{
                case scanner.EOF:<span class="cov5" title="6">
                        return t, nil</span>
                case scanner.Ident:<span class="cov8" title="26">
                        ident := sc.TokenText()
                        switch sc.Peek() </span>{
                        case '=':<span class="cov8" title="19">
                                sc.Next()
                                value, err := parseValue(sc)
                                if err != nil </span><span class="cov4" title="4">{
                                        return Tag{}, err
                                }</span>
                                <span class="cov7" title="15">t.Attributes[ident] = value</span>
                        case '[':<span class="cov2" title="2">
                                sc.Next()
                                arg, err := parseArgs(sc)
                                if err != nil </span><span class="cov1" title="1">{
                                        return Tag{}, err
                                }</span>
                                <span class="cov1" title="1">t.Attributes[ident] = arg</span>
                        case ',':<span class="cov4" title="5">
                                sc.Next()
                                t.Attributes[ident] = nil</span>
                        case scanner.EOF:<span class="cov0" title="0">
                                t.Attributes[ident] = nil</span>
                        }
                case ',':<span class="cov6" title="10"></span>
                        // NOP
                default:<span class="cov1" title="1">
                        return Tag{}, fmt.Errorf("invalid token: %s", sc.TokenText())</span>
                }
        }
}

func parseArray(sc *scanner.Scanner) ([]interface{}, error) <span class="cov4" title="4">{
        var result []interface{}
        for </span><span class="cov7" title="13">{
                value, err := parseValue(sc)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov7" title="13">result = append(result, value)
                next := sc.Next()
                if next == ']' </span><span class="cov3" title="3">{
                        return result, nil
                }</span>
                <span class="cov6" title="10">if next == ',' </span><span class="cov6" title="9">{
                        continue</span>
                }
                <span class="cov1" title="1">return result, fmt.Errorf(", expected but got %s", string(next))</span>
        }
}

func parseValue(sc *scanner.Scanner) (interface{}, error) <span class="cov9" title="34">{
        switch sc.Peek() </span>{
        case '\'':<span class="cov7" title="18">
                sc.Next()
                return parseString(sc)</span>
        case '*':<span class="cov1" title="1">
                r := sc.Next()
                return string(r), nil</span>
        case '&lt;', '&gt;':<span class="cov2" title="2">
                r := sc.Next()
                if sc.Peek() == '=' </span><span class="cov1" title="1">{
                        sc.Next()
                        return string(r) + "=", nil
                }</span>
                <span class="cov1" title="1">return string(r), nil</span>
        case '!':<span class="cov2" title="2">
                sc.Next()
                if sc.Peek() == '=' </span><span class="cov1" title="1">{
                        sc.Next()
                        return "!=", nil
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("invalid value: %s", sc.TokenText())</span>
        case '[':<span class="cov4" title="4">
                sc.Next()
                return parseArray(sc)</span>
        default:<span class="cov5" title="7">
                tok := sc.Scan()
                switch tok </span>{
                case scanner.Ident:<span class="cov4" title="5">
                        return checkType(sc.TokenText()), nil</span>
                case scanner.String, scanner.Int, scanner.Float:<span class="cov2" title="2">
                        if tok == scanner.String </span><span class="cov0" title="0">{
                                str := sc.TokenText()
                                return str[1 : len(str)-1], nil
                        }</span> else<span class="cov2" title="2"> if tok == scanner.Int </span><span class="cov1" title="1">{
                                return strconv.ParseInt(sc.TokenText(), base, bitSize64)
                        }</span> else<span class="cov1" title="1"> if tok == scanner.Float </span><span class="cov1" title="1">{
                                return strconv.ParseFloat(sc.TokenText(), bitSize64)
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("invalid value: %s", sc.TokenText())</span>
                }
        }
        <span class="cov0" title="0">return nil, errors.New("invalid value")</span>
}

func parseArgs(sc *scanner.Scanner) (map[string]interface{}, error) <span class="cov2" title="2">{
        result := map[string]interface{}{}
        for </span><span class="cov3" title="3">{
                tok := sc.Scan()
                if tok != scanner.Ident </span><span class="cov0" title="0">{
                        return result, fmt.Errorf("invalid attribute name: %s", sc.TokenText())
                }</span>
                <span class="cov3" title="3">name := sc.TokenText()
                eq := sc.Next()
                if eq != '=' </span><span class="cov1" title="1">{
                        return result, fmt.Errorf("= expected but got %s", string(eq))
                }</span>
                <span class="cov2" title="2">value, err := parseValue(sc)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov2" title="2">result[name] = value
                next := sc.Next()
                if next == ']' </span><span class="cov1" title="1">{
                        return result, nil
                }</span>
                <span class="cov1" title="1">if next == ',' </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">return result, fmt.Errorf(") or , expected but got %s", string(next))</span>
        }
}

func parseString(sc *scanner.Scanner) (string, error) <span class="cov7" title="18">{
        var buf bytes.Buffer
        ch := sc.Next()
        for ch != '\'' </span><span class="cov8" title="26">{
                if ch == '\n' || ch == '\r' || ch &lt; 0 </span><span class="cov1" title="1">{
                        return "", errors.New("unterminated string")
                }</span>
                <span class="cov8" title="25">if ch == '\\' </span><span class="cov6" title="12">{
                        s, err := parseEscape(sc)
                        if err != nil </span><span class="cov1" title="1">{
                                return "", err
                        }</span>
                        <span class="cov6" title="11">buf.WriteString(s)</span>
                } else<span class="cov7" title="13"> {
                        buf.WriteRune(ch)
                }</span>
                <span class="cov8" title="24">ch = sc.Next()</span>
        }
        <span class="cov7" title="16">return buf.String(), nil</span>
}

func parseEscape(sc *scanner.Scanner) (string, error) <span class="cov6" title="12">{
        ch := sc.Next()
        switch ch </span>{
        case 'a':<span class="cov1" title="1">
                return "\a", nil</span>
        case 'b':<span class="cov1" title="1">
                return "\b", nil</span>
        case 'f':<span class="cov1" title="1">
                return "\f", nil</span>
        case 'n':<span class="cov1" title="1">
                return "\n", nil</span>
        case 'r':<span class="cov1" title="1">
                return "\r", nil</span>
        case 't':<span class="cov1" title="1">
                return "\t", nil</span>
        case 'v':<span class="cov1" title="1">
                return "\v", nil</span>
        case '\\':<span class="cov1" title="1">
                return "\\", nil</span>
        case '"':<span class="cov2" title="2">
                return "\"", nil</span>
        case '\'':<span class="cov1" title="1">
                return "'", nil</span>
        }
        <span class="cov1" title="1">return "", fmt.Errorf("invalid escape sequence: %s", string(ch))</span>
}

func checkType(s string) interface{} <span class="cov4" title="5">{
        switch s </span>{
        case "true", "TRUE":<span class="cov1" title="1">
                return true</span>
        case "false", "FALSE":<span class="cov1" title="1">
                return false</span>
        default:<span class="cov3" title="3">
                if i, err := strconv.ParseInt(s, base, bitSize64); err == nil </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov3" title="3">if f, err := strconv.ParseFloat(s, bitSize64); err == nil </span><span class="cov0" title="0">{
                        return f
                }</span>

                <span class="cov3" title="3">return s</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package writer

import (
        "bytes"
        "fmt"
        "html/template"
        "strconv"
        "strings"

        build "github.com/Checkmarx/kics/pkg/builder/model"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// RegoWriter represents the template for a Rego rule
type RegoWriter struct {
        tmpl *template.Template
}

// Block represents a json block of a file for scan
type Block struct {
        Name string
        All  bool
        List []string
}

// RegoRule contains a block to be scanned and a rule to be applied
type RegoRule struct {
        Block Block
        build.Rule
}

const (
        stringValue = "\"%s\""
        prec        = 6
        bitSize32   = 32
        bitSize64   = 64
)

// NewRegoWriter initializes a default RegoWriter using builder template
func NewRegoWriter() (*RegoWriter, error) <span class="cov1" title="1">{
        tmpl, err := template.New("template.gorego").
                Funcs(template.FuncMap{
                        "condition": condition,
                        "regoValue": regoValueToString,
                        "lastCondition": func(r RegoRule) build.Condition </span><span class="cov1" title="1">{
                                return r.Conditions[len(r.Conditions)-1]
                        }</span>,
                        "unescape": func(v string) template.HTML <span class="cov1" title="1">{
                                return template.HTML(v) // nolint:gosec
                        }</span>,
                        "innerKey": func(r RegoRule) template.HTML <span class="cov2" title="2">{
                                condition := r.Conditions[len(r.Conditions)-1]
                                return template.HTML(conditionKey(r.Block, condition, false, true)) // nolint:gosec
                        }</span>,
                        "searchKey": func(r RegoRule) template.HTML <span class="cov1" title="1">{
                                format := "%%s[%%s].%s"
                                condition := r.Conditions[len(r.Conditions)-1]
                                var vars []string

                                if v, ok := condition.Attr("resource"); ok &amp;&amp; v == "*" </span><span class="cov1" title="1">{
                                        vars = append(vars, "blockType")
                                }</span> else<span class="cov0" title="0"> {
                                        vars = append(vars, "blockTypes[blockIndex]")
                                }</span>
                                <span class="cov1" title="1">vars = append(vars, "name")
                                if _, ok := condition.Attr("any_key"); ok </span><span class="cov1" title="1">{
                                        format += ".%%s"
                                        vars = append(vars, "key")
                                }</span>
                                <span class="cov1" title="1">format = fmt.Sprintf(format, conditionKey(r.Block, condition, false, true))

                                return template.HTML(fmt.Sprintf("sprintf(\"%s\", [%s])", format, strings.Join(vars, ", ")))</span> // nolint:gosec
                        },
                }).
                ParseFiles("./pkg/builder/writer/template.gorego")
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;RegoWriter{tmpl: tmpl}, nil</span>
}

// Render starts RegoWriter rules list passed as parameter
func (w *RegoWriter) Render(rules []build.Rule) ([]byte, error) <span class="cov1" title="1">{
        wr := bytes.NewBuffer(nil)

        if err := w.tmpl.Execute(wr, format(rules)); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to render")
        }</span>

        <span class="cov1" title="1">return wr.Bytes(), nil</span>
}

func condition(r Block, c build.Condition) string <span class="cov5" title="6">{
        key := conditionKey(r, c, true, false)

        if c.IssueType == model.IssueTypeRedundantAttribute </span><span class="cov1" title="1">{
                return key
        }</span>
        <span class="cov4" title="5">if c.IssueType == model.IssueTypeMissingAttribute </span><span class="cov1" title="1">{
                return fmt.Sprintf("not %s", key)
        }</span>

        <span class="cov4" title="4">if _, ok := c.Attr("upper"); ok </span><span class="cov1" title="1">{
                key = fmt.Sprintf("upper(%s)", key)
        }</span>
        <span class="cov4" title="4">if _, ok := c.Attr("lower"); ok </span><span class="cov1" title="1">{
                key = fmt.Sprintf("lower(%s)", key)
        }</span>

        <span class="cov4" title="4">if reg, ok := c.Attr("regex"); ok </span><span class="cov1" title="1">{
                return fmt.Sprintf("re_match(\"%s\", %s)", reg, key)
        }</span>

        <span class="cov3" title="3">condition := "=="
        if v, ok := c.AttrAsString("condition"); ok </span><span class="cov1" title="1">{
                condition = v
        }</span>

        <span class="cov3" title="3">if value, ok := c.AttrAsString("val"); ok </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s %s %s", key, condition, regoValueToString(value))
        }</span>

        <span class="cov2" title="2">return fmt.Sprintf("%s %s %s", key, condition, regoValueToString(c.Value))</span>
}

func regoValueToString(i interface{}) string <span class="cov7" title="15">{
        switch v := i.(type) </span>{
        case bool:<span class="cov2" title="2">
                if v </span><span class="cov1" title="1">{
                        return "true"
                }</span>
                <span class="cov1" title="1">return "false"</span>
        case int64:<span class="cov1" title="1">
                return strconv.Itoa(int(v))</span>
        case int32:<span class="cov1" title="1">
                return strconv.Itoa(int(v))</span>
        case int:<span class="cov1" title="1">
                return strconv.Itoa(v)</span>
        case float64:<span class="cov1" title="1">
                return strconv.FormatFloat(v, 'f', prec, bitSize64)</span>
        case float32:<span class="cov1" title="1">
                return strconv.FormatFloat(float64(v), 'f', prec, bitSize32)</span>
        case string:<span class="cov4" title="4">
                return fmt.Sprintf(stringValue, v)</span>
        case *string:<span class="cov2" title="2">
                if v == nil </span><span class="cov1" title="1">{
                        return "\"\""
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf(stringValue, *v)</span>
        case []string:<span class="cov1" title="1">
                sts := make([]string, 0, len(v))
                for _, vi := range v </span><span class="cov3" title="3">{
                        sts = append(sts, fmt.Sprintf(stringValue, vi))
                }</span>

                <span class="cov1" title="1">return fmt.Sprintf("{%s}", strings.Join(sts, ", "))</span>
        default:<span class="cov1" title="1">
                log.Warn().Msgf("Can't convert value, %T to string", i)
                return ""</span>
        }
}

func conditionKey(block Block, c build.Condition, withBlockPrefix, pathOnly bool) string <span class="cov6" title="10">{
        key := ""
        if withBlockPrefix </span><span class="cov5" title="7">{
                key = "block"
        }</span>
        <span class="cov6" title="10">for i, pathItem := range c.Path </span><span class="cov10" title="50">{
                switch pathItem.Type </span>{
                case build.PathTypeResourceType:<span class="cov6" title="10">
                        if pathOnly </span><span class="cov3" title="3">{
                                continue</span>
                        } else<span class="cov5" title="7"> if block.All </span><span class="cov5" title="7">{
                                key += "[blockType]"
                        }</span> else<span class="cov0" title="0"> {
                                key += "[blockTypes[blockIndex]]"
                        }</span>
                case build.PathTypeResourceName:<span class="cov6" title="10">
                        if !pathOnly </span><span class="cov5" title="7">{
                                key += "[name]"
                        }</span>
                case build.PathTypeDefault:<span class="cov7" title="20">
                        key = buildDefaultType(c, i, pathOnly, pathItem, key)</span>
                }
        }

        <span class="cov6" title="10">return key</span>
}

func buildDefaultType(c build.Condition, i int, pathOnly bool, pathItem build.PathItem, key string) string <span class="cov7" title="20">{
        if _, ok := c.Attr("any_key"); ok &amp;&amp; i == len(c.Path)-1 </span><span class="cov6" title="10">{
                if !pathOnly </span><span class="cov5" title="7">{
                        key += "[key]"
                }</span>
                <span class="cov6" title="10">return key</span>
        }

        <span class="cov6" title="10">if key != "" </span><span class="cov5" title="7">{
                key += "."
        }</span>

        <span class="cov6" title="10">key += pathItem.Name
        return key</span>
}

func format(rules []build.Rule) []RegoRule <span class="cov2" title="2">{
        res := make([]RegoRule, len(rules))
        for i, r := range rules </span><span class="cov2" title="2">{
                res[i] = RegoRule{
                        Rule:  r,
                        Block: createBlock(r),
                }
        }</span>

        <span class="cov2" title="2">return res</span>
}

func createBlock(rule build.Rule) Block <span class="cov3" title="3">{ // nolint:gocyclo
        result := Block{}
        result = resultName(rule, result)

        resources := make(map[string]struct{}, len(rule.Conditions))
        for _, condition := range rule.Conditions </span><span class="cov3" title="3">{
                if len(condition.Path) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="3">v, ok := condition.Attr("resource")
                if !ok </span><span class="cov0" title="0">{
                        for _, pathItem := range condition.Path </span><span class="cov0" title="0">{
                                if pathItem.Type == build.PathTypeResourceType </span><span class="cov0" title="0">{
                                        resources[pathItem.Name] = struct{}{}
                                }</span>
                        }

                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov3" title="3">resources, result = switchFunction(v, result, resources)</span>
        }

        <span class="cov3" title="3">result.List = make([]string, 0, len(resources))
        for resource := range resources </span><span class="cov3" title="3">{
                result.List = append(result.List, resource)
        }</span>

        <span class="cov3" title="3">return result</span>
}

func switchFunction(v interface{}, result Block, resources map[string]struct{}) (map[string]struct{}, Block) <span class="cov4" title="5">{
        switch vv := v.(type) </span>{
        case string:<span class="cov4" title="4">
                if vv == "*" </span><span class="cov4" title="4">{
                        result.All = true
                }</span>
                <span class="cov4" title="4">resources[vv] = struct{}{}</span>
        case []string:<span class="cov1" title="1">
                for _, vi := range vv </span><span class="cov2" title="2">{
                        resources[vi] = struct{}{}
                }</span>
        case []interface{}:<span class="cov0" title="0">
                for _, vi := range vv </span><span class="cov0" title="0">{
                        if vvi, ok := vi.(string); ok </span><span class="cov0" title="0">{
                                resources[vvi] = struct{}{}
                        }</span>
                }
        }
        <span class="cov4" title="5">return resources, result</span>
}

func resultName(rule build.Rule, result Block) Block <span class="cov4" title="4">{
        for _, pathItem := range rule.Conditions[len(rule.Conditions)-1].Path </span><span class="cov4" title="4">{
                if pathItem.Type == build.PathTypeResource </span><span class="cov4" title="4">{
                        result.Name = pathItem.Name
                        break</span>
                }
        }
        <span class="cov4" title="4">return result</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package descriptions

import (
        "bytes"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "time"

        "github.com/Checkmarx/kics/internal/constants"
        descModel "github.com/Checkmarx/kics/pkg/descriptions/model"
        "github.com/rs/zerolog/log"
)

var (
        //
        // The requested description content is CIS Proprietary Content owned
        // by CIS Center for Internet Security Inc. (cissecurity.org)
        //
        //  Apache License 2.0 shall not apply to any content generated by KICS
        //  which is marked as being “Proprietary to CIS” (the “CIS Proprietary Content”).
        //
        //  The CIS Proprietary Content is exclusively owned by the Center for Internet Security, Inc.
        //  and you are granted a limited, non-exclusively, non-transferable, non-sublicensable license
        //  to view the CIS Proprietary Content in connection with your use of KICS
        //
        // ***************************************************
        // *  HARDCODED authKey is NOT FOR SECURITY PURPOSES *
        // ***************************************************
        authKey = []rune{67, 101, 110, 116, 101, 114, 95, 102, 111, 114, 95, 73, 110, 116, 101, 114, 110, 101,
                116, 95, 83, 101, 99, 117, 114, 105, 116, 121, 95, 80, 114, 111, 112, 114, 105, 101, 116, 97, 114, 121,
                95, 67, 111, 110, 116, 101, 110, 116, 95, 99, 105, 115, 101, 99, 117, 114, 105, 116, 121, 46, 111, 114, 103}

        tr = &amp;http.Transport{
                MaxIdleConns:       10,
                IdleConnTimeout:    30 * time.Second,
                DisableCompression: true,
        }
        // HTTPRequestClient - http client to use for requests
        HTTPRequestClient HTTPClient = &amp;http.Client{
                Transport: tr,
                Timeout:   15 * time.Second,
        }
)

// HTTPClient - http client to use for requests
type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

// HTTPDescription - HTTP client interface to use for requesting descriptions
type HTTPDescription interface {
        CheckConnection() error
        RequestDescriptions(descriptionIDs []string) (map[string]descModel.CISDescriptions, error)
}

// Client - client for making CIS descriptions requests
type Client struct {
}

// CheckConnection - checks if the endpoint is reachable
func (c *Client) CheckConnection() error <span class="cov0" title="0">{
        baseURL, err := getBaseURL()
        if err != nil </span><span class="cov0" title="0">{
                log.Debug().Msg("Unable to get baseURL")
                return err
        }</span>

        <span class="cov0" title="0">endpointURL := fmt.Sprintf("%s/api/", baseURL)
        req, err := http.NewRequest(http.MethodGet, endpointURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Debug().Msg("Unable to create request")
                return err
        }</span>

        <span class="cov0" title="0">resp, err := doRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("Unable to GET descriptions API")
                return err
        }</span>
        <span class="cov0" title="0">log.Debug().Msg("HTTP GET success")
        defer resp.Body.Close()
        return err</span>
}

// RequestDescriptions - gets CIS descriptions from endpoint
func (c *Client) RequestDescriptions(descriptionIDs []string) (map[string]descModel.CISDescriptions, error) <span class="cov1" title="1">{
        baseURL, err := getBaseURL()
        if err != nil </span><span class="cov0" title="0">{
                log.Debug().Msg("Unable to get baseURL")
                return nil, err
        }</span>

        <span class="cov1" title="1">endpointURL := fmt.Sprintf("%s/api/%s", baseURL, "descriptions")

        descriptionRequest := descModel.DescriptionRequest{
                Version:        constants.Version,
                DescriptionIDs: descriptionIDs,
        }

        requestBody, err := json.Marshal(descriptionRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Unable to marshal request body")
                return nil, err
        }</span>

        <span class="cov1" title="1">req, err := http.NewRequest(http.MethodPost, endpointURL, bytes.NewReader(requestBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">req.Header.Add("Content-Type", "application/json")
        req.Header.Add("Authorization", fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(getBasicAuth()))))

        log.Debug().Msgf("HTTP POST to descriptions endpoint")
        startTime := time.Now()
        resp, err := doRequest(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("Unable to POST to descriptions endpoint")
                return nil, err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        endTime := time.Since(startTime)
        log.Debug().Msgf("HTTP Status: %d %s %v", resp.StatusCode, http.StatusText(resp.StatusCode), endTime)

        b, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Unable to read response body")
                return nil, err
        }</span>

        <span class="cov1" title="1">var getDescriptionsResponse descModel.DescriptionResponse
        err = json.Unmarshal(b, &amp;getDescriptionsResponse)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msg("Unable to unmarshal response body")
                return nil, err
        }</span>

        <span class="cov1" title="1">return getDescriptionsResponse.Descriptions, nil</span>
}

// doRequest - make HTTP request
func doRequest(request *http.Request) (*http.Response, error) <span class="cov10" title="2">{
        return HTTPRequestClient.Do(request)
}</span>

func getBaseURL() (string, error) <span class="cov1" title="1">{
        var rtnBaseURL string
        urlFromEnv := os.Getenv("KICS_DESCRIPTIONS_ENDPOINT")
        if constants.BaseURL == "" &amp;&amp; urlFromEnv == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("the BaseURL or KICS_DESCRIPTIONS_ENDPOINT environment variable not set")
        }</span>

        <span class="cov1" title="1">if urlFromEnv != "" </span><span class="cov1" title="1">{
                rtnBaseURL = urlFromEnv
        }</span> else<span class="cov0" title="0"> {
                rtnBaseURL = constants.BaseURL
        }</span>
        <span class="cov1" title="1">return rtnBaseURL, nil</span>
}

func getBasicAuth() string <span class="cov1" title="1">{
        auth := os.Getenv("KICS_BASIC_AUTH_PASS")
        if auth == "" </span><span class="cov1" title="1">{
                auth = string(authKey)
        }</span>
        <span class="cov1" title="1">return auth</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package descriptions

import (
        "fmt"

        "github.com/Checkmarx/kics/pkg/model"
)

var (
        descClient HTTPDescription = &amp;Client{}
)

// RequestAndOverrideDescriptions - Requests CIS descriptions and override default descriptions
func RequestAndOverrideDescriptions(summary *model.Summary) error <span class="cov8" title="1">{
        descriptionIDs := make([]string, 0)
        for idx := range summary.Queries </span><span class="cov8" title="1">{
                descriptionIDs = append(descriptionIDs, summary.Queries[idx].DescriptionID)
        }</span>

        <span class="cov8" title="1">if err := descClient.CheckConnection(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">descriptionMap, err := descClient.RequestDescriptions(descriptionIDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for idx := range summary.Queries </span><span class="cov8" title="1">{
                if descriptionMap[summary.Queries[idx].DescriptionID].DescriptionID == "" &amp;&amp;
                        descriptionMap[summary.Queries[idx].DescriptionID].RationaleText == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">descriptionID := summary.Queries[idx].DescriptionID

                summary.Queries[idx].CISDescriptionID = descriptionMap[descriptionID].DescriptionID
                summary.Queries[idx].CISDescriptionTitle = descriptionMap[descriptionID].DescriptionTitle
                summary.Queries[idx].CISDescriptionText = descriptionMap[descriptionID].DescriptionText
                summary.Queries[idx].CISRationaleText = descriptionMap[descriptionID].RationaleText
                summary.Queries[idx].CISBenchmarkName = descriptionMap[descriptionID].BenchmarkName
                summary.Queries[idx].CISBenchmarkVersion = descriptionMap[descriptionID].BenchmarkVersion

                summary.Queries[idx].CISDescriptionIDFormatted = fmt.Sprintf(
                        "CIS Security - %s v%s - Rule %s",
                        descriptionMap[descriptionID].BenchmarkName,
                        descriptionMap[descriptionID].BenchmarkVersion,
                        descriptionMap[descriptionID].DescriptionID,
                )
                summary.Queries[idx].CISDescriptionTextFormatted = fmt.Sprintf(
                        "%s\n%s",
                        descriptionMap[descriptionID].DescriptionText,
                        descriptionMap[descriptionID].RationaleText,
                )</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package detector

import (
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog"
)

const (
        undetectedVulnerabilityLine = -1
)

type defaultDetectLine struct {
}

// DetectLine searches vulnerability line if kindDetectLine is not in detectors
func (d defaultDetectLine) DetectLine(file *model.FileMetadata, searchKey string,
        logWithFields *zerolog.Logger, outputLines int) model.VulnerabilityLines <span class="cov7" title="3">{
        lines := d.SplitLines(file.OriginalData)
        var isBreak bool
        foundAtLeastOne := false
        currentLine := 0
        var extractedString [][]string
        extractedString = GetBracketValues(searchKey, extractedString, "")
        sanitizedSubstring := searchKey
        for idx, str := range extractedString </span><span class="cov7" title="3">{
                sanitizedSubstring = strings.Replace(sanitizedSubstring, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
        }</span>

        <span class="cov7" title="3">for _, key := range strings.Split(sanitizedSubstring, ".") </span><span class="cov10" title="5">{
                substr1, substr2 := GenerateSubstrings(key, extractedString)

                foundAtLeastOne, currentLine, isBreak = DetectCurrentLine(lines, substr1, substr2, currentLine, foundAtLeastOne)

                if isBreak </span><span class="cov1" title="1">{
                        break</span>
                }
        }

        <span class="cov7" title="3">if foundAtLeastOne </span><span class="cov4" title="2">{
                return model.VulnerabilityLines{
                        Line:      currentLine + 1,
                        VulnLines: GetAdjacentVulnLines(currentLine, outputLines, lines),
                }
        }</span>

        <span class="cov1" title="1">logWithFields.Warn().Msgf("Failed to detect line, query response %s", searchKey)

        return model.VulnerabilityLines{
                Line:      undetectedVulnerabilityLine,
                VulnLines: []model.CodeLine{},
        }</span>
}

func (d defaultDetectLine) SplitLines(content string) []string <span class="cov7" title="3">{
        text := strings.ReplaceAll(content, "\r", "")
        return strings.Split(text, "\n")
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package detector

import (
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog"
)

type kindDetectLine interface {
        DetectLine(file *model.FileMetadata, searchKey string,
                logWithFields *zerolog.Logger, outputLines int) model.VulnerabilityLines
        SplitLines(content string) []string
}

// DetectLine is a struct that associates a kindDetectLine to its FileKind
type DetectLine struct {
        detectors       map[model.FileKind]kindDetectLine
        outputLines     int
        logWithFields   *zerolog.Logger
        defaultDetector kindDetectLine
}

// NewDetectLine creates a new DetectLine's reference
func NewDetectLine(outputLines int) *DetectLine <span class="cov10" title="6">{
        return &amp;DetectLine{
                detectors:       make(map[model.FileKind]kindDetectLine),
                logWithFields:   &amp;zerolog.Logger{},
                outputLines:     outputLines,
                defaultDetector: defaultDetectLine{},
        }
}</span>

// SetupLogs will change the logger feild to be used in kindDetectLine DetectLine method
func (d *DetectLine) SetupLogs(logger *zerolog.Logger) <span class="cov1" title="1">{
        d.logWithFields = logger
}</span>

// Add adds a new kindDetectLine to the caller and returns it
func (d *DetectLine) Add(detector kindDetectLine, kind model.FileKind) *DetectLine <span class="cov4" title="2">{
        d.detectors[kind] = detector
        return d
}</span>

// DetectLine will use the correct kindDetectLine according to the files kind
// if file kind is not in detectors default detect line is called
func (d *DetectLine) DetectLine(file *model.FileMetadata, searchKey string) model.VulnerabilityLines <span class="cov4" title="2">{
        if det, ok := d.detectors[file.Kind]; ok </span><span class="cov1" title="1">{
                return det.DetectLine(file, searchKey, d.logWithFields, d.outputLines)
        }</span>
        <span class="cov1" title="1">return d.defaultDetector.DetectLine(file, searchKey, d.logWithFields, d.outputLines)</span>
}

// GetAdjecent finds and returns the lines adjecent to the line containing the vulnerability
func (d *DetectLine) GetAdjecent(file *model.FileMetadata, line int) model.VulnerabilityLines <span class="cov0" title="0">{
        if det, ok := d.detectors[file.Kind]; ok </span><span class="cov0" title="0">{
                return model.VulnerabilityLines{
                        Line:      line,
                        VulnLines: GetAdjacentVulnLines(line-1, d.outputLines, det.SplitLines(file.OriginalData)),
                }
        }</span>
        <span class="cov0" title="0">return model.VulnerabilityLines{
                Line:      line,
                VulnLines: GetAdjacentVulnLines(line-1, d.outputLines, d.defaultDetector.SplitLines(file.OriginalData)),
        }</span>
}

// SplitLines splits lines splits the file by lines based on the type of file
func (d *DetectLine) SplitLines(file *model.FileMetadata) []string <span class="cov0" title="0">{
        if det, ok := d.detectors[file.Kind]; ok </span><span class="cov0" title="0">{
                return det.SplitLines(file.OriginalData)
        }</span>
        <span class="cov0" title="0">return d.defaultDetector.SplitLines(file.OriginalData)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package docker

import (
        "regexp"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog"
)

// DetectKindLine defines a kindDetectLine type
type DetectKindLine struct {
}

const (
        undetectedVulnerabilityLine = -1
)

var (
        nameRegexDockerFileML = regexp.MustCompile(`.+\s+\\$`)
        commentRegex          = regexp.MustCompile(`^\s*#.*`)
        splitRegex            = regexp.MustCompile(`\s\\`)
)

// DetectLine searches vulnerability line in docker files
func (d DetectKindLine) DetectLine(file *model.FileMetadata, searchKey string,
        logWithFields *zerolog.Logger, outputLines int) model.VulnerabilityLines <span class="cov3" title="3">{
        text := d.SplitLines(file.OriginalData)
        lines := prepareDockerFileLines(text)
        var isBreak bool
        foundAtLeastOne := false
        currentLine := 0
        var extractedString [][]string
        extractedString = detector.GetBracketValues(searchKey, extractedString, "")
        sKey := searchKey
        for idx, str := range extractedString </span><span class="cov4" title="5">{
                sKey = strings.Replace(sKey, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
        }</span>

        <span class="cov3" title="3">for _, key := range strings.Split(sKey, ".") </span><span class="cov5" title="6">{
                substr1, substr2 := detector.GenerateSubstrings(key, extractedString)

                foundAtLeastOne, currentLine, isBreak = detector.DetectCurrentLine(lines, substr1, substr2,
                        currentLine, foundAtLeastOne)

                if isBreak </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov3" title="3">unchangedText := d.SplitLines(file.OriginalData)

        if foundAtLeastOne </span><span class="cov3" title="3">{
                return model.VulnerabilityLines{
                        Line:      currentLine + 1,
                        VulnLines: detector.GetAdjacentVulnLines(currentLine, outputLines, unchangedText),
                }
        }</span>

        <span class="cov0" title="0">logWithFields.Warn().Msgf("Failed to detect Docker line, query response %s", searchKey)

        return model.VulnerabilityLines{
                Line:      undetectedVulnerabilityLine,
                VulnLines: []model.CodeLine{},
        }</span>
}

// SplitLines splits Dockerfile document by line, multiline are considered as one
func (d DetectKindLine) SplitLines(content string) []string <span class="cov5" title="6">{
        text := strings.ReplaceAll(content, "\r", "")
        return strings.Split(text, "\n")
}</span>

func prepareDockerFileLines(text []string) []string <span class="cov3" title="3">{
        for idx, key := range text </span><span class="cov9" title="37">{
                if !commentRegex.MatchString(key) </span><span class="cov9" title="37">{
                        text[idx] = multiLineSpliter(text, key, idx)
                }</span>
        }
        <span class="cov3" title="3">return text</span>
}

func multiLineSpliter(textSplit []string, key string, idx int) string <span class="cov10" title="48">{
        if nameRegexDockerFileML.MatchString(key) </span><span class="cov6" title="11">{
                i := idx + 1
                if i &gt;= len(textSplit) </span><span class="cov0" title="0">{
                        return textSplit[idx]
                }</span>
                <span class="cov6" title="11">for textSplit[i] == "" </span><span class="cov5" title="8">{
                        i++
                        if i &gt;= len(textSplit) </span><span class="cov0" title="0">{
                                return textSplit[idx]
                        }</span>
                }
                <span class="cov6" title="11">if commentRegex.MatchString(textSplit[i]) </span><span class="cov0" title="0">{
                        textSplit[i] += " \\"
                }</span>
                <span class="cov6" title="11">textSplit[idx] = splitRegex.ReplaceAllLiteralString(textSplit[idx], " "+textSplit[i])
                textSplit[i] = ""
                textSplit[idx] = multiLineSpliter(textSplit, textSplit[idx], idx)</span>
        }
        <span class="cov10" title="48">return textSplit[idx]</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package helm

import (
        "fmt"
        "sort"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/agnivade/levenshtein"
        "github.com/rs/zerolog"
)

// DetectKindLine defines a kindDetectLine type
type DetectKindLine struct {
}

type detectCurlLine struct {
        foundRes   bool
        lineRes    int
        breakRes   bool
        lastUnique dupHistory
}

// dupHistory keeps the history of uniques
type dupHistory struct {
        unique         bool
        lastUniqueLine int
}

const (
        undetectedVulnerabilityLine = -1
)

// DetectLine is used to detect line on the helm template,
// it looks only at the keys of the template and will make use of the auxiliary added
// lines (ex: "# KICS_HELM_ID_")
func (d DetectKindLine) DetectLine(file *model.FileMetadata, searchKey string,
        logWithFields *zerolog.Logger, outputLines int) model.VulnerabilityLines <span class="cov2" title="3">{
        searchKey = fmt.Sprintf("%s.%s", strings.TrimRight(strings.TrimLeft(file.HelmID, "# "), ":"), searchKey)
        lines := d.SplitLines(file.OriginalData)
        curLineRes := detectCurlLine{
                foundRes: false,
                lineRes:  0,
                breakRes: false,
        }
        var extractedString [][]string
        extractedString = detector.GetBracketValues(searchKey, extractedString, "")
        sanitizedSubstring := searchKey
        for idx, str := range extractedString </span><span class="cov3" title="6">{
                sanitizedSubstring = strings.Replace(sanitizedSubstring, str[0], `{{`+strconv.Itoa(idx)+`}}`, -1)
        }</span>

        <span class="cov2" title="3">helmID, err := strconv.Atoi(strings.TrimSuffix(strings.TrimPrefix(file.HelmID, "# KICS_HELM_ID_"), ":"))
        if err != nil </span><span class="cov0" title="0">{
                helmID = -1
        }</span>

        // Since we are only looking at keys we can ignore the second value passed through '=' and '[]'
        <span class="cov2" title="3">for _, key := range strings.Split(sanitizedSubstring, ".") </span><span class="cov5" title="18">{
                substr1, _ := detector.GenerateSubstrings(key, extractedString)
                curLineRes = curLineRes.detectCurrentLine(lines, fmt.Sprintf("%s:", substr1), "", true, file.IDInfo, helmID)

                if curLineRes.breakRes </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // Look at dupHistory to see if the last element was duplicate, if so
        // change the line to the last unique key
        <span class="cov2" title="3">if !curLineRes.lastUnique.unique </span><span class="cov1" title="1">{
                curLineRes.lineRes = curLineRes.lastUnique.lastUniqueLine
        }</span>

        <span class="cov2" title="3">if curLineRes.foundRes </span><span class="cov2" title="3">{
                lineRemove := make(map[int]int)
                count := 0
                for i, line := range lines </span><span class="cov7" title="74">{ // Remove auxiliary lines
                        if strings.Contains(line, "# KICS_HELM_ID_") </span><span class="cov3" title="4">{
                                count++
                                lineRemove[i] = count
                                lines = append(lines[:i], lines[i+1:]...)
                        }</span>
                }
                // Update found line
                <span class="cov2" title="3">curLineRes.lineRes = removeLines(curLineRes.lineRes, lineRemove)
                return model.VulnerabilityLines{
                        Line:                 curLineRes.lineRes + 1,
                        VulnLines:            detector.GetAdjacentVulnLines(curLineRes.lineRes, outputLines, lines),
                        LineWithVulnerabilty: strings.Split(lines[curLineRes.lineRes], ": ")[0],
                }</span>
        }

        <span class="cov0" title="0">logWithFields.Warn().Msgf("Failed to detect line, query response %s", searchKey)

        return model.VulnerabilityLines{
                Line:      undetectedVulnerabilityLine,
                VulnLines: []model.CodeLine{},
        }</span>
}

// SplitLines splits the Helm document by line
func (d DetectKindLine) SplitLines(content string) []string <span class="cov2" title="3">{
        text := strings.ReplaceAll(content, "\r", "")
        return strings.Split(text, "\n")
}</span>

// removeLines is used to update the vulnerability line after removing the "# KICS_HELM_ID_"
func removeLines(current int, lineRemove map[int]int) int <span class="cov2" title="3">{
        orderByKey := make([]int, len(lineRemove))
        i := 0
        for k := range lineRemove </span><span class="cov3" title="4">{
                orderByKey[i] = k
                i++
        }</span>
        <span class="cov2" title="3">remove := 0
        sort.Ints(orderByKey)
        for _, k := range orderByKey </span><span class="cov3" title="4">{
                if current &gt; k </span><span class="cov3" title="4">{
                        remove = lineRemove[k]
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }
        <span class="cov2" title="3">current -= remove
        return current</span>
}

func (d detectCurlLine) detectCurrentLine(lines []string, str1,
        str2 string, byKey bool, idInfo map[int]interface{}, id int) detectCurlLine <span class="cov5" title="18">{
        distances := make(map[int]int)
        for i := d.lineRes; i &lt; len(lines); i++ </span><span class="cov10" title="311">{
                if str1 != "" &amp;&amp; str2 != "" </span><span class="cov0" title="0">{
                        if strings.Contains(lines[i], str1) &amp;&amp; strings.Contains(lines[i], str2) </span><span class="cov0" title="0">{
                                distances[i] = levenshtein.ComputeDistance(detector.ExtractLineFragment(lines[i], str2, byKey), str2)
                        }</span>
                } else<span class="cov10" title="311"> if str1 != "" </span><span class="cov10" title="311">{
                        if strings.Contains(lines[i], str1) </span><span class="cov5" title="23">{
                                distances[i] = levenshtein.ComputeDistance(
                                        detector.ExtractLineFragment(strings.TrimSpace(lines[i]), str1, byKey), str1)
                        }</span>
                }
        }

        <span class="cov5" title="18">lastSingle := d.lastUnique.lastUniqueLine

        if len(distances) == 0 </span><span class="cov0" title="0">{
                return detectCurlLine{
                        foundRes: d.foundRes,
                        lineRes:  d.lineRes,
                        breakRes: true,
                        lastUnique: dupHistory{
                                lastUniqueLine: lastSingle,
                                unique:         d.lastUnique.unique,
                        },
                }
        }</span>

        <span class="cov5" title="18">lineResponse := detector.SelectLineWithMinimumDistance(distances, d.lineRes)
        // if lineResponse is unique
        unique := detectLastSingle(lineResponse, distances, idInfo, id)
        if unique </span><span class="cov5" title="17">{
                lastSingle = lineResponse
        }</span>

        <span class="cov5" title="18">return detectCurlLine{
                foundRes: true,
                lineRes:  lineResponse,
                breakRes: false,
                lastUnique: dupHistory{
                        unique:         unique,
                        lastUniqueLine: lastSingle,
                },
        }</span>
}

// detectLastSingle checks if the line is unique or a duplicate
func detectLastSingle(line int, dis map[int]int, idInfo map[int]interface{}, id int) bool <span class="cov5" title="18">{
        if idInfo == nil </span><span class="cov4" title="12">{
                return true
        }</span>
        <span class="cov3" title="6">for key, value := range dis </span><span class="cov4" title="9">{
                if value == dis[line] &amp;&amp; key != line </span><span class="cov1" title="1">{
                        // check if we are only looking at original data equivalent to the vulnerability
                        if ok := idInfo[id].(map[int]int)[key]; ok != 0 </span><span class="cov1" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov3" title="5">return true</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package detector

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/agnivade/levenshtein"
        "github.com/rs/zerolog/log"
)

var (
        nameRegex       = regexp.MustCompile(`^([A-Za-z0-9-_]+)\[([A-Za-z0-9-_{}]+)]$`)
        nameRegexDocker = regexp.MustCompile(`{{(.*?)}}`)
)

const (
        namePartsLength  = 3
        valuePartsLength = 2
)

// GetBracketValues gets values inside "{{ }}" ignoring any "{{" or "}}" inside
func GetBracketValues(expr string, list [][]string, restOfString string) [][]string <span class="cov7" title="17">{
        var tempList []string
        firstOpen := strings.Index(expr, "{{")
        firstClose := strings.Index(expr, "}}")
        // in case we have '}}}' we need to advance one position to get the close
        for firstClose+2 &lt; len(expr) &amp;&amp; string(expr[firstClose+2]) == `}` &amp;&amp; firstClose != -1 </span><span class="cov1" title="1">{
                firstClose++
        }</span>
        <span class="cov7" title="17">switchVal := firstClose - firstOpen
        if switchVal == 0 </span><span class="cov5" title="9">{ // if there is no "{{" and no "}}"
                if expr != "" </span><span class="cov5" title="7">{
                        tempList = append(tempList, fmt.Sprintf("{{%s}}", expr), expr)
                        list = append(list, tempList)
                }</span>
                <span class="cov5" title="9">if restOfString == "" </span><span class="cov5" title="8">{
                        return list // if there is no more string to read from return value of list
                }</span>
                <span class="cov1" title="1">list = GetBracketValues(restOfString, list, "")</span> // recursive call to the rest of the string
        } else<span class="cov5" title="8"> if switchVal &gt; 0 </span><span class="cov5" title="6">{ // if the position of  the first "}}" is bigger than than the position of "{{"
                // recursive with the value inside of curly brackets
                list = GetBracketValues(expr[firstOpen+2:firstClose], list, expr[firstClose+2:])
        }</span> else<span class="cov2" title="2"> { // if the position of  the first "{{" is bigger than than the position of "}}"
                nextClose := strings.Index(restOfString, "}}")
                tempList = append(tempList, fmt.Sprintf("{{%s%s}}", expr, restOfString[nextClose:]),
                        fmt.Sprintf("%s%s", expr, restOfString[nextClose:]))
                list = append(list, tempList)
                list = GetBracketValues(restOfString[nextClose+2:], list, "") // recursive call to the rest of the string
        }</span>
        <span class="cov5" title="9">return list</span>
}

// GenerateSubstrings returns the substrings used for line searching depending on search key
// '.' is new line
// '=' is value in the same line
// '[]' is in the same line
func GenerateSubstrings(key string, extractedString [][]string) (substr1Res, substr2Res string) <span class="cov4" title="5">{
        var substr1, substr2 string
        if parts := nameRegex.FindStringSubmatch(key); len(parts) == namePartsLength </span><span class="cov2" title="2">{
                substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
        }</span> else<span class="cov3" title="3"> if parts := strings.Split(key, "="); len(parts) == valuePartsLength </span><span class="cov1" title="1">{
                substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
        }</span> else<span class="cov2" title="2"> {
                parts := []string{key, ""}
                substr1, substr2 = getKeyWithCurlyBrackets(key, extractedString, parts)
        }</span>
        <span class="cov4" title="5">return substr1, substr2</span>
}

func getKeyWithCurlyBrackets(key string, extractedString [][]string, parts []string) (substr1Res, substr2Res string) <span class="cov4" title="5">{
        var substr1, substr2 string
        extractedPart := nameRegexDocker.FindStringSubmatch(key)
        if len(extractedPart) == valuePartsLength </span><span class="cov1" title="1">{
                for idx, key := range parts </span><span class="cov2" title="2">{
                        if extractedPart[0] == key </span><span class="cov1" title="1">{
                                switch idx </span>{
                                case (len(parts) - 2):<span class="cov0" title="0">
                                        i, err := strconv.Atoi(extractedPart[1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error().Msgf("failed to extract curly brackets substring")
                                        }</span>
                                        <span class="cov0" title="0">substr1 = extractedString[i][1]</span>
                                case len(parts) - 1:<span class="cov1" title="1">
                                        i, err := strconv.Atoi(extractedPart[1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error().Msgf("failed to extract curly brackets substring")
                                        }</span>
                                        <span class="cov1" title="1">substr2 = extractedString[i][1]</span>
                                }
                        } else<span class="cov1" title="1"> {
                                substr1 = generateSubstr(substr1, parts, valuePartsLength)
                                substr2 = generateSubstr(substr2, parts, 1)
                        }</span>
                }
        } else<span class="cov4" title="4"> {
                substr1 = parts[len(parts)-2]
                substr2 = parts[len(parts)-1]
        }</span>

        <span class="cov4" title="5">return substr1, substr2</span>
}

func generateSubstr(substr string, parts []string, leng int) string <span class="cov2" title="2">{
        if substr == "" </span><span class="cov2" title="2">{
                substr = parts[len(parts)-leng]
        }</span>
        <span class="cov2" title="2">return substr</span>
}

// GetAdjacentVulnLines is used to get the lines adjecent to the line that contains the vulnerability
// adj is the amount of lines wanted
func GetAdjacentVulnLines(idx, adj int, lines []string) []model.CodeLine <span class="cov5" title="9">{
        var endPos int
        var startPos int
        if adj &lt;= len(lines) </span><span class="cov5" title="8">{
                endPos = idx + adj/2 + 1 // if adj lines passes the number of lines in file
                if len(lines) &lt; endPos </span><span class="cov1" title="1">{
                        endPos = len(lines)
                }</span>
                <span class="cov5" title="8">startAdj := adj
                if adj%2 == 0 </span><span class="cov2" title="2">{
                        startAdj--
                }</span>

                <span class="cov5" title="8">startPos = idx - startAdj/2 // if adj lines passes the first line in the file
                if startPos &lt; 0 </span><span class="cov1" title="1">{
                        startPos = 0
                }</span>
        } else<span class="cov1" title="1"> { // in case adj is bigger than number of lines in file
                adj = len(lines)
                endPos = len(lines)
                startPos = 0
        }</span>

        <span class="cov5" title="9">switch idx </span>{
        case 0:<span class="cov2" title="2">
                // case vulnerability is the first line of the file
                return createVulnLines(1, lines[:adj])</span>
        case len(lines) - 1:<span class="cov3" title="3">
                // case vulnerability is the last line of the file
                return createVulnLines(startPos+1, lines[len(lines)-adj:])</span>
        default:<span class="cov4" title="4">
                // case vulnerability is in the midle of the file
                return createVulnLines(startPos+1, lines[startPos:endPos])</span>
        }
}

// createVulnLines is the function that will  generate the array that contains the lines numbers
// used to alter the color of the line that contains the vulnerability
func createVulnLines(startPos int, lines []string) []model.CodeLine <span class="cov5" title="9">{
        vulns := make([]model.CodeLine, len(lines))
        for idx, line := range lines </span><span class="cov8" title="24">{
                vulns[idx] = model.CodeLine{
                        Line:     line,
                        Position: startPos,
                }
                startPos++
        }</span>
        <span class="cov5" title="9">return vulns</span>
}

// SelectLineWithMinimumDistance will search a map of levenshtein distances to find the minimum distance
func SelectLineWithMinimumDistance(distances map[int]int, startingFrom int) int <span class="cov5" title="7">{
        minDistance, lineOfMinDistance := constants.MaxInteger, startingFrom
        for line, distance := range distances </span><span class="cov6" title="10">{
                if distance &lt; minDistance || distance == minDistance &amp;&amp; line &lt; lineOfMinDistance </span><span class="cov5" title="9">{
                        minDistance = distance
                        lineOfMinDistance = line
                }</span>
        }

        <span class="cov5" title="7">return lineOfMinDistance</span>
}

// ExtractLineFragment will prepare substr for line detection
func ExtractLineFragment(line, substr string, key bool) string <span class="cov5" title="7">{
        // If detecting line by keys only
        if key </span><span class="cov0" title="0">{
                return line[:strings.Index(line, ":")]
        }</span>
        <span class="cov5" title="7">start := strings.Index(line, substr)
        end := start + len(substr)

        for start &gt;= 0 </span><span class="cov8" title="24">{
                if line[start] == ' ' </span><span class="cov5" title="6">{
                        break</span>
                }

                <span class="cov7" title="18">start--</span>
        }

        <span class="cov5" title="7">for end &lt; len(line) </span><span class="cov6" title="11">{
                if line[end] == ' ' </span><span class="cov5" title="6">{
                        break</span>
                }

                <span class="cov4" title="5">end++</span>
        }

        <span class="cov5" title="7">return removeExtras(line, start, end)</span>
}

func removeExtras(result string, start, end int) string <span class="cov5" title="7">{
        // workaround for selecting yaml keys
        if result[end-1] == ':' </span><span class="cov0" title="0">{
                end--
        }</span>

        <span class="cov5" title="7">if result[end-1] == '"' </span><span class="cov4" title="5">{
                end--
        }</span>

        <span class="cov5" title="7">if result[start+1] == '"' </span><span class="cov4" title="5">{
                start++
        }</span>

        <span class="cov5" title="7">return result[start+1 : end]</span>
}

// DetectCurrentLine uses levenshtein distance to find the most acurate line for the vulnerability
func DetectCurrentLine(lines []string, str1, str2 string,
        curLine int, foundOne bool) (foundRes bool, lineRes int, breakRes bool) <span class="cov4" title="5">{
        distances := make(map[int]int)
        for i := curLine; i &lt; len(lines); i++ </span><span class="cov10" title="53">{
                if str1 != "" &amp;&amp; str2 != "" </span><span class="cov8" title="32">{
                        if strings.Contains(lines[i], str1) </span><span class="cov4" title="4">{
                                restLine := lines[i][strings.Index(lines[i], str1)+len(str1):]
                                if strings.Contains(restLine, str2) </span><span class="cov3" title="3">{
                                        distances[i] = levenshtein.ComputeDistance(ExtractLineFragment(lines[i], str1, false), str1)
                                        distances[i] += levenshtein.ComputeDistance(ExtractLineFragment(restLine, str2, false), str2)
                                }</span>
                        }
                } else<span class="cov7" title="21"> if str1 != "" </span><span class="cov7" title="21">{
                        if strings.Contains(lines[i], str1) </span><span class="cov1" title="1">{
                                distances[i] = levenshtein.ComputeDistance(ExtractLineFragment(lines[i], str1, false), str1)
                        }</span>
                }
        }

        <span class="cov4" title="5">if len(distances) == 0 </span><span class="cov1" title="1">{
                return foundOne, curLine, true
        }</span>

        <span class="cov4" title="4">return true, SelectLineWithMinimumDistance(distances, curLine), false</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package detector

import (
        "encoding/json"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/tidwall/gjson"
)

// searchLineDetector is the struct used to get the line from the payload with lines information
// content - payload with line information
// resolvedPath - string created from pathComponents, used to create gjson paths
// resolvedArrayPath - string created from pathComponents containing an array used to create gjson paths
// targetObj - key of the interface{}, we want the line from
type searchLineDetector struct {
        content           []byte
        resolvedPath      string
        resolvedArrayPath string
        targetObj         string
}

// GetLineBySearchLine makes use of the gjson pkg to find the line of a key in the original file
// with it's path given by a slice of strings
func GetLineBySearchLine(pathComponents []string, file *model.FileMetadata) (int, error) <span class="cov6" title="5">{
        content, err := json.Marshal(file.LineInfoDocument)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov6" title="5">detector := &amp;searchLineDetector{
                content: content,
        }

        return detector.preparePath(pathComponents), nil</span>
}

// preparePath resolves the path components and retrives important information
// for the creation of the paths to search
func (d *searchLineDetector) preparePath(pathItems []string) int <span class="cov6" title="5">{
        if len(pathItems) == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>
        // Escaping '.' in path components so it doesn't conflict with gjson pkg
        <span class="cov6" title="5">objPath := strings.ReplaceAll(pathItems[0], ".", "\\.")
        ArrPath := strings.ReplaceAll(pathItems[0], ".", "\\.")

        obj := pathItems[len(pathItems)-1]

        arrayObject := ""

        // Iterate reversely through the path componets and get the key of the last array in the path
        // needed for cases where the fields in the array are &lt;"key": "value"&gt; type and not &lt;object&gt;
        foundArrayIdx := false
        for i := len(pathItems) - 1; i &gt;= 0; i-- </span><span class="cov10" title="14">{
                if _, err := strconv.Atoi(pathItems[i]); err == nil </span><span class="cov4" title="3">{
                        foundArrayIdx = true
                        continue</span>
                }
                <span class="cov9" title="11">if foundArrayIdx </span><span class="cov4" title="3">{
                        arrayObject = pathItems[i]
                        break</span>
                }
        }

        <span class="cov6" title="5">if arrayObject == objPath </span><span class="cov3" title="2">{
                ArrPath = "_kics_lines._kics_" + arrayObject + "._kics_arr"
        }</span>

        <span class="cov6" title="5">var treatedPathItems []string
        if len(pathItems) &gt; 1 </span><span class="cov6" title="5">{
                treatedPathItems = pathItems[1 : len(pathItems)-1]
        }</span>

        // Create a string based on the path components so it can be later transformed in a gjson path
        <span class="cov6" title="5">for _, pathItem := range treatedPathItems </span><span class="cov6" title="5">{
                // In case of an array present
                if pathItem == arrayObject </span><span class="cov1" title="1">{
                        ArrPath += "._kics_lines._kics_" + strings.ReplaceAll(pathItem, ".", "\\.") + "._kics_arr"
                }</span> else<span class="cov5" title="4"> {
                        ArrPath += "." + strings.ReplaceAll(pathItem, ".", "\\.")
                }</span>
                <span class="cov6" title="5">objPath += "." + strings.ReplaceAll(pathItem, ".", "\\.")</span>
        }

        <span class="cov6" title="5">d.resolvedPath = objPath
        d.resolvedArrayPath = ArrPath
        d.targetObj = obj

        return d.getResult()</span>
}

// getResult creates the paths to be used by gjson pkg to find the line in the content
func (d *searchLineDetector) getResult() int <span class="cov6" title="5">{
        pathObjects := []string{
                d.resolvedPath + "._kics_lines._kics_" + d.targetObj + "._kics_line",
                d.resolvedPath + "." + d.targetObj + "._kics_lines._kics__default._kics_line",
                d.resolvedArrayPath + "." + d.targetObj + "._kics__default._kics_line",
                d.resolvedArrayPath + "._kics_" + d.targetObj + "._kics_line",
        }

        result := -1
        // run gjson pkg
        for _, pathItem := range pathObjects </span><span class="cov8" title="10">{
                if tmpResult := gjson.GetBytes(d.content, pathItem); int(tmpResult.Int()) &gt; 0 </span><span class="cov6" title="5">{
                        result = int(tmpResult.Int())
                        break</span>
                }
        }
        <span class="cov6" title="5">return result</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package engine

import (
        "bytes"
        "context"
        "encoding/json"
        "strings"
        "time"

        "github.com/Checkmarx/kics/internal/metrics"
        "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/detector/docker"
        "github.com/Checkmarx/kics/pkg/detector/helm"
        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/getsentry/sentry-go"
        "github.com/open-policy-agent/opa/ast"
        "github.com/open-policy-agent/opa/cover"
        "github.com/open-policy-agent/opa/rego"
        "github.com/open-policy-agent/opa/storage/inmem"
        "github.com/open-policy-agent/opa/topdown"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// Default values for inspector
const (
        UndetectedVulnerabilityLine = -1
        DefaultQueryID              = "Undefined"
        DefaultQueryName            = "Anonymous"
        DefaultQueryDescription     = "Undefined"
        DefaultQueryDescriptionID   = "Undefined"
        DefaultQueryURI             = "https://github.com/Checkmarx/kics/"
        DefaultIssueType            = model.IssueTypeIncorrectValue

        regoQuery = `result = data.Cx.CxPolicy`
)

// ErrNoResult - error representing when a query didn't return a result
var ErrNoResult = errors.New("query: not result")

// ErrInvalidResult - error representing invalid result
var ErrInvalidResult = errors.New("query: invalid result format")

// VulnerabilityBuilder represents a function that will build a vulnerability
type VulnerabilityBuilder func(ctx *QueryContext, tracker Tracker, v interface{},
        detector *detector.DetectLine) (model.Vulnerability, error)

type preparedQuery struct {
        opaQuery rego.PreparedEvalQuery
        metadata model.QueryMetadata
}

// Inspector represents a list of compiled queries, a builder for vulnerabilities, an information tracker
// a flag to enable coverage and the coverage report if it is enabled
type Inspector struct {
        queries        []*preparedQuery
        vb             VulnerabilityBuilder
        tracker        Tracker
        failedQueries  map[string]error
        excludeResults map[string]bool
        detector       *detector.DetectLine

        enableCoverageReport bool
        coverageReport       cover.Report
        queryExecTimeout     time.Duration
}

// QueryContext contains the context where the query is executed, which scan it belongs, basic information of query,
// the query compiled and its payload
type QueryContext struct {
        ctx           context.Context
        scanID        string
        files         map[string]model.FileMetadata
        query         *preparedQuery
        payload       model.Documents
        baseScanPaths []string
}

var (
        unsafeRegoFunctions = map[string]struct{}{
                "http.send":   {},
                "opa.runtime": {},
        }
)

// NewInspector initializes a inspector, compiling and loading queries for scan and its tracker
func NewInspector(
        ctx context.Context,
        queriesSource source.QueriesSource,
        vb VulnerabilityBuilder,
        tracker Tracker,
        queryParameters *source.QueryInspectorParameters,
        excludeResults map[string]bool,
        queryTimeout int) (*Inspector, error) <span class="cov2" title="4">{
        log.Debug().Msg("engine.NewInspector()")

        metrics.Metric.Start("get_queries")
        queries, err := queriesSource.GetQueries(queryParameters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to get queries")
        }</span>

        <span class="cov2" title="4">commonLibrary, err := queriesSource.GetQueryLibrary("common")
        if err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Err(err).
                        Msgf("Inspector failed to get library for %s platform", "common")
                return nil, errors.Wrap(err, "failed to get library")
        }</span>
        <span class="cov2" title="4">platformLibraries := getPlatformLibraries(queriesSource, queries)
        opaQueries := make([]*preparedQuery, 0, len(queries))
        for _, metadata := range queries </span><span class="cov10" title="3760">{
                platformGeneralQuery, ok := platformLibraries[metadata.Platform]
                if !ok </span><span class="cov0" title="0">{
                        log.Err(err).
                                Msgf("Inspector failed to get generic query, query=%s", metadata.Query)
                        continue</span>
                }

                <span class="cov10" title="3760">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, nil</span>
                default:<span class="cov10" title="3760">
                        var opaQuery rego.PreparedEvalQuery
                        mergedInputData, err := source.MergeInputData(platformGeneralQuery.LibraryInputData, metadata.InputData)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debug().Msg("Could not merge platform library input data")
                        }</span>
                        <span class="cov10" title="3760">mergedInputData, err = source.MergeInputData(commonLibrary.LibraryInputData, mergedInputData)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debug().Msg("Could not merge common library input data")
                        }</span>
                        <span class="cov10" title="3760">store := inmem.NewFromReader(bytes.NewBufferString(mergedInputData))
                        opaQuery, err = rego.New(
                                rego.Query(regoQuery),
                                rego.Module("Common", commonLibrary.LibraryCode),
                                rego.Module("Generic", platformGeneralQuery.LibraryCode),
                                rego.Module(metadata.Query, metadata.Content),
                                rego.Store(store),
                                rego.UnsafeBuiltins(unsafeRegoFunctions),
                        ).PrepareForEval(ctx)

                        if err != nil </span><span class="cov0" title="0">{
                                sentry.CaptureException(err)
                                log.Err(err).
                                        Msgf("Inspector failed to prepare query for evaluation, query=%s", metadata.Query)

                                continue</span>
                        }

                        <span class="cov10" title="3760">tracker.TrackQueryLoad(metadata.Aggregation)

                        opaQueries = append(opaQueries, &amp;preparedQuery{
                                opaQuery: opaQuery,
                                metadata: metadata,
                        })</span>
                }
        }

        <span class="cov2" title="4">failedQueries := make(map[string]error)

        queriesNumber := sumAllAggregatedQueries(opaQueries)

        metrics.Metric.Stop()

        log.Info().
                Msgf("Inspector initialized, number of queries=%d", queriesNumber)

        lineDetector := detector.NewDetectLine(tracker.GetOutputLines()).
                Add(helm.DetectKindLine{}, model.KindHELM).
                Add(docker.DetectKindLine{}, model.KindDOCKER)

        queryExecTimeout := time.Duration(queryTimeout) * time.Second
        log.Info().Msgf("Query execution timeout=%v", queryExecTimeout)

        return &amp;Inspector{
                queries:          opaQueries,
                vb:               vb,
                tracker:          tracker,
                failedQueries:    failedQueries,
                excludeResults:   excludeResults,
                detector:         lineDetector,
                queryExecTimeout: queryExecTimeout,
        }, nil</span>
}

func getPlatformLibraries(queriesSource source.QueriesSource, queries []model.QueryMetadata) map[string]source.RegoLibraries <span class="cov2" title="4">{
        supportedPlatforms := make(map[string]string)
        for _, query := range queries </span><span class="cov10" title="3760">{
                supportedPlatforms[query.Platform] = ""
        }</span>
        <span class="cov2" title="4">platformLibraries := make(map[string]source.RegoLibraries)
        for platform := range supportedPlatforms </span><span class="cov4" title="22">{
                platformLibrary, errLoadingPlatformLib := queriesSource.GetQueryLibrary(platform)
                if errLoadingPlatformLib != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(errLoadingPlatformLib)
                        log.Err(errLoadingPlatformLib).
                                Msgf("Inspector failed to get library for %s platform", platform)
                        continue</span>
                }
                <span class="cov4" title="22">platformLibraries[platform] = platformLibrary</span>
        }
        <span class="cov2" title="4">return platformLibraries</span>
}

func sumAllAggregatedQueries(opaQueries []*preparedQuery) int <span class="cov2" title="4">{
        sum := 0
        for _, query := range opaQueries </span><span class="cov10" title="3760">{
                sum += query.metadata.Aggregation
        }</span>
        <span class="cov2" title="4">return sum</span>
}

// Inspect scan files and return the a list of vulnerabilities found on the process
func (c *Inspector) Inspect(
        ctx context.Context,
        scanID string,
        files model.FileMetadatas,
        baseScanPaths []string,
        platforms []string,
        currentQuery chan&lt;- int64) ([]model.Vulnerability, error) <span class="cov1" title="2">{
        log.Debug().Msg("engine.Inspect()")
        combinedFiles := files.Combine(false)

        _, err := json.Marshal(combinedFiles)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="2">var vulnerabilities []model.Vulnerability
        vulnerabilities = make([]model.Vulnerability, 0)
        for _, query := range c.getQueriesByPlat(platforms) </span><span class="cov1" title="2">{
                currentQuery &lt;- 1

                vuls, err := c.doRun(&amp;QueryContext{
                        ctx:           ctx,
                        scanID:        scanID,
                        files:         files.ToMap(),
                        query:         query,
                        payload:       combinedFiles,
                        baseScanPaths: baseScanPaths,
                })
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        log.Err(err).
                                Str("scanID", scanID).
                                Msgf("Inspector. query executed with error, query=%s", query.metadata.Query)

                        c.failedQueries[query.metadata.Query] = err

                        continue</span>
                }

                <span class="cov1" title="2">vulnerabilities = append(vulnerabilities, vuls...)

                c.tracker.TrackQueryExecution(query.metadata.Aggregation)</span>
        }

        <span class="cov1" title="2">return vulnerabilities, nil</span>
}

// LenQueriesByPlat returns the number of queries by platforms
func (c *Inspector) LenQueriesByPlat(platforms []string) int <span class="cov1" title="2">{
        count := 0
        for _, query := range c.queries </span><span class="cov9" title="2506">{
                if contains(platforms, query.metadata.Platform) </span><span class="cov7" title="507">{
                        c.tracker.TrackQueryExecuting(query.metadata.Aggregation)
                        count++
                }</span>
        }
        <span class="cov1" title="2">return count</span>
}

func (c *Inspector) getQueriesByPlat(platforms []string) []*preparedQuery <span class="cov1" title="2">{
        queries := make([]*preparedQuery, 0)
        for _, query := range c.queries </span><span class="cov1" title="2">{
                if contains(platforms, query.metadata.Platform) </span><span class="cov1" title="2">{
                        queries = append(queries, query)
                }</span>
        }
        <span class="cov1" title="2">return queries</span>
}

// EnableCoverageReport enables the flag to create a coverage report
func (c *Inspector) EnableCoverageReport() <span class="cov1" title="1">{
        c.enableCoverageReport = true
}</span>

// GetCoverageReport returns the scan coverage report
func (c *Inspector) GetCoverageReport() cover.Report <span class="cov1" title="1">{
        return c.coverageReport
}</span>

// GetFailedQueries returns a map of failed queries and the associated error
func (c *Inspector) GetFailedQueries() map[string]error <span class="cov1" title="1">{
        return c.failedQueries
}</span>

func (c *Inspector) doRun(ctx *QueryContext) ([]model.Vulnerability, error) <span class="cov1" title="2">{
        timeoutCtx, cancel := context.WithTimeout(ctx.ctx, c.queryExecTimeout)
        defer cancel()
        options := []rego.EvalOption{rego.EvalInput(ctx.payload)}

        var cov *cover.Cover
        if c.enableCoverageReport </span><span class="cov1" title="2">{
                cov = cover.New()
                options = append(options, rego.EvalQueryTracer(cov))
        }</span>

        <span class="cov1" title="2">results, err := ctx.query.opaQuery.Eval(timeoutCtx, options...)
        if err != nil </span><span class="cov0" title="0">{
                if topdown.IsCancel(err) </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "query executing timeout exited")
                }</span>

                <span class="cov0" title="0">return nil, errors.Wrap(err, "failed to evaluate query")</span>
        }
        <span class="cov1" title="2">if c.enableCoverageReport &amp;&amp; cov != nil </span><span class="cov1" title="2">{
                module, parseErr := ast.ParseModule(ctx.query.metadata.Query, ctx.query.metadata.Content)
                if parseErr != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(parseErr, "failed to parse coverage module")
                }</span>

                <span class="cov1" title="2">c.coverageReport = cov.Report(map[string]*ast.Module{
                        ctx.query.metadata.Query: module,
                })</span>
        }

        <span class="cov1" title="2">log.Trace().
                Str("scanID", ctx.scanID).
                Msgf("Inspector executed with result %+v, query=%s", results, ctx.query.metadata.Query)

        return c.decodeQueryResults(ctx, results)</span>
}

func (c *Inspector) decodeQueryResults(ctx *QueryContext, results rego.ResultSet) ([]model.Vulnerability, error) <span class="cov1" title="2">{
        if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, ErrNoResult
        }</span>

        <span class="cov1" title="2">result := results[0].Bindings

        queryResult, ok := result["result"]
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrNoResult
        }</span>

        <span class="cov1" title="2">queryResultItems, ok := queryResult.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidResult
        }</span>

        <span class="cov1" title="2">vulnerabilities := make([]model.Vulnerability, 0, len(queryResultItems))
        failedDetectLine := false
        for _, queryResultItem := range queryResultItems </span><span class="cov1" title="2">{
                vulnerability, err := c.vb(ctx, c.tracker, queryResultItem, c.detector)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        log.Err(err).
                                Msgf("Inspector can't save vulnerability, query=%s", ctx.query.metadata.Query)

                        if _, ok := c.failedQueries[ctx.query.metadata.Query]; !ok </span><span class="cov0" title="0">{
                                c.failedQueries[ctx.query.metadata.Query] = err
                        }</span>

                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov1" title="2">file := ctx.files[vulnerability.FileID]
                if shouldSkipFile(file.Commands, vulnerability.QueryID) </span><span class="cov0" title="0">{
                        log.Debug().Msgf("Skipping file %s for query %s", file.FilePath, ctx.query.metadata.Query)
                        continue</span>
                }

                <span class="cov1" title="2">if vulnerability.Line == UndetectedVulnerabilityLine </span><span class="cov1" title="2">{
                        failedDetectLine = true
                }</span>

                <span class="cov1" title="2">if _, ok := c.excludeResults[vulnerability.SimilarityID]; ok </span><span class="cov1" title="1">{
                        log.Debug().
                                Msgf("Excluding result SimilarityID: %s", vulnerability.SimilarityID)
                }</span> else<span class="cov1" title="1"> {
                        vulnerabilities = append(vulnerabilities, vulnerability)
                }</span>
        }

        <span class="cov1" title="2">if failedDetectLine </span><span class="cov1" title="2">{
                c.tracker.FailedDetectLine()
        }</span>

        <span class="cov1" title="2">return vulnerabilities, nil</span>
}

// contains is a simple method to check if a slice
// contains an entry
func contains(s []string, e string) bool <span class="cov9" title="2512">{
        if e == "common" </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov9" title="2511">if e == "k8s" </span><span class="cov6" title="161">{
                e = "kubernetes"
        }</span>
        <span class="cov9" title="2511">for _, a := range s </span><span class="cov9" title="2512">{
                if strings.EqualFold(a, e) </span><span class="cov7" title="511">{
                        return true
                }</span>
        }
        <span class="cov9" title="2000">return false</span>
}

func shouldSkipFile(command model.CommentsCommands, queryID string) bool <span class="cov3" title="7">{
        if queries, ok := command["enable"]; ok </span><span class="cov1" title="2">{
                for _, query := range strings.Split(queries, ",") </span><span class="cov1" title="2">{
                        if strings.EqualFold(query, queryID) </span><span class="cov1" title="1">{
                                return false
                        }</span>
                }
                <span class="cov1" title="1">return true</span>
        }
        <span class="cov2" title="5">if queries, ok := command["disable"]; ok </span><span class="cov1" title="2">{
                for _, query := range strings.Split(queries, ",") </span><span class="cov1" title="2">{
                        if strings.EqualFold(query, queryID) </span><span class="cov1" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov2" title="4">return false</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package provider

import (
        "context"
        "io/fs"
        "os"
        "os/signal"
        "path/filepath"
        "strconv"
        "sync"
        "time"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"

        "github.com/hashicorp/go-getter"
)

const (
        channelLength = 2
        tempDirFormat = 1e9
)

// ExtractedPath is a struct that contains the paths, temporary paths to remove
// and extraction map path of the sources
// Path is the slice of paths to scan
// ExtractionMap is a map that correlates the temporary path to the given path
// RemoveTmp is the slice containing temporary paths to be removed
type ExtractedPath struct {
        Path          []string
        ExtractionMap map[string]model.ExtractedPathObject
}

type getterStruct struct {
        ctx         context.Context
        cancel      context.CancelFunc
        mode        getter.ClientMode
        pwd         string
        opts        []getter.ClientOption
        destination string
        source      string
}

// GetSources goes through the source slice, and determines the of source type (ex: zip, git, local).
// It than extracts the files to be scanned. If the source given is not local, a temp dir
// will be created where the files will be stored.
func GetSources(source []string) (ExtractedPath, error) <span class="cov10" title="4">{
        extrStruct := ExtractedPath{
                Path:          []string{},
                ExtractionMap: make(map[string]model.ExtractedPathObject),
        }
        for _, path := range source </span><span class="cov10" title="4">{
                destination := filepath.Join(os.TempDir(), "kics-extract-"+nextRandom())

                mode := getter.ClientModeAny

                pwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal().Msgf("Error getting wd: %s", err)
                }</span>

                <span class="cov10" title="4">opts := []getter.ClientOption{}

                opts = append(opts, getter.WithInsecure())

                ctx, cancel := context.WithCancel(context.Background())

                goGetter := getterStruct{
                        ctx:         ctx,
                        cancel:      cancel,
                        mode:        mode,
                        pwd:         pwd,
                        opts:        opts,
                        destination: destination,
                        source:      path,
                }

                getterDst, err := getPaths(&amp;goGetter)
                if err != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("failed to find path %s: %s", path, err)
                        return ExtractedPath{}, err
                }</span>
                <span class="cov8" title="3">tempDst, local := checkSymLink(getterDst, path)

                extrStruct.ExtractionMap[getterDst] = model.ExtractedPathObject{
                        Path:      path,
                        LocalPath: local,
                }

                extrStruct.Path = append(extrStruct.Path, tempDst)</span>
        }

        <span class="cov8" title="3">return extrStruct, nil</span>
}

func getPaths(g *getterStruct) (string, error) <span class="cov10" title="4">{
        // Build the client
        client := &amp;getter.Client{
                Ctx:     g.ctx,
                Src:     g.source,
                Dst:     g.destination,
                Pwd:     g.pwd,
                Mode:    g.mode,
                Options: g.opts,
        }

        wg := sync.WaitGroup{}
        wg.Add(1)
        errChan := make(chan error, channelLength)
        go func() </span><span class="cov10" title="4">{
                defer wg.Done()
                defer g.cancel()
                if err := client.Get(); err != nil </span><span class="cov1" title="1">{
                        errChan &lt;- err
                }</span>
        }()

        <span class="cov10" title="4">c := make(chan os.Signal, channelLength)
        signal.Notify(c, os.Interrupt)

        select </span>{
        case &lt;-c:<span class="cov0" title="0">
                signal.Reset(os.Interrupt)
                g.cancel()
                wg.Wait()</span>
        case &lt;-g.ctx.Done():<span class="cov8" title="3">
                wg.Wait()</span>
        case err := &lt;-errChan:<span class="cov1" title="1">
                wg.Wait()
                return "", err</span>
        }

        <span class="cov8" title="3">return g.destination, nil</span>
}

// check if the dst is a symbolic link
func checkSymLink(getterDst, pathFile string) (string, bool) <span class="cov8" title="3">{
        var local bool
        _, err := os.Stat(pathFile)
        if err == nil </span><span class="cov8" title="3">{ // check if file exist locally
                local = true
        }</span>

        <span class="cov8" title="3">info, err := os.Lstat(getterDst)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed lstat for %s: %v", getterDst, err)
        }</span>

        <span class="cov8" title="3">fileInfo := getFileInfo(info, getterDst, pathFile)

        if info.Mode()&amp;os.ModeSymlink != 0 </span><span class="cov5" title="2">{ // if it's a symbolic Link
                path, err := os.Readlink(getterDst) // get location of symbolic Link
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed Readlink for %s: %v", getterDst, err)
                }</span>
                <span class="cov5" title="2">getterDst = path</span> // change path to local path
        } else<span class="cov1" title="1"> if !fileInfo.IsDir() </span><span class="cov0" title="0">{ // symbolic links are not created for single files
                if local </span><span class="cov0" title="0">{ // check if file exist locally
                        getterDst = pathFile
                }</span>
        }
        <span class="cov8" title="3">return getterDst, local</span>
}

func getFileInfo(info fs.FileInfo, dst, pathFile string) fs.FileInfo <span class="cov8" title="3">{
        var extension = filepath.Ext(pathFile)
        var path string
        if extension == "" </span><span class="cov5" title="2">{
                path = filepath.Join(dst, filepath.Base(pathFile[0:len(pathFile)-len(extension)])) // for single file
        }</span> else<span class="cov1" title="1"> {
                path = filepath.Join(dst, filepath.Base(pathFile)) // for directories
        }</span>
        <span class="cov8" title="3">fileInfo, err := os.Lstat(path)
        if err != nil </span><span class="cov8" title="3">{
                fileInfo = info
        }</span>
        <span class="cov8" title="3">return fileInfo</span>
}

// ======== Golang way to create random number for tmp dir naming =============
var rand uint32
var randmu sync.Mutex

func reseed() uint32 <span class="cov1" title="1">{
        return uint32(time.Now().UnixNano() + int64(os.Getpid()))
}</span>

func nextRandom() string <span class="cov10" title="4">{
        randmu.Lock()
        r := rand
        if r == 0 </span><span class="cov1" title="1">{
                r = reseed()
        }</span>
        <span class="cov10" title="4">r = r*1664525 + 1013904223 // constants from Numerical Recipes
        rand = r
        randmu.Unlock()
        return strconv.Itoa(int(tempDirFormat + r%tempDirFormat))[1:]</span>
}

// ==============================================================================
</pre>
		
		<pre class="file" id="file33" style="display: none">package provider

import (
        "context"
        "os"
        "path/filepath"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/getsentry/sentry-go"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// FileSystemSourceProvider provides a path to be scanned
// and a list of files which will not be scanned
type FileSystemSourceProvider struct {
        paths    []string
        excludes map[string][]os.FileInfo
}

// ErrNotSupportedFile - error representing when a file format is not supported by KICS
var ErrNotSupportedFile = errors.New("invalid file format")

// NewFileSystemSourceProvider initializes a FileSystemSourceProvider with path and files that will be ignored
func NewFileSystemSourceProvider(paths, excludes []string) (*FileSystemSourceProvider, error) <span class="cov2" title="5">{
        log.Debug().Msgf("provider.NewFileSystemSourceProvider()")
        ex := make(map[string][]os.FileInfo, len(excludes))
        osPaths := make([]string, len(paths))
        for idx, path := range paths </span><span class="cov2" title="7">{
                osPaths[idx] = filepath.FromSlash(path)
        }</span>
        <span class="cov2" title="5">fs := &amp;FileSystemSourceProvider{
                paths:    osPaths,
                excludes: ex,
        }
        for _, exclude := range excludes </span><span class="cov1" title="2">{
                excludePaths, err := getExcludePaths(exclude)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="2">if err := fs.AddExcluded(excludePaths); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov2" title="5">return fs, nil</span>
}

// AddExcluded add new excluded files to the File System Source Provider
func (s *FileSystemSourceProvider) AddExcluded(excludePaths []string) error <span class="cov2" title="4">{
        for _, excludePath := range excludePaths </span><span class="cov1" title="3">{
                info, err := os.Stat(excludePath)
                if err != nil </span><span class="cov1" title="2">{
                        if os.IsNotExist(err) </span><span class="cov1" title="2">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return errors.Wrap(err, "failed to open excluded file")</span>
                }
                <span class="cov1" title="1">if _, ok := s.excludes[info.Name()]; !ok </span><span class="cov1" title="1">{
                        s.excludes[info.Name()] = make([]os.FileInfo, 0)
                }</span>
                <span class="cov1" title="1">s.excludes[info.Name()] = append(s.excludes[info.Name()], info)</span>
        }
        <span class="cov2" title="4">return nil</span>
}

func getExcludePaths(pathExpressions string) ([]string, error) <span class="cov1" title="3">{
        if strings.ContainsAny(pathExpressions, "*?[") </span><span class="cov1" title="1">{
                info, err := filepath.Glob(pathExpressions)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to open excluded file")
                }</span>
                <span class="cov1" title="1">return info, nil</span>
        }
        <span class="cov1" title="2">return []string{pathExpressions}, nil</span>
}

// GetBasePaths returns base path of FileSystemSourceProvider
func (s *FileSystemSourceProvider) GetBasePaths() []string <span class="cov1" title="2">{
        return s.paths
}</span>

// GetSources tries to open file or directory and execute sink function on it
func (s *FileSystemSourceProvider) GetSources(ctx context.Context,
        extensions model.Extensions, sink Sink, resolverSink ResolverSink) error <span class="cov2" title="7">{
        for _, scanPath := range s.paths </span><span class="cov2" title="7">{
                resolved := false
                fileInfo, err := os.Stat(scanPath)
                if err != nil </span><span class="cov1" title="3">{
                        return errors.Wrap(err, "failed to open path")
                }</span>

                <span class="cov2" title="4">if !fileInfo.IsDir() </span><span class="cov1" title="1">{
                        c, openFileErr := openScanFile(scanPath, extensions)
                        if openFileErr != nil </span><span class="cov0" title="0">{
                                if openFileErr == ErrNotSupportedFile </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">return openFileErr</span>
                        }
                        <span class="cov1" title="1">if sinkErr := sink(ctx, scanPath, c); sinkErr != nil </span><span class="cov0" title="0">{
                                return sinkErr
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }

                <span class="cov1" title="3">err = s.walkDir(ctx, scanPath, resolved, sink, resolverSink, extensions)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to walk directory")
                }</span>
                <span class="cov1" title="3">continue</span>
        }
        <span class="cov2" title="4">return nil</span>
}

func (s *FileSystemSourceProvider) walkDir(ctx context.Context, scanPath string, resolved bool,
        sink Sink, resolverSink ResolverSink, extensions model.Extensions) error <span class="cov1" title="3">{
        return filepath.Walk(scanPath, func(path string, info os.FileInfo, err error) error </span><span class="cov9" title="22091">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov9" title="22091">if shouldSkip, skipFolder := s.checkConditions(info, extensions, path, resolved); shouldSkip </span><span class="cov9" title="21862">{
                        return skipFolder
                }</span>

                // ------------------ Helm resolver --------------------------------
                <span class="cov5" title="229">if info.IsDir() </span><span class="cov1" title="1">{
                        excluded, errRes := resolverSink(ctx, strings.ReplaceAll(path, "\\", "/"))
                        if errRes != nil </span><span class="cov0" title="0">{
                                sentry.CaptureException(errRes)
                                log.Err(errRes).
                                        Msgf("Filesystem files provider couldn't Resolve Directory, file=%s", info.Name())
                                return nil
                        }</span>
                        <span class="cov1" title="1">if errAdd := s.AddExcluded(excluded); errAdd != nil </span><span class="cov0" title="0">{
                                log.Err(errAdd).Msgf("Filesystem files provider couldn't exclude rendered Chart files, Chart=%s", info.Name())
                        }</span>
                        <span class="cov1" title="1">resolved = true
                        return nil</span>
                }
                // -----------------------------------------------------------------

                <span class="cov5" title="228">c, err := os.Open(filepath.Clean(path))
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to open file")
                }</span>
                <span class="cov5" title="228">defer closeFile(c, info)

                err = sink(ctx, strings.ReplaceAll(path, "\\", "/"), c)
                if err != nil </span><span class="cov5" title="114">{
                        sentry.CaptureException(err)
                        log.Err(err).
                                Msgf("Filesystem files provider couldn't parse file, file=%s", info.Name())
                }</span>
                <span class="cov5" title="228">return nil</span>
        })
}

func openScanFile(scanPath string, extensions model.Extensions) (*os.File, error) <span class="cov1" title="1">{
        if !extensions.Include(filepath.Ext(scanPath)) &amp;&amp; !extensions.Include(filepath.Base(scanPath)) </span><span class="cov0" title="0">{
                return nil, ErrNotSupportedFile
        }</span>

        <span class="cov1" title="1">c, errOpenFile := os.Open(scanPath)
        if errOpenFile != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(errOpenFile, "failed to open path")
        }</span>
        <span class="cov1" title="1">return c, nil</span>
}

func closeFile(file *os.File, info os.FileInfo) <span class="cov5" title="228">{
        if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Err(err).
                        Msgf("Filesystem couldn't close file, file=%s", info.Name())
        }</span>
}

func (s *FileSystemSourceProvider) checkConditions(info os.FileInfo, extensions model.Extensions,
        path string, resolved bool) (bool, error) <span class="cov10" title="22094">{
        if info.IsDir() </span><span class="cov8" title="5066">{
                if f, ok := s.excludes[info.Name()]; ok &amp;&amp; containsFile(f, info) </span><span class="cov1" title="1">{
                        log.Info().Msgf("Directory ignored: %s", path)
                        return true, filepath.SkipDir
                }</span>
                <span class="cov8" title="5065">_, err := os.Stat(filepath.Join(path, "Chart.yaml"))
                if err != nil || resolved </span><span class="cov8" title="5063">{
                        return true, nil
                }</span>
                <span class="cov1" title="2">return false, nil</span>
        }

        <span class="cov9" title="17028">if f, ok := s.excludes[info.Name()]; ok &amp;&amp; containsFile(f, info) </span><span class="cov0" title="0">{
                log.Trace().Msgf("File ignored: %s", path)
                return true, nil
        }</span>
        <span class="cov9" title="17028">if !extensions.Include(filepath.Ext(path)) &amp;&amp; !extensions.Include(filepath.Base(path)) </span><span class="cov9" title="16800">{
                return true, nil
        }</span>
        <span class="cov5" title="228">return false, nil</span>
}

func containsFile(fileList []os.FileInfo, target os.FileInfo) bool <span class="cov1" title="1">{
        for _, file := range fileList </span><span class="cov1" title="1">{
                if os.SameFile(file, target) </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package secrets

import (
        "context"
        _ "embed" // Embed KICS regex rules
        "encoding/json"
        "fmt"
        "math"
        "regexp"
        "strings"
        "time"

        "github.com/Checkmarx/kics/assets"
        "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/detector/docker"
        "github.com/Checkmarx/kics/pkg/detector/helm"
        engine "github.com/Checkmarx/kics/pkg/engine"
        "github.com/Checkmarx/kics/pkg/engine/similarity"
        "github.com/Checkmarx/kics/pkg/engine/source"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

const (
        Base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        HexChars    = "1234567890abcdefABCDEF"
)

var (
        SecretsQueryMetadata map[string]string
)

type Inspector struct {
        ctx                   context.Context
        tracker               engine.Tracker
        detector              *detector.DetectLine
        excludeResults        map[string]bool
        regexQueries          []RegexQuery
        allowRules            []AllowRule
        vulnerabilities       []model.Vulnerability
        queryExecutionTimeout time.Duration
        foundLines            []int
}

type Entropy struct {
        Group int     `json:"group"`
        Min   float64 `json:"min"`
        Max   float64 `json:"max"`
}

type MultilineResult struct {
        DetectLineGroup int `json:"detectLineGroup"`
}

type AllowRule struct {
        Description string `json:"description"`
        RegexStr    string `json:"regex"`
        Regex       *regexp.Regexp
}

type RegexQuery struct {
        ID         string          `json:"id"`
        Name       string          `json:"name"`
        Multiline  MultilineResult `json:"multiline"`
        RegexStr   string          `json:"regex"`
        Entropies  []Entropy       `json:"entropies"`
        AllowRules []AllowRule     `json:"allowRules"`
        Regex      *regexp.Regexp
}

type RegexRuleStruct struct {
        Rules      []RegexQuery `json:"rules"`
        AllowRules []AllowRule  `json:"allowRules"`
}

type RuleMatch struct {
        File     string
        RuleName string
        Matches  []string
        Line     int
        Entropy  float64
}

type lineVulneInfo struct {
        lineContent string
        lineNumber  int
        groups      []string
}

func NewInspector(
        ctx context.Context,
        excludeResults map[string]bool,
        tracker engine.Tracker,
        queryFilter *source.QueryInspectorParameters,
        disableSecretsQuery bool,
        executionTimeout int,
        regexRulesContent string,
) (*Inspector, error) <span class="cov3" title="8">{
        if disableSecretsQuery </span><span class="cov1" title="1">{
                return &amp;Inspector{
                        ctx:                   ctx,
                        tracker:               tracker,
                        excludeResults:        excludeResults,
                        regexQueries:          make([]RegexQuery, 0),
                        allowRules:            make([]AllowRule, 0),
                        vulnerabilities:       make([]model.Vulnerability, 0),
                        queryExecutionTimeout: time.Duration(executionTimeout) * time.Second,
                }, nil
        }</span>

        <span class="cov2" title="7">lineDetector := detector.NewDetectLine(tracker.GetOutputLines()).
                Add(helm.DetectKindLine{}, model.KindHELM).
                Add(docker.DetectKindLine{}, model.KindDOCKER)

        err := json.Unmarshal([]byte(assets.SecretsQueryMetadataJSON), &amp;SecretsQueryMetadata)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov2" title="6">queryExecutionTimeout := time.Duration(executionTimeout) * time.Second

        var allRegexQueries RegexRuleStruct
        err = json.Unmarshal([]byte(regexRulesContent), &amp;allRegexQueries)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="5">return &amp;Inspector{
                ctx:                   ctx,
                detector:              lineDetector,
                excludeResults:        excludeResults,
                tracker:               tracker,
                regexQueries:          compileRegexQueries(queryFilter, allRegexQueries.Rules),
                allowRules:            compileRegex(allRegexQueries.AllowRules),
                vulnerabilities:       make([]model.Vulnerability, 0),
                queryExecutionTimeout: queryExecutionTimeout,
                foundLines:            make([]int, 0),
        }, nil</span>
}

func (c *Inspector) Inspect(ctx context.Context, basePaths []string,
        files model.FileMetadatas, currentQuery chan&lt;- int64) ([]model.Vulnerability, error) <span class="cov2" title="3">{
        for i := range c.regexQueries </span><span class="cov5" title="93">{
                currentQuery &lt;- 1

                timeoutCtx, cancel := context.WithTimeout(ctx, c.queryExecutionTimeout*time.Second)
                defer cancel()
                for idx := range files </span><span class="cov5" title="93">{
                        select </span>{
                        case &lt;-timeoutCtx.Done():<span class="cov0" title="0">
                                return c.vulnerabilities, timeoutCtx.Err()</span>
                        default:<span class="cov5" title="93">
                                // check file content line by line
                                if c.regexQueries[i].Multiline == (MultilineResult{}) </span><span class="cov5" title="84">{
                                        lines := c.detector.SplitLines(&amp;files[idx])

                                        for lineNumber, currentLine := range lines </span><span class="cov8" title="1092">{
                                                c.checkLineByLine(&amp;c.regexQueries[i], basePaths, &amp;files[idx], lineNumber, currentLine)
                                        }</span>
                                        <span class="cov5" title="84">continue</span>
                                }

                                // check file content as a whole
                                <span class="cov3" title="9">c.checkFileContent(&amp;c.regexQueries[i], basePaths, &amp;files[idx])</span>
                        }
                }
        }
        <span class="cov2" title="3">return c.vulnerabilities, nil</span>
}

func compileRegexQueries(queryFilter *source.QueryInspectorParameters, allRegexQueries []RegexQuery) []RegexQuery <span class="cov3" title="10">{
        var regexQueries []RegexQuery

        for i := range allRegexQueries </span><span class="cov5" title="105">{
                if len(queryFilter.IncludeQueries.ByIDs) &gt; 0 </span><span class="cov2" title="3">{
                        if isValueInArray(allRegexQueries[i].ID, queryFilter.IncludeQueries.ByIDs) </span><span class="cov1" title="1">{
                                regexQueries = append(regexQueries, allRegexQueries[i])
                        }</span>
                } else<span class="cov5" title="102"> {
                        if isValueInArray(allRegexQueries[i].ID, queryFilter.ExcludeQueries.ByIDs) </span><span class="cov1" title="1">{
                                log.Debug().
                                        Msgf("Excluding query ID: %s category: %s severity: %s",
                                                allRegexQueries[i].ID,
                                                SecretsQueryMetadata["category"],
                                                SecretsQueryMetadata["severity"])
                                continue</span>
                        }
                        <span class="cov5" title="101">regexQueries = append(regexQueries, allRegexQueries[i])</span>
                }
        }
        <span class="cov3" title="10">for i := range regexQueries </span><span class="cov5" title="102">{
                regexQueries[i].Regex = regexp.MustCompile(regexQueries[i].RegexStr)
                for j := range regexQueries[i].AllowRules </span><span class="cov4" title="39">{
                        regexQueries[i].AllowRules[j].Regex = regexp.MustCompile(regexQueries[i].AllowRules[j].RegexStr)
                }</span>
        }
        <span class="cov3" title="10">return regexQueries</span>
}

func compileRegex(allowRules []AllowRule) []AllowRule <span class="cov2" title="5">{
        for j := range allowRules </span><span class="cov3" title="18">{
                allowRules[j].Regex = regexp.MustCompile(allowRules[j].RegexStr)
        }</span>
        <span class="cov2" title="5">return allowRules</span>
}

func (c *Inspector) GetQueriesLength() int <span class="cov2" title="3">{
        return len(c.regexQueries)
}</span>

func isValueInArray(value string, array []string) bool <span class="cov5" title="105">{
        for i := range array </span><span class="cov2" title="6">{
                if value == array[i] </span><span class="cov1" title="2">{
                        return true
                }</span>
        }
        <span class="cov5" title="103">return false</span>
}

func (c *Inspector) isSecret(s string, query *RegexQuery) (isSecretRet bool, groups [][]string) <span class="cov8" title="1101">{
        if isAllowRule(s, query.AllowRules) || isAllowRule(s, c.allowRules) </span><span class="cov4" title="31">{
                return false, [][]string{}
        }</span>

        <span class="cov8" title="1070">groups = query.Regex.FindAllStringSubmatch(s, -1)

        for _, group := range groups </span><span class="cov1" title="2">{
                splitedText := strings.Split(s, "\n")
                max := -1
                for i, splited := range splitedText </span><span class="cov3" title="17">{
                        if len(groups) &lt; query.Multiline.DetectLineGroup </span><span class="cov3" title="16">{
                                if strings.Contains(splited, group[query.Multiline.DetectLineGroup]) &amp;&amp; i &gt; max </span><span class="cov0" title="0">{
                                        max = i
                                }</span>
                        }
                }
                <span class="cov1" title="2">if max == -1 </span><span class="cov1" title="2">{
                        continue</span>
                }
                <span class="cov0" title="0">secret, newGroups := c.isSecret(strings.Join(append(splitedText[:max], splitedText[max+1:]...), "\n"), query)
                if !secret </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">groups = append(groups, newGroups...)</span>
        }

        <span class="cov8" title="1070">if len(groups) &gt; 0 </span><span class="cov1" title="2">{
                return true, groups
        }</span>
        <span class="cov8" title="1068">return false, [][]string{}</span>
}

func isAllowRule(s string, allowRules []AllowRule) bool <span class="cov8" title="2202">{
        for i := range allowRules </span><span class="cov10" title="7082">{
                if allowRules[i].Regex.MatchString(s) </span><span class="cov4" title="31">{
                        return true
                }</span>
        }
        <span class="cov8" title="2171">return false</span>
}

func (c *Inspector) checkFileContent(query *RegexQuery, basePaths []string, file *model.FileMetadata) <span class="cov3" title="9">{
        isSecret, groups := c.isSecret(file.OriginalData, query)
        if !isSecret </span><span class="cov3" title="8">{
                return
        }</span>

        <span class="cov1" title="1">lineVulns := c.secretsDetectLine(query, file, groups)

        for _, lineVuln := range lineVulns </span><span class="cov1" title="1">{
                if len(query.Entropies) == 0 </span><span class="cov0" title="0">{
                        c.addVulnerability(
                                basePaths,
                                file,
                                query,
                                lineVuln.lineNumber,
                                lineVuln.lineContent,
                        )
                }</span>

                <span class="cov1" title="1">if len(lineVuln.groups) &gt; 0 </span><span class="cov1" title="1">{
                        for _, entropy := range query.Entropies </span><span class="cov1" title="1">{
                                // if matched group does not exist continue
                                if len(lineVuln.groups) &lt;= entropy.Group </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov1" title="1">isMatch, entropyFloat := CheckEntropyInterval(
                                        entropy,
                                        lineVuln.groups[entropy.Group],
                                )
                                log.Debug().Msgf("match: %v :: %v", isMatch, fmt.Sprint(entropyFloat))

                                if isMatch </span><span class="cov1" title="1">{
                                        c.addVulnerability(
                                                basePaths,
                                                file,
                                                query,
                                                lineVuln.lineNumber,
                                                lineVuln.lineContent,
                                        )
                                }</span>
                        }
                }
        }
}

func (c *Inspector) secretsDetectLine(query *RegexQuery, file *model.FileMetadata, vulnGroups [][]string) []lineVulneInfo <span class="cov1" title="1">{
        content := file.OriginalData
        lines := c.detector.SplitLines(file)
        lineVulneInfoSlice := make([]lineVulneInfo, 0)
        realLineUpdater := 0
        for _, groups := range vulnGroups </span><span class="cov1" title="1">{
                lineVulneInfoObject := lineVulneInfo{
                        lineNumber:  -1,
                        lineContent: "-",
                        groups:      groups,
                }

                if len(groups) &lt;= query.Multiline.DetectLineGroup </span><span class="cov0" title="0">{
                        log.Warn().Msgf("Unable to detect line in file %v Multiline group not found: %v", file.FilePath, query.Multiline.DetectLineGroup)
                        lineVulneInfoSlice = append(lineVulneInfoSlice, lineVulneInfoObject)
                        continue</span>
                }

                <span class="cov1" title="1">contentMatchRemoved := strings.Replace(content, groups[query.Multiline.DetectLineGroup], "", 1)

                text := strings.ReplaceAll(contentMatchRemoved, "\r", "")
                contentMatchRemovedLines := strings.Split(text, "\n")
                for i := 0; i &lt; len(lines); i++ </span><span class="cov2" title="7">{
                        if lines[i] != contentMatchRemovedLines[i] </span><span class="cov1" title="1">{
                                lineVulneInfoObject.lineNumber = i + realLineUpdater
                                lineVulneInfoObject.lineContent = lines[i]
                                break</span>
                        }
                }

                <span class="cov1" title="1">realLineUpdater += len(lines) - len(contentMatchRemovedLines)
                content = contentMatchRemoved
                lines = contentMatchRemovedLines

                lineVulneInfoSlice = append(lineVulneInfoSlice, lineVulneInfoObject)</span>
        }

        <span class="cov1" title="1">return lineVulneInfoSlice</span>
}

func (c *Inspector) checkLineByLine(query *RegexQuery, basePaths []string, file *model.FileMetadata, lineNumber int, currentLine string) <span class="cov8" title="1092">{
        isSecret, groups := c.isSecret(currentLine, query)
        if !isSecret </span><span class="cov8" title="1091">{
                return
        }</span>

        <span class="cov1" title="1">if len(query.Entropies) == 0 </span><span class="cov1" title="1">{
                c.addVulnerability(
                        basePaths,
                        file,
                        query,
                        lineNumber,
                        currentLine,
                )
        }</span>

        <span class="cov1" title="1">for i := range query.Entropies </span><span class="cov0" title="0">{
                entropy := query.Entropies[i]

                // if matched group does not exist continue
                if len(groups[0]) &lt;= entropy.Group </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">isMatch, entropyFloat := CheckEntropyInterval(
                        entropy,
                        groups[0][entropy.Group],
                )
                log.Debug().Msgf("match: %v :: %v", isMatch, fmt.Sprint(entropyFloat))

                if isMatch </span><span class="cov0" title="0">{
                        c.addVulnerability(
                                basePaths,
                                file,
                                query,
                                lineNumber,
                                currentLine,
                        )
                }</span>
        }
}

func (c *Inspector) addVulnerability(basePaths []string, file *model.FileMetadata, query *RegexQuery, lineNumber int, issueLine string) <span class="cov1" title="2">{
        simID, err := similarity.ComputeSimilarityID(
                basePaths,
                file.FilePath,
                query.ID,
                fmt.Sprintf("%d", lineNumber),
                "",
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msg("unable to compute similarity ID")
        }</span>

        <span class="cov1" title="2">if _, ok := c.excludeResults[engine.PtrStringToString(simID)]; !ok </span><span class="cov1" title="2">{
                linesVuln := c.detector.GetAdjecent(file, lineNumber+1)
                vuln := model.Vulnerability{
                        QueryID:          query.ID,
                        QueryName:        SecretsQueryMetadata["queryName"] + " - " + query.Name,
                        SimilarityID:     engine.PtrStringToString(simID),
                        FileID:           file.ID,
                        FileName:         file.FilePath,
                        Line:             linesVuln.Line,
                        VulnLines:        linesVuln.VulnLines,
                        IssueType:        "RedundantAttribute",
                        Platform:         SecretsQueryMetadata["platform"],
                        Severity:         model.SeverityHigh,
                        QueryURI:         SecretsQueryMetadata["descriptionUrl"],
                        Category:         SecretsQueryMetadata["category"],
                        Description:      SecretsQueryMetadata["descriptionText"],
                        DescriptionID:    SecretsQueryMetadata["descriptionID"],
                        KeyExpectedValue: "Hardcoded secret key should not appear in source",
                        KeyActualValue:   fmt.Sprintf("'%s' contains a secret", issueLine),
                }
                c.vulnerabilities = append(c.vulnerabilities, vuln)
        }</span>
}

// CheckEntropyInterval - verifies if a given token's entropy is within expected bounds
func CheckEntropyInterval(entropy Entropy, token string) (isEntropyInInterval bool, entropyLevel float64) <span class="cov2" title="7">{
        base64Entropy := calculateEntropy(token, Base64Chars)
        hexEntropy := calculateEntropy(token, HexChars)
        highestEntropy := math.Max(base64Entropy, hexEntropy)
        if insideInterval(entropy, base64Entropy) || insideInterval(entropy, hexEntropy) </span><span class="cov2" title="4">{
                return true, highestEntropy
        }</span>
        <span class="cov2" title="3">return false, highestEntropy</span>
}

func insideInterval(entropy Entropy, floatEntropy float64) bool <span class="cov3" title="11">{
        return floatEntropy &gt;= entropy.Min &amp;&amp; floatEntropy &lt;= entropy.Max
}</span>

// calculateEntropy - calculates the entropy of a string based on the Shannon formula
func calculateEntropy(token, charSet string) float64 <span class="cov3" title="14">{
        if token == "" </span><span class="cov2" title="4">{
                return 0
        }</span>
        <span class="cov3" title="10">charMap := map[rune]float64{}
        for _, char := range token </span><span class="cov8" title="1154">{
                if strings.Contains(charSet, string(char)) </span><span class="cov7" title="856">{
                        charMap[char]++
                }</span>
        }

        <span class="cov3" title="10">var freq float64
        length := float64(len(token))
        for _, count := range charMap </span><span class="cov6" title="153">{
                freq += count * math.Log2(count)
        }</span>

        <span class="cov3" title="10">return math.Log2(length) - freq/length</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package similarity

import (
        "crypto/sha256"
        "encoding/hex"
        "path/filepath"
        "strings"

        "github.com/rs/zerolog/log"
)

// ComputeSimilarityID This function receives four string parameters and computes a sha256 hash
func ComputeSimilarityID(basePaths []string, filePath, queryID, searchKey, searchValue string) (*string, error) <span class="cov9" title="18">{
        basePath := ""
        for _, path := range basePaths </span><span class="cov9" title="18">{
                if strings.Contains(filepath.ToSlash(filePath), filepath.ToSlash(path)) </span><span class="cov8" title="14">{
                        basePath = filepath.ToSlash(path)
                        break</span>
                }
        }
        <span class="cov9" title="18">standardizedPath, err := standardizeToRelativePath(basePath, filePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("Error while standardizing path: %s", err)
        }</span>

        <span class="cov9" title="18">var stringNode = standardizedPath + queryID + searchKey + searchValue

        hashSum := sha256.Sum256([]byte(stringNode))

        similarity := hex.EncodeToString(hashSum[:])
        return &amp;similarity, nil</span>
}

func standardizeToRelativePath(basePath, path string) (string, error) <span class="cov10" title="22">{
        cleanPath := filepath.Clean(path)
        standardPath := filepath.ToSlash(cleanPath)
        basePath = filepath.ToSlash(basePath)
        relativeStandardPath, err := filepath.Rel(basePath, standardPath)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov9" title="21">return filepath.ToSlash(relativeStandardPath), nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package source

import (
        "encoding/json"
        "os"
        "path"
        "path/filepath"
        "sort"
        "strings"

        "github.com/Checkmarx/kics/assets"
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/getsentry/sentry-go"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// FilesystemSource this type defines a struct with a path to a filesystem source of queries
// Source is the path to the queries
// Types are the types given by the flag --type for query selection mechanism
type FilesystemSource struct {
        Source         string
        Types          []string
        CloudProviders []string
        Library        string
}

const (
        // QueryFileName The default query file name
        QueryFileName = "query.rego"
        // MetadataFileName The default metadata file name
        MetadataFileName = "metadata.json"
        // LibrariesDefaultBasePath the path to rego libraries
        LibrariesDefaultBasePath = "./assets/libraries"

        emptyInputData = "{}"

        common = "Common"

        kicsDefault = "default"
)

// NewFilesystemSource initializes a NewFilesystemSource with source to queries and types of queries to load
func NewFilesystemSource(source string, types, cloudProviders []string, libraryPath string) *FilesystemSource <span class="cov7" title="17">{
        log.Debug().Msg("source.NewFilesystemSource()")

        if len(types) == 0 </span><span class="cov0" title="0">{
                types = []string{""}
        }</span>

        <span class="cov7" title="17">if len(cloudProviders) == 0 </span><span class="cov0" title="0">{
                cloudProviders = []string{""}
        }</span>

        <span class="cov7" title="17">return &amp;FilesystemSource{
                Source:         filepath.FromSlash(source),
                Types:          types,
                CloudProviders: cloudProviders,
                Library:        filepath.FromSlash(libraryPath),
        }</span>
}

// ListSupportedPlatforms returns a list of supported platforms
func ListSupportedPlatforms() []string <span class="cov1" title="1">{
        keys := make([]string, len(constants.AvailablePlatforms))
        i := 0
        for k := range constants.AvailablePlatforms </span><span class="cov5" title="7">{
                keys[i] = k
                i++
        }</span>
        <span class="cov1" title="1">sort.Strings(keys)
        return keys</span>
}

// ListSupportedCloudProviders returns a list of supported cloud providers
func ListSupportedCloudProviders() []string <span class="cov0" title="0">{
        return []string{"aws", "azure", "gcp"}
}</span>

func getLibraryInDir(platform, libraryDirPath string) string <span class="cov0" title="0">{
        var libraryFilePath string
        err := filepath.Walk(libraryDirPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if strings.EqualFold(filepath.Base(path), platform+".rego") </span><span class="cov0" title="0">{ // try to find the library file &lt;platform&gt;.rego
                        libraryFilePath = path
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Failed to analize path %s: %s", libraryDirPath, err)
        }</span>
        <span class="cov0" title="0">return libraryFilePath</span>
}

func isDefaultLibrary(libraryPath string) bool <span class="cov5" title="7">{
        return filepath.FromSlash(libraryPath) == filepath.FromSlash(LibrariesDefaultBasePath)
}</span>

// GetPathToCustomLibrary - returns the libraries path for a given platform
func GetPathToCustomLibrary(platform, libraryPathFlag string) string <span class="cov5" title="7">{
        libraryFilePath := kicsDefault

        if !isDefaultLibrary(libraryPathFlag) </span><span class="cov0" title="0">{
                log.Debug().Msgf("Trying to load custom libraries from %s", libraryPathFlag)

                library := getLibraryInDir(platform, libraryPathFlag)
                // found a library named according to the platform
                if library != "" </span><span class="cov0" title="0">{
                        libraryFilePath = library
                }</span>
        }

        <span class="cov5" title="7">return libraryFilePath</span>
}

// GetQueryLibrary returns the library.rego for the platform passed in the argument
func (s *FilesystemSource) GetQueryLibrary(platform string) (RegoLibraries, error) <span class="cov5" title="7">{
        library := GetPathToCustomLibrary(platform, s.Library)
        customLibraryCode := ""
        customLibraryData := emptyInputData

        if library == "" </span><span class="cov0" title="0">{
                return RegoLibraries{}, errors.New("unable to get libraries path")
        }</span>

        <span class="cov5" title="7">if library != kicsDefault </span><span class="cov0" title="0">{
                byteContent, err := os.ReadFile(library)
                if err != nil </span><span class="cov0" title="0">{
                        return RegoLibraries{}, err
                }</span>
                <span class="cov0" title="0">customLibraryCode = string(byteContent)
                customLibraryData, err = readInputData(strings.TrimSuffix(library, filepath.Ext(library)) + ".json")
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug().Msg(err.Error())
                }</span>
        } else<span class="cov5" title="7"> {
                log.Debug().Msgf("Custom library not provided. Loading embedded library instead")
        }</span>
        // getting embedded library
        <span class="cov5" title="7">embeddedLibraryCode, errGettingEmbeddedLibrary := assets.GetEmbeddedLibrary(strings.ToLower(platform))
        if errGettingEmbeddedLibrary != nil </span><span class="cov1" title="1">{
                return RegoLibraries{}, errGettingEmbeddedLibrary
        }</span>

        <span class="cov5" title="6">mergedLibraryCode, errMergeLibs := mergeLibraries(customLibraryCode, embeddedLibraryCode)
        if errMergeLibs != nil </span><span class="cov0" title="0">{
                return RegoLibraries{}, errMergeLibs
        }</span>

        <span class="cov5" title="6">embeddedLibraryData, errGettingEmbeddedLibraryCode := assets.GetEmbeddedLibraryData(strings.ToLower(platform))
        if errGettingEmbeddedLibraryCode != nil </span><span class="cov4" title="5">{
                log.Debug().Msgf("Could not open embedded library data for %s platform", platform)
                embeddedLibraryData = emptyInputData
        }</span>
        <span class="cov5" title="6">mergedLibraryData, errMergingLibraryData := MergeInputData(embeddedLibraryData, customLibraryData)
        if errMergingLibraryData != nil </span><span class="cov0" title="0">{
                log.Debug().Msgf("Could not merge library data for %s platform", platform)
        }</span>

        <span class="cov5" title="6">regoLibrary := RegoLibraries{
                LibraryCode:      mergedLibraryCode,
                LibraryInputData: mergedLibraryData,
        }
        return regoLibrary, nil</span>
}

// CheckType checks if the queries have the type passed as an argument in '--type' flag to be loaded
func (s *FilesystemSource) CheckType(queryPlatform interface{}) bool <span class="cov5" title="7">{
        if queryPlatform.(string) == common </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov5" title="7">if s.Types[0] != "" </span><span class="cov0" title="0">{
                return strings.Contains(strings.ToUpper(strings.Join(s.Types, ",")), strings.ToUpper(queryPlatform.(string)))
        }</span>
        <span class="cov5" title="7">return true</span>
}

// CheckCloudProvider checks if the queries have the cloud provider passed as an argument in '--cloud-provider' flag to be loaded
func (s *FilesystemSource) CheckCloudProvider(cloudProvider interface{}) bool <span class="cov5" title="7">{
        if cloudProvider != nil </span><span class="cov0" title="0">{
                if strings.EqualFold(cloudProvider.(string), common) </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if s.CloudProviders[0] != "" </span><span class="cov0" title="0">{
                        return strings.Contains(strings.ToUpper(strings.Join(s.CloudProviders, ",")), strings.ToUpper(cloudProvider.(string)))
                }</span>
        }

        <span class="cov5" title="7">if s.CloudProviders[0] == "" </span><span class="cov5" title="7">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func checkQueryInclude(id interface{}, includedQueries []string) bool <span class="cov2" title="2">{
        queryMetadataKey, ok := id.(string)
        if !ok </span><span class="cov0" title="0">{
                log.Warn().
                        Msgf("Can't cast query metadata key = %v", id)
                return false
        }</span>
        <span class="cov2" title="2">for _, includedQuery := range includedQueries </span><span class="cov2" title="2">{
                if queryMetadataKey == includedQuery </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

func checkQueryExcludeField(id interface{}, excludeQueries []string) bool <span class="cov6" title="12">{
        queryMetadataKey, ok := id.(string)
        if !ok </span><span class="cov0" title="0">{
                log.Warn().
                        Msgf("Can't cast query metadata key = %v", id)
                return false
        }</span>
        <span class="cov6" title="12">for _, excludedQuery := range excludeQueries </span><span class="cov4" title="4">{
                if strings.EqualFold(queryMetadataKey, excludedQuery) </span><span class="cov3" title="3">{
                        return true
                }</span>
        }
        <span class="cov6" title="9">return false</span>
}

func checkQueryExclude(metadata map[string]interface{}, queryParameters *QueryInspectorParameters) bool <span class="cov4" title="5">{
        return checkQueryExcludeField(metadata["id"], queryParameters.ExcludeQueries.ByIDs) ||
                checkQueryExcludeField(metadata["category"], queryParameters.ExcludeQueries.ByCategories) ||
                checkQueryExcludeField(metadata["severity"], queryParameters.ExcludeQueries.BySeverities)
}</span>

// GetQueries walks a given filesource path returns all queries found in an array of
// QueryMetadata struct
func (s *FilesystemSource) GetQueries(queryParameters *QueryInspectorParameters) ([]model.QueryMetadata, error) <span class="cov6" title="10">{
        queryDirs := make([]string, 0)
        err := filepath.Walk(s.Source,
                func(p string, f os.FileInfo, err error) error </span><span class="cov10" title="52">{
                        if err != nil </span><span class="cov3" title="3">{
                                return err
                        }</span>

                        <span class="cov9" title="49">if f.IsDir() || f.Name() != QueryFileName </span><span class="cov9" title="42">{
                                return nil
                        }</span>

                        <span class="cov5" title="7">queryDirs = append(queryDirs, filepath.Dir(p))
                        return nil</span>
                })
        <span class="cov6" title="10">if err != nil </span><span class="cov3" title="3">{
                return nil, errors.Wrap(err, "failed to get query Source")
        }</span>

        <span class="cov5" title="7">queries := make([]model.QueryMetadata, 0, len(queryDirs))
        for _, queryDir := range queryDirs </span><span class="cov5" title="7">{
                query, errRQ := ReadQuery(queryDir)
                if errRQ != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(errRQ)
                        log.Err(errRQ).
                                Msgf("Query provider failed to read query, query=%s", path.Base(queryDir))
                        continue</span>
                }

                <span class="cov5" title="7">if !s.CheckType(query.Metadata["platform"]) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov5" title="7">if !s.CheckCloudProvider(query.Metadata["cloudProvider"]) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov5" title="7">customInputData, readInputErr := readInputData(filepath.Join(queryParameters.InputDataPath, query.Metadata["id"].(string)+".json"))
                if readInputErr != nil </span><span class="cov0" title="0">{
                        log.Err(errRQ).
                                Msgf("failed to read input data, query=%s", path.Base(queryDir))
                        continue</span>
                }

                <span class="cov5" title="7">inputData, mergeError := MergeInputData(query.InputData, customInputData)
                if mergeError != nil </span><span class="cov0" title="0">{
                        log.Err(mergeError).
                                Msgf("failed to merge input data, query=%s", path.Base(queryDir))
                        continue</span>
                }
                <span class="cov5" title="7">query.InputData = inputData

                if len(queryParameters.IncludeQueries.ByIDs) &gt; 0 </span><span class="cov2" title="2">{
                        if checkQueryInclude(query.Metadata["id"], queryParameters.IncludeQueries.ByIDs) </span><span class="cov1" title="1">{
                                queries = append(queries, query)
                        }</span>
                } else<span class="cov4" title="5"> {
                        if checkQueryExclude(query.Metadata, queryParameters) </span><span class="cov3" title="3">{
                                log.Debug().
                                        Msgf("Excluding query ID: %s category: %s severity: %s", query.Metadata["id"], query.Metadata["category"], query.Metadata["severity"])
                                continue</span>
                        }

                        <span class="cov2" title="2">queries = append(queries, query)</span>
                }
        }

        <span class="cov5" title="7">return queries, err</span>
}

// ReadQuery reads query's files for a given path and returns a QueryMetadata struct with it's
// content
func ReadQuery(queryDir string) (model.QueryMetadata, error) <span class="cov5" title="7">{
        queryContent, err := os.ReadFile(filepath.Clean(path.Join(queryDir, QueryFileName)))
        if err != nil </span><span class="cov0" title="0">{
                return model.QueryMetadata{}, errors.Wrapf(err, "failed to read query %s", path.Base(queryDir))
        }</span>

        <span class="cov5" title="7">metadata := ReadMetadata(queryDir)

        platform := getPlatform(metadata["platform"].(string))

        inputData, errInputData := readInputData(filepath.Join(queryDir, "data.json"))
        if errInputData != nil </span><span class="cov0" title="0">{
                log.Err(errInputData).
                        Msgf("Query provider failed to read input data, query=%s", path.Base(queryDir))
        }</span>

        <span class="cov5" title="7">aggregation := 1
        if agg, ok := metadata["aggregation"]; ok </span><span class="cov0" title="0">{
                aggregation = int(agg.(float64))
        }</span>

        <span class="cov5" title="7">return model.QueryMetadata{
                Query:       path.Base(filepath.ToSlash(queryDir)),
                Content:     string(queryContent),
                Metadata:    metadata,
                Platform:    platform,
                InputData:   inputData,
                Aggregation: aggregation,
        }, nil</span>
}

// ReadMetadata read query's metadata file inside the query directory
func ReadMetadata(queryDir string) map[string]interface{} <span class="cov6" title="9">{
        f, err := os.Open(filepath.Clean(path.Join(queryDir, MetadataFileName)))
        if err != nil </span><span class="cov1" title="1">{
                sentry.CaptureException(err)
                if os.IsNotExist(err) </span><span class="cov1" title="1">{
                        log.Warn().
                                Msgf("Queries provider can't find metadata, query=%s", path.Base(queryDir))

                        return nil
                }</span>

                <span class="cov0" title="0">log.Err(err).
                        Msgf("Queries provider can't read metadata, query=%s", path.Base(queryDir))

                return nil</span>
        }
        <span class="cov5" title="8">defer func() </span><span class="cov5" title="8">{
                if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Err(err).
                                Msgf("Queries provider can't close file, file=%s", filepath.Clean(path.Join(queryDir, MetadataFileName)))
                }</span>
        }()

        <span class="cov5" title="8">var metadata map[string]interface{}
        if err := json.NewDecoder(f).Decode(&amp;metadata); err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Err(err).
                        Msgf("Queries provider can't unmarshal metadata, query=%s", path.Base(queryDir))

                return nil
        }</span>

        <span class="cov5" title="8">return metadata</span>
}

func getPlatform(metadataPlatform string) string <span class="cov7" title="14">{
        switch metadataPlatform </span>{
        case "Ansible":<span class="cov1" title="1">
                return "ansible"</span>
        case "CloudFormation":<span class="cov5" title="8">
                return "cloudFormation"</span>
        case "Common":<span class="cov1" title="1">
                return "common"</span>
        case "Dockerfile":<span class="cov1" title="1">
                return "dockerfile"</span>
        case "Kubernetes":<span class="cov1" title="1">
                return "k8s"</span>
        case "OpenAPI":<span class="cov1" title="1">
                return "openAPI"</span>
        case "Terraform":<span class="cov1" title="1">
                return "terraform"</span>
        case "AzureResourceManager":<span class="cov0" title="0">
                return "azureResourceManager"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

func readInputData(inputDataPath string) (string, error) <span class="cov7" title="15">{
        inputData, err := os.ReadFile(filepath.Clean(inputDataPath))
        if err != nil </span><span class="cov7" title="14">{
                if os.IsNotExist(err) </span><span class="cov7" title="14">{
                        return emptyInputData, nil
                }</span>
                <span class="cov0" title="0">return emptyInputData, errors.Wrapf(err, "failed to read query input data %s", path.Base(inputDataPath))</span>
        }
        <span class="cov1" title="1">return string(inputData), nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Package source (go:generate go run -mod=mod github.com/golang/mock/mockgen -package mock -source=./$GOFILE -destination=../mock/$GOFILE)
package source

import (
        "encoding/json"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/open-policy-agent/opa/ast"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

// QueryInspectorParameters is a struct that represents the optionn to select queries to be executed
type QueryInspectorParameters struct {
        IncludeQueries IncludeQueries
        ExcludeQueries ExcludeQueries
        InputDataPath  string
}

// ExcludeQueries is a struct that represents the option to exclude queries by ids or by categories
type ExcludeQueries struct {
        ByIDs        []string
        ByCategories []string
        BySeverities []string
}

// IncludeQueries is a struct that represents the option to include queries by ID taking precedence over exclusion
type IncludeQueries struct {
        ByIDs []string
}

// RegoLibraries is a struct that contains the library code and its input data
type RegoLibraries struct {
        LibraryCode      string
        LibraryInputData string
}

// QueriesSource wraps an interface that contains basic methods: GetQueries and GetQueryLibrary
// GetQueries gets all queries from a QueryMetadata list
// GetQueryLibrary gets a library of rego functions given a plataform's name
type QueriesSource interface {
        GetQueries(querySelection *QueryInspectorParameters) ([]model.QueryMetadata, error)
        GetQueryLibrary(platform string) (RegoLibraries, error)
}

// mergeLibraries return custom library and embedded library merged, overwriting embedded library functions, if necessary
func mergeLibraries(customLib, embeddedLib string) (string, error) <span class="cov7" title="12">{
        if customLib == "" </span><span class="cov6" title="7">{
                return embeddedLib, nil
        }</span>
        <span class="cov5" title="5">statements, _, err := ast.NewParser().WithReader(strings.NewReader(customLib)).Parse()
        if err != nil </span><span class="cov1" title="1">{
                log.Err(err).Msg("Could not parse custom library")
                return "", err
        }</span>
        <span class="cov4" title="4">headers := make(map[string]string)
        variables := make(map[string]string)
        for _, st := range statements </span><span class="cov4" title="4">{
                if rule, ok := st.(*ast.Rule); ok </span><span class="cov4" title="4">{
                        headers[string(rule.Head.Name)] = ""
                }</span>
                <span class="cov4" title="4">if regoPackage, ok := st.(ast.Body); ok </span><span class="cov0" title="0">{
                        variableSet := regoPackage.Vars(ast.SafetyCheckVisitorParams)
                        for variable := range variableSet </span><span class="cov0" title="0">{
                                variables[variable.String()] = ""
                        }</span>
                }
        }
        <span class="cov4" title="4">statements, _, err = ast.NewParser().WithReader(strings.NewReader(embeddedLib)).Parse()
        if err != nil </span><span class="cov1" title="1">{
                log.Err(err).Msg("Could not parse default library")
                return "", err
        }</span>
        <span class="cov3" title="3">for _, st := range statements </span><span class="cov4" title="4">{
                if rule, ok := st.(*ast.Rule); ok </span><span class="cov4" title="4">{
                        if _, remove := headers[string(rule.Head.Name)]; remove </span><span class="cov2" title="2">{
                                embeddedLib = strings.Replace(embeddedLib, string(rule.Location.Text), "", 1)
                        }</span>
                        <span class="cov4" title="4">continue</span>
                }
                <span class="cov0" title="0">if regoPackage, ok := st.(*ast.Package); ok </span><span class="cov0" title="0">{
                        firstHalf := strings.Join(strings.Split(embeddedLib, "\n")[:regoPackage.Location.Row-1], "\n")
                        secondHalf := strings.Join(strings.Split(embeddedLib, "\n")[regoPackage.Location.Row+1:], "\n")
                        embeddedLib = firstHalf + "\n" + secondHalf
                        continue</span>
                }
                <span class="cov0" title="0">if body, ok := st.(ast.Body); ok </span><span class="cov0" title="0">{
                        variableSet := body.Vars(ast.SafetyCheckVisitorParams)
                        for variable := range variableSet </span><span class="cov0" title="0">{
                                if _, remove := variables[variable.String()]; remove </span><span class="cov0" title="0">{
                                        embeddedLib = strings.Replace(embeddedLib, string(body.Loc().Text), "", 1)
                                        break</span>
                                }
                        }
                }
        }
        <span class="cov3" title="3">customLib += "\n" + embeddedLib

        return customLib, nil</span>
}

// MergeInputData merges KICS input data with custom input data user defined
func MergeInputData(defaultInputData, customInputData string) (string, error) <span class="cov7" title="14">{
        if checkEmptyInputdata(customInputData) &amp;&amp; checkEmptyInputdata(defaultInputData) </span><span class="cov7" title="12">{
                return emptyInputData, nil
        }</span>
        <span class="cov2" title="2">if checkEmptyInputdata(defaultInputData) </span><span class="cov0" title="0">{
                return customInputData, nil
        }</span>
        <span class="cov2" title="2">if checkEmptyInputdata(customInputData) </span><span class="cov1" title="1">{
                return defaultInputData, nil
        }</span>

        <span class="cov1" title="1">dataJSON := map[string]interface{}{}
        customDataJSON := map[string]interface{}{}
        if unmarshalError := json.Unmarshal([]byte(defaultInputData), &amp;dataJSON); unmarshalError != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(unmarshalError, "failed to merge query input data")
        }</span>
        <span class="cov1" title="1">if unmarshalError := json.Unmarshal([]byte(customInputData), &amp;customDataJSON); unmarshalError != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(unmarshalError, "failed to merge query input data")
        }</span>

        <span class="cov1" title="1">for key, value := range customDataJSON </span><span class="cov2" title="2">{
                dataJSON[key] = value
        }</span>
        <span class="cov1" title="1">mergedJSON, mergeErr := json.Marshal(dataJSON)
        if mergeErr != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(mergeErr, "failed to merge query input data")
        }</span>
        <span class="cov1" title="1">return string(mergedJSON), nil</span>
}

func checkEmptyInputdata(inputData string) bool <span class="cov10" title="31">{
        return inputData == emptyInputData || inputData == ""
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package engine

import (
        "encoding/json"
        "strings"

        dec "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/engine/similarity"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

const (
        formatFloat64 = 64
)

// DefaultVulnerabilityBuilder defines a vulnerability builder to execute default actions of scan
var DefaultVulnerabilityBuilder = func(ctx *QueryContext, tracker Tracker,
        v interface{}, detector *dec.DetectLine) (model.Vulnerability, error) <span class="cov10" title="5">{
        vObj, ok := v.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return model.Vulnerability{}, ErrInvalidResult
        }</span>

        <span class="cov10" title="5">vObj = mergeWithMetadata(vObj, ctx.query.metadata.Metadata)

        var err error
        var output []byte

        output, err = json.Marshal(vObj)
        if err != nil </span><span class="cov0" title="0">{
                return model.Vulnerability{}, errors.Wrap(err, "failed to marshall query output")
        }</span>

        <span class="cov10" title="5">var fileID *string

        fileID, err = mapKeyToString(vObj, "documentId", false)
        if err != nil </span><span class="cov0" title="0">{
                return model.Vulnerability{}, errors.Wrap(err, "failed to recognize file id")
        }</span>

        <span class="cov10" title="5">file, ok := ctx.files[*fileID]
        if !ok </span><span class="cov0" title="0">{
                return model.Vulnerability{}, errors.New("failed to find file from query response")
        }</span>

        <span class="cov10" title="5">logWithFields := log.With().
                Str("scanID", ctx.scanID).
                Str("fileName", file.FilePath).
                Str("queryName", ctx.query.metadata.Query).
                Logger()

        detector.SetupLogs(&amp;logWithFields)

        linesVulne := model.VulnerabilityLines{
                Line:      -1,
                VulnLines: []model.CodeLine{},
        }

        similarityIDLineInfo := ""
        searchKey := ""
        if s, ok := vObj["searchKey"]; ok </span><span class="cov10" title="5">{
                searchKey = s.(string)
                similarityIDLineInfo = searchKey
                linesVulne = detector.DetectLine(&amp;file, searchKey)
        }</span> else<span class="cov0" title="0"> {
                logWithFields.Error().Msg("Saving result. failed to detect line")
        }</span>

        <span class="cov10" title="5">searchLineCalc := &amp;searchLineCalculator{
                lineNr:               -1,
                vObj:                 vObj,
                file:                 file,
                detector:             detector,
                similarityIDLineInfo: similarityIDLineInfo,
                linesVulne:           linesVulne,
        }
        // calculate search Line if possible (default uses values of search key)
        searchLineCalc.calculate()
        lineNumber := searchLineCalc.lineNr
        similarityIDLineInfo = searchLineCalc.similarityIDLineInfo
        linesVulne = searchLineCalc.linesVulne

        searchValue := ""
        if s, ok := vObj["searchValue"]; ok </span><span class="cov0" title="0">{
                searchValue = s.(string)
        }</span>

        <span class="cov10" title="5">overrideKey := ""
        if s, ok := vObj["overrideKey"]; ok </span><span class="cov4" title="2">{
                overrideKey = s.(string)
        }</span>

        <span class="cov10" title="5">queryID := getStringFromMap("id", DefaultQueryID, overrideKey, vObj, &amp;logWithFields)

        var severity model.Severity = model.SeverityInfo
        var s *string

        if s, err = mapKeyToString(vObj, "severity", false); err == nil </span><span class="cov7" title="3">{
                sev := getSeverity(strings.ToUpper(*s))
                if sev == "" </span><span class="cov0" title="0">{
                        logWithFields.Warn().Str("severity", *s).Msg("Saving result. invalid severity constant value")
                }</span> else<span class="cov7" title="3"> {
                        severity = sev
                        overrideValue := tryOverride(overrideKey, "severity", vObj)
                        if overrideValue != nil </span><span class="cov1" title="1">{
                                sev = getSeverity(strings.ToUpper(*overrideValue))
                                if sev != "" </span><span class="cov1" title="1">{
                                        severity = sev
                                }</span>
                        }
                }
        } else<span class="cov4" title="2"> {
                logWithFields.Info().Msg("Saving result. failed to detect severity")
        }</span>

        <span class="cov10" title="5">issueType := DefaultIssueType
        if v := mustMapKeyToString(vObj, "issueType"); v != nil </span><span class="cov10" title="5">{
                issueType = model.IssueType(*v)
        }</span>

        <span class="cov10" title="5">var similarityID *string

        similarityID, err = similarity.ComputeSimilarityID(ctx.baseScanPaths, file.FilePath, queryID, similarityIDLineInfo, searchValue)
        if err != nil </span><span class="cov0" title="0">{
                logWithFields.Err(err).Send()
                tracker.FailedComputeSimilarityID()
        }</span>

        <span class="cov10" title="5">return model.Vulnerability{
                ID:               0,
                SimilarityID:     PtrStringToString(similarityID),
                ScanID:           ctx.scanID,
                FileID:           file.ID,
                FileName:         file.FilePath,
                QueryName:        getStringFromMap("queryName", DefaultQueryName, overrideKey, vObj, &amp;logWithFields),
                QueryID:          queryID,
                QueryURI:         getStringFromMap("descriptionUrl", DefaultQueryURI, overrideKey, vObj, &amp;logWithFields),
                Category:         getStringFromMap("category", "", overrideKey, vObj, &amp;logWithFields),
                Description:      getStringFromMap("descriptionText", "", overrideKey, vObj, &amp;logWithFields),
                DescriptionID:    getStringFromMap("descriptionID", DefaultQueryDescriptionID, overrideKey, vObj, &amp;logWithFields),
                Severity:         severity,
                Platform:         getStringFromMap("platform", "", overrideKey, vObj, &amp;logWithFields),
                Line:             linesVulne.Line,
                VulnLines:        linesVulne.VulnLines,
                IssueType:        issueType,
                SearchKey:        searchKey,
                SearchLine:       lineNumber,
                SearchValue:      searchValue,
                KeyExpectedValue: PtrStringToString(mustMapKeyToString(vObj, "keyExpectedValue")),
                KeyActualValue:   PtrStringToString(mustMapKeyToString(vObj, "keyActualValue")),
                Value:            mustMapKeyToString(vObj, "value"),
                Output:           string(output),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package engine

import (
        "encoding/json"
        "fmt"
        "strconv"

        dec "github.com/Checkmarx/kics/pkg/detector"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

type searchLineCalculator struct {
        lineNr               int
        vObj                 map[string]interface{}
        file                 model.FileMetadata
        detector             *dec.DetectLine
        similarityIDLineInfo string
        linesVulne           model.VulnerabilityLines
}

func (s *searchLineCalculator) calculate() <span class="cov5" title="7">{
        if searchLine, ok := s.vObj["searchLine"]; ok </span><span class="cov1" title="1">{
                line := make([]string, 0, len(searchLine.([]interface{})))
                for _, strElement := range searchLine.([]interface{}) </span><span class="cov3" title="3">{
                        line = append(line, strElement.(string))
                }</span>
                <span class="cov1" title="1">var err error
                s.lineNr, err = dec.GetLineBySearchLine(line, &amp;s.file)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to get line information from searchLine, using searchKey")
                }</span>
                <span class="cov1" title="1">if s.lineNr &gt;= 0 </span><span class="cov1" title="1">{
                        s.similarityIDLineInfo = strconv.Itoa(s.lineNr)
                        s.linesVulne = s.detector.GetAdjecent(&amp;s.file, s.lineNr)
                }</span>
        }
}

func mergeWithMetadata(base, additional map[string]interface{}) map[string]interface{} <span class="cov5" title="7">{
        for k, v := range additional </span><span class="cov7" title="19">{
                if _, ok := base[k]; ok </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov6" title="18">base[k] = v</span>
        }

        <span class="cov5" title="7">return base</span>
}

func mustMapKeyToString(m map[string]interface{}, key string) *string <span class="cov7" title="21">{
        res, err := mapKeyToString(m, key, true)
        if err != nil &amp;&amp; key != "value" </span><span class="cov4" title="6">{
                log.Warn().
                        Str("reason", err.Error()).
                        Msgf("Failed to get key %s in map", key)
        }</span>

        <span class="cov7" title="21">return res</span>
}

func mapKeyToString(m map[string]interface{}, key string, allowNil bool) (*string, error) <span class="cov10" title="78">{
        v, ok := m[key]
        if !ok </span><span class="cov9" title="52">{
                return nil, fmt.Errorf("key '%s' not found in map", key)
        }</span>

        <span class="cov7" title="26">switch vv := v.(type) </span>{
        case json.Number:<span class="cov0" title="0">
                return stringToPtrString(vv.String()), nil</span>
        case string:<span class="cov7" title="21">
                return stringToPtrString(vv), nil</span>
        case int, int32, int64:<span class="cov2" title="2">
                return stringToPtrString(fmt.Sprintf("%d", vv)), nil</span>
        case float32:<span class="cov0" title="0">
                return stringToPtrString(strconv.FormatFloat(float64(vv), 'f', -1, formatFloat64)), nil</span>
        case float64:<span class="cov1" title="1">
                return stringToPtrString(strconv.FormatFloat(vv, 'f', -1, formatFloat64)), nil</span>
        case nil:<span class="cov1" title="1">
                if allowNil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov1" title="1">return stringToPtrString("null"), nil</span>
        case bool:<span class="cov1" title="1">
                return stringToPtrString(fmt.Sprintf("%v", vv)), nil</span>
        }

        <span class="cov0" title="0">log.Debug().
                Msg("Detecting line. can't format item to string")

        if allowNil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return stringToPtrString(""), nil</span>
}

func stringToPtrString(v string) *string <span class="cov7" title="26">{
        return &amp;v
}</span>

// PtrStringToString - converts a pointer to string to a string
func PtrStringToString(v *string) string <span class="cov6" title="17">{
        if v == nil </span><span class="cov5" title="7">{
                return ""
        }</span>
        <span class="cov5" title="10">return *v</span>
}

func tryOverride(overrideKey, vulnParam string, vObj map[string]interface{}) *string <span class="cov3" title="4">{
        if overrideKey != "" </span><span class="cov3" title="3">{
                if override, ok := vObj["override"].(map[string]interface{}); ok </span><span class="cov3" title="3">{
                        if overrideObject, ok := override[overrideKey].(map[string]interface{}); ok </span><span class="cov3" title="3">{
                                if _, ok := overrideObject[vulnParam]; ok </span><span class="cov2" title="2">{
                                        overrideValue, err := mapKeyToString(overrideObject, vulnParam, true)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil
                                        }</span> else<span class="cov2" title="2"> if overrideValue != nil </span><span class="cov2" title="2">{
                                                return overrideValue
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov2" title="2">return nil</span>
}

func getStringFromMap(vulnParam, defaultParam, overrideKey string, vObj map[string]interface{}, logWithFields *zerolog.Logger) string <span class="cov8" title="35">{
        ts, err := mapKeyToString(vObj, vulnParam, false)
        if err != nil </span><span class="cov8" title="34">{
                logWithFields.Err(err).
                        Msgf("Saving result. failed to detect %s", vulnParam)
                return defaultParam
        }</span>
        <span class="cov1" title="1">overrideValue := tryOverride(overrideKey, vulnParam, vObj)
        if overrideValue != nil </span><span class="cov1" title="1">{
                ts = overrideValue
        }</span>
        <span class="cov1" title="1">return *ts</span>
}

func getSeverity(severity string) model.Severity <span class="cov3" title="4">{
        for _, si := range model.AllSeverities </span><span class="cov6" title="13">{
                if severity == string(si) </span><span class="cov3" title="4">{
                        return si
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package kics

import (
        "context"
        "encoding/json"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/getsentry/sentry-go"
        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
)

func (s *Service) resolverSink(ctx context.Context, filename, scanID string) ([]string, error) <span class="cov0" title="0">{
        kind := s.Resolver.GetType(filename)
        if kind == model.KindCOMMON </span><span class="cov0" title="0">{
                return []string{}, nil
        }</span>
        <span class="cov0" title="0">resFiles, err := s.Resolver.Resolve(filename, kind)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("failed to render file content")
                return []string{}, nil
        }</span>

        <span class="cov0" title="0">excluded := make([]string, len(resFiles.File))

        for idx, rfile := range resFiles.File </span><span class="cov0" title="0">{
                s.Tracker.TrackFileFound()
                excluded[idx] = rfile.FileName
                documents, retParse, err := s.Parser.Parse(rfile.FileName, rfile.Content)
                if err != nil </span><span class="cov0" title="0">{
                        if retParse == "break" </span><span class="cov0" title="0">{
                                return []string{}, nil
                        }</span>
                        <span class="cov0" title="0">log.Err(err).Msgf("failed to parse file content")
                        return []string{}, nil</span>
                }
                <span class="cov0" title="0">for _, document := range documents </span><span class="cov0" title="0">{
                        _, err = json.Marshal(document)
                        if err != nil </span><span class="cov0" title="0">{
                                sentry.CaptureException(err)
                                log.Err(err).Msgf("failed to marshal content in file: %s", rfile.FileName)
                                continue</span>
                        }

                        <span class="cov0" title="0">file := model.FileMetadata{
                                ID:           uuid.New().String(),
                                ScanID:       scanID,
                                Document:     document,
                                OriginalData: string(rfile.OriginalData),
                                Kind:         kind,
                                FilePath:     rfile.FileName,
                                Content:      string(rfile.Content),
                                HelmID:       rfile.SplitID,
                                IDInfo:       rfile.IDInfo,
                        }
                        s.saveToFile(ctx, &amp;file)</span>
                }
                <span class="cov0" title="0">s.Tracker.TrackFileParse()</span>
        }
        <span class="cov0" title="0">return excluded, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package kics

import (
        "context"
        "io"
        "sync"

        "github.com/Checkmarx/kics/pkg/engine"
        "github.com/Checkmarx/kics/pkg/engine/provider"
        "github.com/Checkmarx/kics/pkg/engine/secrets"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser"
        "github.com/Checkmarx/kics/pkg/resolver"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

const (
        mbConst = 1048576
)

// Storage is the interface that wraps following basic methods: SaveFile, SaveVulnerability, GetVulnerability and GetScanSummary
// SaveFile should append metadata to a file
// SaveVulnerabilities should append vulnerabilities list to current storage
// GetVulnerabilities should returns all vulnerabilities associated to a scan ID
// GetScanSummary should return a list of summaries based on their scan IDs
type Storage interface {
        SaveFile(ctx context.Context, metadata *model.FileMetadata) error
        SaveVulnerabilities(ctx context.Context, vulnerabilities []model.Vulnerability) error
        GetVulnerabilities(ctx context.Context, scanID string) ([]model.Vulnerability, error)
        GetScanSummary(ctx context.Context, scanIDs []string) ([]model.SeveritySummary, error)
}

// Tracker is the interface that wraps the basic methods: TrackFileFound and TrackFileParse
// TrackFileFound should increment the number of files to be scanned
// TrackFileParse should increment the number of files parsed successfully to be scanned
type Tracker interface {
        TrackFileFound()
        TrackFileParse()
}

// Service is a struct that contains a SourceProvider to receive sources, a storage to save and retrieve scanning informations
// a parser to parse and provide files in format that KICS understand, a inspector that runs the scanning and a tracker to
// update scanning numbers
type Service struct {
        SourceProvider   provider.SourceProvider
        Storage          Storage
        Parser           *parser.Parser
        Inspector        *engine.Inspector
        SecretsInspector *secrets.Inspector
        Tracker          Tracker
        Resolver         *resolver.Resolver
        files            model.FileMetadatas
}

func (s *Service) PrepareSources(ctx context.Context, scanID string, wg *sync.WaitGroup, errCh chan&lt;- error) <span class="cov0" title="0">{
        defer wg.Done()
        // CxSAST query under review
        if err := s.SourceProvider.GetSources(
                ctx,
                s.Parser.SupportedExtensions(),
                func(ctx context.Context, filename string, rc io.ReadCloser) error </span><span class="cov0" title="0">{
                        return s.sink(ctx, filename, scanID, rc)
                }</span>,
                func(ctx context.Context, filename string) ([]string, error) <span class="cov0" title="0">{ // Sink used for resolver files and templates
                        return s.resolverSink(ctx, filename, scanID)
                }</span>,
        ); err != nil <span class="cov0" title="0">{
                errCh &lt;- errors.Wrap(err, "failed to read sources")
        }</span>
}

// StartScan executes scan over the context, using the scanID as reference
func (s *Service) StartScan(
        ctx context.Context,
        scanID string,
        errCh chan&lt;- error,
        wg *sync.WaitGroup,
        currentQuery chan&lt;- int64) <span class="cov10" title="4">{
        log.Debug().Msg("service.StartScan()")
        defer wg.Done()

        secretsVulnerabilities, err := s.SecretsInspector.Inspect(
                ctx,
                s.SourceProvider.GetBasePaths(),
                s.files,
                currentQuery,
        )
        if err != nil </span><span class="cov0" title="0">{
                errCh &lt;- errors.Wrap(err, "failed to inspect secrets")
        }</span>

        <span class="cov10" title="4">vulnerabilities, err := s.Inspector.Inspect(
                ctx,
                scanID,
                s.files,
                s.SourceProvider.GetBasePaths(),
                s.Parser.Platform,
                currentQuery,
        )
        if err != nil </span><span class="cov0" title="0">{
                errCh &lt;- errors.Wrap(err, "failed to inspect files")
        }</span>
        <span class="cov10" title="4">vulnerabilities = append(vulnerabilities, secretsVulnerabilities...)

        err = s.Storage.SaveVulnerabilities(ctx, vulnerabilities)
        if err != nil </span><span class="cov0" title="0">{
                errCh &lt;- errors.Wrap(err, "failed to save vulnerabilities")
        }</span>
}

/*
   getContent will read the passed file 1MB at a time
   to prevent resource exhaustion and return its content
*/
func getContent(rc io.Reader) (*[]byte, error) <span class="cov0" title="0">{
        maxSizeMB := 5 // Max size of file in MBs
        var content []byte
        data := make([]byte, mbConst)
        for </span><span class="cov0" title="0">{
                if maxSizeMB &lt; 0 </span><span class="cov0" title="0">{
                        return &amp;[]byte{}, errors.New("file size limit exceeded")
                }</span>
                <span class="cov0" title="0">data = data[:cap(data)]
                n, err := rc.Read(data)
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">return &amp;[]byte{}, err</span>
                }
                <span class="cov0" title="0">content = append(content, data[:n]...)
                maxSizeMB--</span>
        }
        <span class="cov0" title="0">return &amp;content, nil</span>
}

// GetVulnerabilities returns a list of scan detected vulnerabilities
func (s *Service) GetVulnerabilities(ctx context.Context, scanID string) ([]model.Vulnerability, error) <span class="cov10" title="4">{
        return s.Storage.GetVulnerabilities(ctx, scanID)
}</span>

// GetScanSummary returns how many vulnerabilities of each severity was found
func (s *Service) GetScanSummary(ctx context.Context, scanIDs []string) ([]model.SeveritySummary, error) <span class="cov10" title="4">{
        return s.Storage.GetScanSummary(ctx, scanIDs)
}</span>

func (s *Service) saveToFile(ctx context.Context, file *model.FileMetadata) <span class="cov0" title="0">{
        err := s.Storage.SaveFile(ctx, file)
        if err == nil </span><span class="cov0" title="0">{
                s.files = append(s.files, *file)
        }</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package kics

import (
        "context"
        "encoding/json"
        "io"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser/jsonfilter/parser"
        "github.com/antlr/antlr4/runtime/Go/antlr"
        "github.com/getsentry/sentry-go"
        "github.com/google/uuid"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
)

var (
        lines = map[model.FileKind][]string{
                "TF":   {"pattern"},
                "JSON": {"FilterPattern"},
                "YAML": {"filter_pattern", "FilterPattern"},
        }
)

func (s *Service) sink(ctx context.Context, filename, scanID string, rc io.Reader) error <span class="cov0" title="0">{
        s.Tracker.TrackFileFound()

        content, err := getContent(rc)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to get file content: %s", filename)
        }</span>

        <span class="cov0" title="0">documents, kind, err := s.Parser.Parse(filename, *content)
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("failed to parse file content: %s", filename)
                return nil
        }</span>

        <span class="cov0" title="0">fileCommands := s.Parser.CommentsCommands(filename, *content)

        for _, document := range documents </span><span class="cov0" title="0">{
                _, err = json.Marshal(document)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        log.Err(err).Msgf("failed to marshal content in file: %s", filename)
                        continue</span>
                }

                <span class="cov0" title="0">file := model.FileMetadata{
                        ID:               uuid.New().String(),
                        ScanID:           scanID,
                        Document:         PrepareScanDocument(document, kind),
                        LineInfoDocument: document,
                        OriginalData:     string(*content),
                        Kind:             kind,
                        FilePath:         filename,
                        Commands:         fileCommands,
                }
                s.saveToFile(ctx, &amp;file)</span>
        }
        <span class="cov0" title="0">s.Tracker.TrackFileParse()

        return errors.Wrap(err, "failed to save file content")</span>
}

// PrepareScanDocument removes _kics_lines from payload and parses json filters
func PrepareScanDocument(body map[string]interface{}, kind model.FileKind) map[string]interface{} <span class="cov0" title="0">{
        bodyMap := make(map[string]interface{})
        j, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to remove kics line information")
                return body
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal(j, &amp;bodyMap); err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("failed to remove kics line information")
                return body
        }</span>
        <span class="cov0" title="0">prepareScanDocumentRoot(bodyMap, kind)
        return bodyMap</span>
}

func prepareScanDocumentRoot(body interface{}, kind model.FileKind) <span class="cov0" title="0">{
        switch bodyType := body.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                prepareScanDocumentValue(bodyType, kind)</span>
        case []interface{}:<span class="cov0" title="0">
                for _, indx := range bodyType </span><span class="cov0" title="0">{
                        prepareScanDocumentRoot(indx, kind)
                }</span>
        }
}

func prepareScanDocumentValue(bodyType map[string]interface{}, kind model.FileKind) <span class="cov0" title="0">{
        delete(bodyType, "_kics_lines")
        for key, v := range bodyType </span><span class="cov0" title="0">{
                switch value := v.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        prepareScanDocumentRoot(value, kind)</span>
                case []interface{}:<span class="cov0" title="0">
                        for _, indx := range value </span><span class="cov0" title="0">{
                                prepareScanDocumentRoot(indx, kind)
                        }</span>
                case string:<span class="cov0" title="0">
                        if field, ok := lines[kind]; ok &amp;&amp; contains(field, key) </span><span class="cov0" title="0">{
                                bodyType[key] = resolveJSONFilter(value)
                        }</span>
                }
        }
}

func contains(strSlice []string, key string) bool <span class="cov0" title="0">{
        for _, v := range strSlice </span><span class="cov0" title="0">{
                if v == key </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func resolveJSONFilter(jsonFilter string) string <span class="cov0" title="0">{
        is := antlr.NewInputStream(jsonFilter)

        // lexer build
        lexer := parser.NewJSONFilterLexer(is)
        lexer.RemoveErrorListeners()
        stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)
        errorListener := parser.NewCustomErrorListener()
        lexer.RemoveErrorListeners()
        lexer.AddErrorListener(errorListener)

        // parser build
        p := parser.NewJSONFilterParser(stream)
        p.RemoveErrorListeners()
        p.AddErrorListener(errorListener)
        p.BuildParseTrees = true
        tree := p.Awsjsonfilter()

        // parse
        visitor := parser.NewJSONFilterPrinterVisitor()
        if errorListener.HasErrors() </span><span class="cov0" title="0">{
                return jsonFilter
        }</span>

        <span class="cov0" title="0">parsed := visitor.VisitAll(tree)

        parsedByte, err := json.Marshal(parsed)
        if err != nil </span><span class="cov0" title="0">{
                return jsonFilter
        }</span>

        <span class="cov0" title="0">return string(parsedByte)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Package model (go:generate go run -mod=mod github.com/mailru/easyjson/easyjson ./$GOFILE)
package model

import (
        "sort"
        "strings"

        _ "github.com/mailru/easyjson/gen" //nolint
        "github.com/rs/zerolog/log"
)

// Constants to describe what kind of file refers
const (
        KindTerraform FileKind = "TF"
        KindJSON      FileKind = "JSON"
        KindYAML      FileKind = "YAML"
        KindDOCKER    FileKind = "DOCKERFILE"
        KindCOMMON    FileKind = "*"
        KindHELM      FileKind = "HELM"
)

// Constants to describe vulnerability's severity
const (
        SeverityHigh   = "HIGH"
        SeverityMedium = "MEDIUM"
        SeverityLow    = "LOW"
        SeverityInfo   = "INFO"
)

// Constants to describe issue's type
const (
        IssueTypeMissingAttribute   IssueType = "MissingAttribute"
        IssueTypeRedundantAttribute IssueType = "RedundantAttribute"
        IssueTypeIncorrectValue     IssueType = "IncorrectValue"
)

// Arrays to group all constants of one type
var (
        AllSeverities = []Severity{
                SeverityHigh,
                SeverityMedium,
                SeverityLow,
                SeverityInfo,
        }

        AllIssueTypesAsString = []string{
                string(IssueTypeMissingAttribute),
                string(IssueTypeRedundantAttribute),
                string(IssueTypeIncorrectValue),
        }
)

// VulnerabilityLines is the representation of the found line for issue
type VulnerabilityLines struct {
        Line                 int
        VulnLines            []CodeLine
        LineWithVulnerabilty string
}

// FileKind is the extension of a file
type FileKind string

// Severity of the vulnerability
type Severity string

// IssueType is the issue's type string representation
type IssueType string

// CodeLine is the lines containing and adjecent to the vulnerability line with their respective positions
type CodeLine struct {
        Position int
        Line     string
}

// ExtractedPathObject is the struct that contains the path location of extracted source
// and a boolean to check if it is a local source
type ExtractedPathObject struct {
        Path      string
        LocalPath bool
}

// CommentsCommands list of commands on a file that will be parsed
type CommentsCommands map[string]string

// FileMetadata is a representation of basic information and content of a file
type FileMetadata struct {
        ID               string `db:"id"`
        ScanID           string `db:"scan_id"`
        Document         Document
        LineInfoDocument map[string]interface{}
        OriginalData     string   `db:"orig_data"`
        Kind             FileKind `db:"kind"`
        FilePath         string   `db:"file_path"`
        Content          string
        HelmID           string
        IDInfo           map[int]interface{}
        Commands         CommentsCommands
}

// QueryMetadata is a representation of general information about a query
type QueryMetadata struct {
        InputData string
        Query     string
        Content   string
        Metadata  map[string]interface{}
        Platform  string
        // special field for generic queries
        // represents how many queries are aggregated into a single rego file
        Aggregation int
}

// Vulnerability is a representation of a detected vulnerability in scanned files
// after running a query
type Vulnerability struct {
        ID               int        `json:"id"`
        ScanID           string     `db:"scan_id" json:"-"`
        SimilarityID     string     `db:"similarity_id" json:"similarityID"`
        FileID           string     `db:"file_id" json:"-"`
        FileName         string     `db:"file_name" json:"fileName"`
        QueryID          string     `db:"query_id" json:"queryID"`
        QueryName        string     `db:"query_name" json:"queryName"`
        QueryURI         string     `json:"-"`
        Category         string     `json:"category"`
        Description      string     `json:"description"`
        DescriptionID    string     `json:"descriptionID"`
        Platform         string     `db:"platform" json:"platform"`
        Severity         Severity   `json:"severity"`
        Line             int        `json:"line"`
        VulnLines        []CodeLine `json:"vulnLines"`
        IssueType        IssueType  `db:"issue_type" json:"issueType"`
        SearchKey        string     `db:"search_key" json:"searchKey"`
        SearchLine       int        `db:"search_line" json:"searchLine"`
        SearchValue      string     `db:"search_value" json:"searchValue"`
        KeyExpectedValue string     `db:"key_expected_value" json:"expectedValue"`
        KeyActualValue   string     `db:"key_actual_value" json:"actualValue"`
        Value            *string    `db:"value" json:"value"`
        Output           string     `json:"-"`
}

// QueryConfig is a struct that contains the fileKind and platform of the rego query
type QueryConfig struct {
        FileKind []FileKind
        Platform string
}

// ResolvedFiles keeps the information of all file/template resolved
type ResolvedFiles struct {
        File []ResolvedFile
}

// ResolvedFile keeps the information of a file/template resolved
type ResolvedFile struct {
        FileName     string
        Content      []byte
        OriginalData []byte
        SplitID      string
        IDInfo       map[int]interface{}
}

// Extensions represents a list of supported extensions
type Extensions map[string]struct{}

// Include returns true if an extension is included in supported extensions listed
// otherwise returns false
func (e Extensions) Include(ext string) bool <span class="cov1" title="1">{
        _, b := e[ext]

        return b
}</span>

// LineObject is the struct that will hold line information for each key
type LineObject struct {
        Line int                     `json:"_kics_line"`
        Arr  []map[string]LineObject `json:"_kics_arr,omitempty"`
}

// MatchedFilesRegex returns the regex rule to identify if an extension is supported or not
func (e Extensions) MatchedFilesRegex() string <span class="cov10" title="4">{
        if len(e) == 0 </span><span class="cov5" title="2">{
                return "NO_MATCHED_FILES"
        }</span>

        <span class="cov5" title="2">var parts []string
        for ext := range e </span><span class="cov8" title="3">{
                parts = append(parts, "\\"+ext)
        }</span>

        <span class="cov5" title="2">sort.Strings(parts)

        return "(.*)(" + strings.Join(parts, "|") + ")$"</span>
}

// FileMetadatas is a slice of FileMetadata
type FileMetadatas []FileMetadata

// ToMap creates a map of FileMetadatas, which the key is the FileMedata ID and the value is the FileMetadata
func (m FileMetadatas) ToMap() map[string]FileMetadata <span class="cov1" title="1">{
        c := make(map[string]FileMetadata, len(m))
        for i := 0; i &lt; len(m); i++ </span><span class="cov1" title="1">{
                c[m[i].ID] = m[i]
        }</span>
        <span class="cov1" title="1">return c</span>
}

// Documents (easyjson:json)
type Documents struct {
        Documents []Document `json:"document"`
}

// Document (easyjson:json)
type Document map[string]interface{}

// Combine merge documents from FileMetadatas using the ID as reference for Document ID and FileName as reference for file
func (m FileMetadatas) Combine(lineInfo bool) Documents <span class="cov8" title="3">{
        documents := Documents{Documents: make([]Document, 0, len(m))}
        for i := 0; i &lt; len(m); i++ </span><span class="cov8" title="3">{
                _, ignore := m[i].Commands["ignore"]
                if len(m[i].Document) == 0 </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov5" title="2">if ignore </span><span class="cov1" title="1">{
                        log.Debug().Msgf("Ignoring file %s", m[i].FilePath)
                        continue</span>
                }
                <span class="cov1" title="1">if lineInfo </span><span class="cov0" title="0">{
                        m[i].LineInfoDocument["id"] = m[i].ID
                        m[i].LineInfoDocument["file"] = m[i].FilePath
                        documents.Documents = append(documents.Documents, m[i].LineInfoDocument)
                }</span> else<span class="cov1" title="1"> {
                        m[i].Document["id"] = m[i].ID
                        m[i].Document["file"] = m[i].FilePath
                        documents.Documents = append(documents.Documents, m[i].Document)
                }</span>
        }
        <span class="cov8" title="3">return documents</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package model

import (
        json "encoding/json"
        easyjson "github.com/mailru/easyjson"
        jlexer "github.com/mailru/easyjson/jlexer"
        jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
        _ *json.RawMessage
        _ *jlexer.Lexer
        _ *jwriter.Writer
        _ easyjson.Marshaler
)

func easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel(in *jlexer.Lexer, out *Documents) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov0" title="0">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeFieldName(false)
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "document":<span class="cov0" title="0">
                        if in.IsNull() </span><span class="cov0" title="0">{
                                in.Skip()
                                out.Documents = nil
                        }</span> else<span class="cov0" title="0"> {
                                in.Delim('[')
                                if out.Documents == nil </span><span class="cov0" title="0">{
                                        if !in.IsDelim(']') </span><span class="cov0" title="0">{
                                                out.Documents = make([]Document, 0, 8)
                                        }</span> else<span class="cov0" title="0"> {
                                                out.Documents = []Document{}
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        out.Documents = (out.Documents)[:0]
                                }</span>
                                <span class="cov0" title="0">for !in.IsDelim(']') </span><span class="cov0" title="0">{
                                        var v1 Document
                                        (v1).UnmarshalEasyJSON(in)
                                        out.Documents = append(out.Documents, v1)
                                        in.WantComma()
                                }</span>
                                <span class="cov0" title="0">in.Delim(']')</span>
                        }
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov0" title="0">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel(out *jwriter.Writer, in Documents) <span class="cov0" title="0">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov0" title="0">{
                const prefix string = ",\"document\":"
                out.RawString(prefix[1:])
                if in.Documents == nil &amp;&amp; (out.Flags&amp;jwriter.NilSliceAsEmpty) == 0 </span><span class="cov0" title="0">{
                        out.RawString("null")
                }</span> else<span class="cov0" title="0"> {
                        out.RawByte('[')
                        for v2, v3 := range in.Documents </span><span class="cov0" title="0">{
                                if v2 &gt; 0 </span><span class="cov0" title="0">{
                                        out.RawByte(',')
                                }</span>
                                <span class="cov0" title="0">(v3).MarshalEasyJSON(out)</span>
                        }
                        <span class="cov0" title="0">out.RawByte(']')</span>
                }
        }
        <span class="cov0" title="0">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v Documents) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Documents) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Documents) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Documents) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel(l, v)
}</span>
func easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel1(in *jlexer.Lexer, out *Document) <span class="cov6" title="3">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                in.Skip()
        }</span> else<span class="cov6" title="3"> {
                in.Delim('{')
                *out = make(Document)
                for !in.IsDelim('}') </span><span class="cov10" title="7">{
                        key := string(in.String())
                        in.WantColon()
                        var v4 interface{}
                        if m, ok := v4.(easyjson.Unmarshaler); ok </span><span class="cov0" title="0">{
                                m.UnmarshalEasyJSON(in)
                        }</span> else<span class="cov10" title="7"> if m, ok := v4.(json.Unmarshaler); ok </span><span class="cov0" title="0">{
                                _ = m.UnmarshalJSON(in.Raw())
                        }</span> else<span class="cov10" title="7"> {
                                v4 = in.Interface()
                        }</span>
                        <span class="cov10" title="7">(*out)[key] = v4
                        in.WantComma()</span>
                }
                <span class="cov6" title="3">in.Delim('}')</span>
        }
        <span class="cov6" title="3">if isTopLevel </span><span class="cov6" title="3">{
                in.Consumed()
        }</span>
}
func easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel1(out *jwriter.Writer, in Document) <span class="cov6" title="3">{
        if in == nil &amp;&amp; (out.Flags&amp;jwriter.NilMapAsEmpty) == 0 </span><span class="cov0" title="0">{
                out.RawString(`null`)
        }</span> else<span class="cov6" title="3"> {
                out.RawByte('{')
                v5First := true
                for v5Name, v5Value := range in </span><span class="cov10" title="7">{
                        if v5First </span><span class="cov6" title="3">{
                                v5First = false
                        }</span> else<span class="cov7" title="4"> {
                                out.RawByte(',')
                        }</span>
                        <span class="cov10" title="7">out.String(string(v5Name))
                        out.RawByte(':')
                        if m, ok := v5Value.(easyjson.Marshaler); ok </span><span class="cov0" title="0">{
                                m.MarshalEasyJSON(out)
                        }</span> else<span class="cov10" title="7"> if m, ok := v5Value.(json.Marshaler); ok </span><span class="cov0" title="0">{
                                out.Raw(m.MarshalJSON())
                        }</span> else<span class="cov10" title="7"> {
                                out.Raw(json.Marshal(v5Value))
                        }</span>
                }
                <span class="cov6" title="3">out.RawByte('}')</span>
        }
}

// MarshalJSON supports json.Marshaler interface
func (v Document) MarshalJSON() ([]byte, error) <span class="cov6" title="3">{
        w := jwriter.Writer{}
        easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel1(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Document) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjsonC80ae7adEncodeGithubComCheckmarxKicsPkgModel1(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Document) UnmarshalJSON(data []byte) error <span class="cov6" title="3">{
        r := jlexer.Lexer{Data: data}
        easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel1(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Document) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjsonC80ae7adDecodeGithubComCheckmarxKicsPkgModel1(l, v)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package model

import (
        json "encoding/json"
        "errors"
        "strconv"

        "github.com/rs/zerolog/log"
        "gopkg.in/yaml.v3"
)

// UnmarshalYAML is a custom yaml parser that places line information in the payload
func (m *Document) UnmarshalYAML(value *yaml.Node) error <span class="cov4" title="3">{
        dpc := unmarshal(value)
        if mapDcp, ok := dpc.(map[string]interface{}); ok </span><span class="cov4" title="3">{
                // set line information for root level objects
                mapDcp["_kics_lines"] = getLines(value, 0)

                // place the payload in the Document struct
                tmp, _ := json.Marshal(mapDcp)
                _ = json.Unmarshal(tmp, m)
                return nil
        }</span>
        <span class="cov0" title="0">return errors.New("failed to parse yaml content")</span>
}

/*
        YAML Node TYPES

        SequenceNode -&gt; array
        ScalarNode -&gt; generic (execpt for arrays, objects and maps)
        MappingNode -&gt; map

*/
// unmarshal is the function that will parse the yaml elements and call the functions needed
// to place their line information in the payload
func unmarshal(val *yaml.Node) interface{} <span class="cov9" title="13">{
        tmp := make(map[string]interface{})

        // if Yaml Node is an Array than we are working with ansible
        // which need to be placed inside "playbooks"
        if val.Kind == yaml.SequenceNode </span><span class="cov1" title="1">{
                contentArray := make([]interface{}, 0)
                for _, contentEntry := range val.Content </span><span class="cov3" title="2">{
                        contentArray = append(contentArray, unmarshal(contentEntry))
                }</span>
                <span class="cov1" title="1">tmp["playbooks"] = contentArray</span>
        } else<span class="cov9" title="12"> if val.Kind == yaml.ScalarNode </span><span class="cov4" title="3">{
                // resolve Scalar Node
                return scalarNodeResolver(val)
        }</span> else<span class="cov8" title="9"> {
                // iterate two by two, since first iteration is the key and the second is the value
                for i := 0; i &lt; len(val.Content); i += 2 </span><span class="cov10" title="16">{
                        if val.Content[i].Kind == yaml.ScalarNode </span><span class="cov10" title="16">{
                                switch val.Content[i+1].Kind </span>{
                                case yaml.ScalarNode:<span class="cov8" title="11">
                                        tmp[val.Content[i].Value] = scalarNodeResolver(val.Content[i+1])</span>
                                // in case value iteration is a map
                                case yaml.MappingNode:<span class="cov4" title="3">
                                        // unmarshall map value and get its line information
                                        tt := unmarshal(val.Content[i+1]).(map[string]interface{})
                                        tt["_kics_lines"] = getLines(val.Content[i+1], val.Content[i].Line)
                                        tmp[val.Content[i].Value] = tt</span>
                                // in case value iteration is an array
                                case yaml.SequenceNode:<span class="cov3" title="2">
                                        contentArray := make([]interface{}, 0)
                                        // unmarshall each iteration of the array
                                        for _, contentEntry := range val.Content[i+1].Content </span><span class="cov6" title="5">{
                                                contentArray = append(contentArray, unmarshal(contentEntry))
                                        }</span>
                                        <span class="cov3" title="2">tmp[val.Content[i].Value] = contentArray</span>
                                }
                        }
                }
        }
        <span class="cov8" title="10">return tmp</span>
}

// getLines creates the map containing the line information for the yaml Node
// def is the line to be used as "_kics__default"
func getLines(val *yaml.Node, def int) map[string]LineObject <span class="cov9" title="13">{
        lineMap := make(map[string]LineObject)

        // line information map
        lineMap["_kics__default"] = LineObject{
                Line: def,
                Arr:  []map[string]LineObject{},
        }

        // if yaml Node is an Array use func getSeqLines
        if val.Kind == yaml.SequenceNode </span><span class="cov1" title="1">{
                return getSeqLines(val, def)
        }</span>

        // iterate two by two, since first iteration is the key and the second is the value
        <span class="cov9" title="12">for i := 0; i &lt; len(val.Content); i += 2 </span><span class="cov10" title="16">{
                lineArr := make([]map[string]LineObject, 0)
                // in case the value iteration is an array call getLines for each iteration of the array
                if val.Content[i+1].Kind == yaml.SequenceNode </span><span class="cov3" title="2">{
                        for _, contentEntry := range val.Content[i+1].Content </span><span class="cov6" title="5">{
                                defaultLine := val.Content[i].Line
                                if contentEntry.Kind == yaml.ScalarNode </span><span class="cov4" title="3">{
                                        defaultLine = contentEntry.Line
                                }</span> else<span class="cov3" title="2"> if contentEntry.Kind == yaml.MappingNode &amp;&amp; len(contentEntry.Content) &gt; 0 </span><span class="cov3" title="2">{
                                        defaultLine = contentEntry.Content[0].Line
                                }</span>
                                <span class="cov6" title="5">lineArr = append(lineArr, getLines(contentEntry, defaultLine))</span>
                        }
                }

                // line information map of each key of the yaml Node
                <span class="cov10" title="16">lineMap["_kics_"+val.Content[i].Value] = LineObject{
                        Line: val.Content[i].Line,
                        Arr:  lineArr,
                }</span>
        }

        <span class="cov9" title="12">return lineMap</span>
}

// getSeqLines iterates through the elements of an Array
// creating a map with each iteration lines information
func getSeqLines(val *yaml.Node, def int) map[string]LineObject <span class="cov1" title="1">{
        lineMap := make(map[string]LineObject)
        lineArr := make([]map[string]LineObject, 0)

        // get line information slice of every element in the array
        for _, cont := range val.Content </span><span class="cov3" title="2">{
                lineArr = append(lineArr, getLines(cont, cont.Line))
        }</span>

        // create line information of array with its line and elements line information
        <span class="cov1" title="1">lineMap["_kics__default"] = LineObject{
                Line: def,
                Arr:  lineArr,
        }
        return lineMap</span>
}

// scalarNodeResolver transforms a ScalarNode value in its correct type
func scalarNodeResolver(val *yaml.Node) interface{} <span class="cov9" title="14">{
        var transformed interface{} = val.Value
        switch val.Tag </span>{
        case "!!bool":<span class="cov1" title="1">
                transformed = transformBoolScalarNode(val.Value)</span>
        case "!!int":<span class="cov1" title="1">
                v, err := strconv.Atoi(val.Value)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to convert integer in yaml parser")
                        return val.Value
                }</span>
                <span class="cov1" title="1">transformed = v</span>
        case "!!null":<span class="cov1" title="1">
                transformed = nil</span>
        }

        <span class="cov9" title="14">return transformed</span>
}

// transformBoolScalarNode transforms a string value to its boolean representation
func transformBoolScalarNode(value string) bool <span class="cov1" title="1">{
        switch value </span>{
        case "true", "True":<span class="cov0" title="0">
                return true</span>
        default:<span class="cov1" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package model

import (
        "os"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "time"

        "github.com/rs/zerolog/log"
)

// SeveritySummary contains scans' result numbers, how many vulnerabilities of each severity was detected
type SeveritySummary struct {
        ScanID           string           `json:"scan_id"`
        SeverityCounters map[Severity]int `json:"severity_counters"`
        TotalCounter     int              `json:"total_counter"`
}

// VulnerableFile contains information of a vulnerable file and where the vulnerability was found
type VulnerableFile struct {
        FileName         string     `json:"file_name"`
        SimilarityID     string     `json:"similarity_id"`
        Line             int        `json:"line"`
        VulnLines        []CodeLine `json:"-"`
        IssueType        IssueType  `json:"issue_type"`
        SearchKey        string     `json:"search_key"`
        SearchLine       int        `json:"search_line"`
        SearchValue      string     `json:"search_value"`
        KeyExpectedValue string     `json:"expected_value"`
        KeyActualValue   string     `json:"actual_value"`
        Value            *string    `json:"value"`
}

// VulnerableQuery contains a query that tested positive ID, name, severity and a list of files that tested vulnerable
type VulnerableQuery struct {
        QueryName                   string           `json:"query_name"`
        QueryID                     string           `json:"query_id"`
        QueryURI                    string           `json:"query_url"`
        Severity                    Severity         `json:"severity"`
        Platform                    string           `json:"platform"`
        Category                    string           `json:"category"`
        Description                 string           `json:"description"`
        DescriptionID               string           `json:"description_id"`
        CISDescriptionIDFormatted   string           `json:"cis_description_id"`
        CISDescriptionTitle         string           `json:"cis_description_title"`
        CISDescriptionTextFormatted string           `json:"cis_description_text"`
        CISDescriptionID            string           `json:"cis_description_id_raw,omitempty"`
        CISDescriptionText          string           `json:"cis_description_text_raw,omitempty"`
        CISRationaleText            string           `json:"cis_description_rationale,omitempty"`
        CISBenchmarkName            string           `json:"cis_benchmark_name,omitempty"`
        CISBenchmarkVersion         string           `json:"cis_benchmark_version,omitempty"`
        Files                       []VulnerableFile `json:"files"`
}

// VulnerableQuerySlice is a slice of VulnerableQuery
type VulnerableQuerySlice []VulnerableQuery

// Counters hold information about how many files were scanned, parsed, failed to be scaned, the total of queries
// and how many queries failed to execute
type Counters struct {
        ScannedFiles           int `json:"files_scanned"`
        ParsedFiles            int `json:"files_parsed"`
        FailedToScanFiles      int `json:"files_failed_to_scan"`
        TotalQueries           int `json:"queries_total"`
        FailedToExecuteQueries int `json:"queries_failed_to_execute"`
        FailedSimilarityID     int `json:"queries_failed_to_compute_similarity_id"`
}

// Times represents an object that contains the start and end time of the scan
type Times struct {
        Start time.Time `json:"start"`
        End   time.Time `json:"end"`
}

// Summary is a report of a single scan
type Summary struct {
        Version string `json:"kics_version,omitempty"`
        Counters
        SeveritySummary
        Times
        ScannedPaths []string             `json:"paths"`
        Queries      VulnerableQuerySlice `json:"queries"`
}

// PathParameters - structure wraps the required fields for temporary path translation
type PathParameters struct {
        ScannedPaths      []string
        PathExtractionMap map[string]ExtractedPathObject
}

var (
        queryRegex   = regexp.MustCompile(`\?([\w-]+(=[\w-]*)?(&amp;[\w-]+(=[\w-]*)?)*)?`)
        urlAuthRegex = regexp.MustCompile(`((ssh|https?)://)(\S+(:\S*)?@).*`)
)

const authGroupPosition = 3

func getRelativePath(basePath, filePath string) string <span class="cov7" title="4">{
        var returnPath string
        relativePath, err := filepath.Rel(basePath, filePath)
        if err != nil </span><span class="cov5" title="3">{
                returnPath = filePath
        }</span> else<span class="cov1" title="1"> {
                returnPath = relativePath
        }</span>
        <span class="cov7" title="4">return returnPath</span>
}

func replaceIfTemporaryPath(filePath string, pathExtractionMap map[string]ExtractedPathObject) string <span class="cov7" title="4">{
        prettyPath := filePath
        for key, val := range pathExtractionMap </span><span class="cov5" title="3">{
                if strings.Contains(filePath, key) </span><span class="cov4" title="2">{
                        splittedPath := strings.Split(filePath, key)
                        if !val.LocalPath </span><span class="cov4" title="2">{
                                // remove authentication information from the URL
                                sanitizedURL := removeURLCredentials(val.Path)
                                // remove query parameters '?key=value&amp;key2=value'
                                return filepath.FromSlash(queryRegex.ReplaceAllString(sanitizedURL, "") + splittedPath[1])
                        }</span>
                        <span class="cov0" title="0">prettyPath = filepath.FromSlash(filepath.Base(val.Path) + splittedPath[1])</span>
                } else<span class="cov1" title="1"> {
                        prettyPath = filePath
                }</span>
        }
        <span class="cov4" title="2">return prettyPath</span>
}

func removeAllURLCredentials(pathExtractionMap map[string]ExtractedPathObject) []string <span class="cov7" title="4">{
        sanitizedScannedPaths := make([]string, 0)
        for _, val := range pathExtractionMap </span><span class="cov5" title="3">{
                if !val.LocalPath </span><span class="cov4" title="2">{
                        sanitizedURL := removeURLCredentials(val.Path)
                        sanitizedScannedPaths = append(sanitizedScannedPaths, sanitizedURL)
                }</span> else<span class="cov1" title="1"> {
                        sanitizedScannedPaths = append(sanitizedScannedPaths, val.Path)
                }</span>
        }
        <span class="cov7" title="4">return sanitizedScannedPaths</span>
}

func removeURLCredentials(url string) string <span class="cov10" title="8">{
        authGroup := ""
        groups := urlAuthRegex.FindStringSubmatch(url)
        // credentials are present in the URL
        if len(groups) &gt; authGroupPosition </span><span class="cov7" title="5">{
                authGroup = groups[authGroupPosition]
        }</span>
        <span class="cov10" title="8">return strings.Replace(url, authGroup, "", 1)</span>
}

func resolvePath(filePath string, pathExtractionMap map[string]ExtractedPathObject) string <span class="cov7" title="4">{
        var returnPath string
        returnPath = replaceIfTemporaryPath(filepath.FromSlash(filePath), pathExtractionMap)
        pwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msgf("Unable to get current working dir %s", err)
                return returnPath
        }</span>
        <span class="cov7" title="4">returnPath = getRelativePath(pwd, returnPath)
        return returnPath</span>
}

// CreateSummary creates a report for a single scan, based on its scanID
func CreateSummary(counters Counters, vulnerabilities []Vulnerability,
        scanID string, pathExtractionMap map[string]ExtractedPathObject) Summary <span class="cov4" title="2">{
        log.Debug().Msg("model.CreateSummary()")
        q := make(map[string]VulnerableQuery, len(vulnerabilities))
        severitySummary := SeveritySummary{
                ScanID: scanID,
        }
        for i := range vulnerabilities </span><span class="cov1" title="1">{
                item := vulnerabilities[i]
                if _, ok := q[item.QueryID]; !ok </span><span class="cov1" title="1">{
                        q[item.QueryID] = VulnerableQuery{
                                QueryName:     item.QueryName,
                                QueryID:       item.QueryID,
                                Severity:      item.Severity,
                                QueryURI:      item.QueryURI,
                                Platform:      item.Platform,
                                Category:      item.Category,
                                Description:   item.Description,
                                DescriptionID: item.DescriptionID,
                        }
                }</span>

                <span class="cov1" title="1">qItem := q[item.QueryID]
                qItem.Files = append(qItem.Files, VulnerableFile{
                        FileName:         resolvePath(item.FileName, pathExtractionMap),
                        SimilarityID:     item.SimilarityID,
                        Line:             item.Line,
                        VulnLines:        item.VulnLines,
                        IssueType:        item.IssueType,
                        SearchKey:        item.SearchKey,
                        SearchValue:      item.SearchValue,
                        KeyExpectedValue: item.KeyExpectedValue,
                        KeyActualValue:   item.KeyActualValue,
                        Value:            item.Value,
                })

                q[item.QueryID] = qItem</span>
        }

        <span class="cov4" title="2">queries := make([]VulnerableQuery, 0, len(q))
        sevs := map[Severity]int{SeverityInfo: 0, SeverityLow: 0, SeverityMedium: 0, SeverityHigh: 0}
        for idx := range q </span><span class="cov1" title="1">{
                queries = append(queries, q[idx])
                sevs[q[idx].Severity] += len(q[idx].Files)
                severitySummary.TotalCounter += len(q[idx].Files)
        }</span>

        <span class="cov4" title="2">severityOrder := map[Severity]int{SeverityInfo: 3, SeverityLow: 2, SeverityMedium: 1, SeverityHigh: 0}
        sort.Slice(queries, func(i, j int) bool </span><span class="cov0" title="0">{
                if severityOrder[queries[i].Severity] == severityOrder[queries[j].Severity] </span><span class="cov0" title="0">{
                        return queries[i].QueryName &lt; queries[j].QueryName
                }</span>
                <span class="cov0" title="0">return severityOrder[queries[i].Severity] &lt; severityOrder[queries[j].Severity]</span>
        })

        <span class="cov4" title="2">severitySummary.SeverityCounters = sevs

        return Summary{
                Counters:        counters,
                Queries:         queries,
                SeveritySummary: severitySummary,
                ScannedPaths:    removeAllURLCredentials(pathExtractionMap),
        }</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package docker

import (
        "bytes"
        "encoding/json"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/moby/buildkit/frontend/dockerfile/parser"
        "github.com/pkg/errors"
)

// Parser is a Dockerfile parser
type Parser struct {
}

// Resource Separates the list of commands by file
type Resource struct {
        CommandList map[string][]Command `json:"command"`
}

// Command is the struct for each dockerfile command
type Command struct {
        Cmd       string
        SubCmd    string
        Flags     []string
        Value     []string
        Original  string
        StartLine int `json:"_kics_line"`
        EndLine   int
        JSON      bool
}

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string) (*[]byte, error) <span class="cov1" title="1">{
        return &amp;fileContent, nil
}</span>

// Parse - parses dockerfile to Json
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, error) <span class="cov3" title="3">{
        var documents []model.Document
        reader := bytes.NewReader(fileContent)

        parsed, err := parser.Parse(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to parse Dockerfile")
        }</span>

        <span class="cov3" title="3">fromValue := "args"
        from := make(map[string][]Command)

        for _, child := range parsed.AST.Children </span><span class="cov8" title="21">{
                if child.Value == "from" </span><span class="cov4" title="4">{
                        fromValue = strings.TrimPrefix(child.Original, "FROM ")
                }</span>

                <span class="cov8" title="21">cmd := Command{
                        Cmd:       child.Value,
                        Original:  child.Original,
                        Flags:     child.Flags,
                        StartLine: child.StartLine,
                        EndLine:   child.EndLine,
                }

                if child.Next != nil &amp;&amp; len(child.Next.Children) &gt; 0 </span><span class="cov2" title="2">{
                        cmd.SubCmd = child.Next.Children[0].Value
                        child = child.Next.Children[0]
                }</span>

                <span class="cov8" title="21">cmd.JSON = child.Attributes["json"]
                for n := child.Next; n != nil; n = n.Next </span><span class="cov10" title="31">{
                        cmd.Value = append(cmd.Value, n.Value)
                }</span>

                <span class="cov8" title="21">from[fromValue] = append(from[fromValue], cmd)</span>
        }

        <span class="cov3" title="3">doc := &amp;model.Document{}
        var resource Resource
        resource.CommandList = from

        j, err := json.Marshal(resource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to Marshal Dockerfile")
        }</span>

        <span class="cov3" title="3">if err := json.Unmarshal(j, &amp;doc); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to Unmarshal Dockerfile")
        }</span>

        <span class="cov3" title="3">documents = append(documents, *doc)

        return documents, nil</span>
}

// GetKind returns the kind of the parser
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindDOCKER
}</span>

// SupportedExtensions returns Dockerfile extensions
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{"Dockerfile", ".dockerfile"}
}</span>

// SupportedTypes returns types supported by this parser, which are dockerfile
func (p *Parser) SupportedTypes() []string <span class="cov1" title="1">{
        return []string{"Dockerfile"}
}</span>

// GetCommentToken return the comment token of Docker - #
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return "#"
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package json

import (
        "bytes"
        "encoding/json"
        "fmt"
        "sort"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
)

type jsonLine struct {
        LineInfo map[string]model.Document
}

// jsonLineStruct is the struct that keeps important information for the creation of line Information Map
// tmpParent is the parent key of the value we are currently on
// pathArr is an array containing the path elements of the value we are currently on
// noremoveidx keeps information of which elements should not be removed from pathArr on closing delimeters
// lastWasRune keeps information if last Token was a delimeter
// parent is the string path of the element we are currently on
type jsonLineStruct struct {
        tmpParent   string
        pathArr     []string
        lastWasRune bool
        noremoveidx []string
        parent      string
}

type fifo struct {
        name  string // for debugging purposes
        Value []int
}

// initiateJSONLine will create a map, containing line information for every key present in the JSON
func initializeJSONLine(doc []byte) *jsonLine <span class="cov4" title="17">{
        newMap := make(map[string]model.Document)
        dec := json.NewDecoder(bytes.NewReader(doc))

        jstruct := jsonLineStruct{
                tmpParent:   "",
                pathArr:     make([]string, 0),
                lastWasRune: false,
                noremoveidx: make([]string, 0),
                parent:      "",
        }

        // for each token inside JSON
        for </span><span class="cov6" title="158">{
                tok, err := dec.Token()
                if err != nil </span><span class="cov4" title="17">{
                        break</span>
                }

                <span class="cov6" title="141">if v, ok := tok.(json.Delim); ok </span><span class="cov6" title="80">{
                        // token is a delimeter
                        jstruct.delimSetup(v)
                }</span> else<span class="cov5" title="61"> {
                        jstruct.lastWasRune = false
                }</span>

                <span class="cov6" title="141">tokStringRepresentation := ""

                // if token is a string than update temporary father key
                switch t := tok.(type) </span>{
                case string:<span class="cov5" title="53">
                        jstruct.tmpParent = t
                        tokStringRepresentation = t</span>
                case float64:<span class="cov3" title="8">
                        tokStringRepresentation = fmt.Sprint(int(t))
                        jstruct.tmpParent = tokStringRepresentation</span>
                case bool:<span class="cov0" title="0">
                        tokStringRepresentation = fmt.Sprint(t)
                        jstruct.tmpParent = tokStringRepresentation</span>
                case nil:<span class="cov0" title="0">
                        tokStringRepresentation = fmt.Sprint(t)
                        jstruct.tmpParent = tokStringRepresentation</span>
                default:<span class="cov6" title="80">
                        continue</span>
                }

                <span class="cov5" title="61">line := 1
                // get the correct line based on byte offset
                for i, val := range doc </span><span class="cov10" title="2264">{
                        if i == int(dec.InputOffset()) </span><span class="cov5" title="61">{
                                break</span>
                        } else<span class="cov9" title="2203"> if val == byte('\n') </span><span class="cov6" title="152">{
                                line++
                        }</span>
                }

                // insert into line information map
                <span class="cov5" title="61">if _, ok := newMap[tokStringRepresentation]; !ok </span><span class="cov5" title="55">{
                        // key info is not in map yet
                        newLineSlice := &amp;fifo{name: tokStringRepresentation}
                        parentMap := make(map[string]interface{})
                        newLineSlice.add(line)
                        parentMap[jstruct.parent] = newLineSlice
                        newMap[tokStringRepresentation] = parentMap
                }</span> else<span class="cov3" title="6"> if v, ok := newMap[tokStringRepresentation][jstruct.parent]; ok </span><span class="cov1" title="2">{
                        // key info is in map with the same path so append is made
                        newLineSlice := &amp;fifo{name: tokStringRepresentation}
                        newLineSlice.add(v.(*fifo).Value...)
                        newLineSlice.add(line)
                        newMap[tokStringRepresentation][jstruct.parent] = newLineSlice
                }</span> else<span class="cov2" title="4"> {
                        // key info is in map with different path
                        newLineSlice := &amp;fifo{name: tokStringRepresentation}
                        newLineSlice.add(line)
                        newMap[tokStringRepresentation][jstruct.parent] = newLineSlice
                }</span>
        }
        <span class="cov4" title="17">return &amp;jsonLine{
                LineInfo: newMap,
        }</span>
}

// delimSetup updates the jsonLineStruct when a json delimeter (ex: { [ ...) is found
func (j *jsonLineStruct) delimSetup(v json.Delim) <span class="cov6" title="80">{
        switch rune(v) </span>{
        case '{', '[':<span class="cov5" title="40">
                // check if last element was a json delimeter
                if !j.lastWasRune </span><span class="cov5" title="38">{
                        j.pathArr = append(j.pathArr, j.tmpParent)
                }</span> else<span class="cov1" title="2"> {
                        // check if temporary parent is in path array, if not last element must be the tempParent
                        // and added to noremoveidx
                        // the next close delimeter should not remove the last element from the pathArr
                        if j.tmpParent != j.pathArr[len(j.pathArr)-1] </span><span class="cov0" title="0">{
                                j.tmpParent = j.pathArr[len(j.pathArr)-1]
                                j.noremoveidx = append(j.noremoveidx, j.tmpParent)
                        }</span> else<span class="cov1" title="2"> {
                                // the next close delimeter should not remove the last element from the pathArr
                                j.noremoveidx = append(j.noremoveidx, j.tmpParent)
                        }</span>
                }
                // update parent path string
                <span class="cov5" title="40">j.parent = strings.Join(j.pathArr, ".")</span>
        case '}', ']':<span class="cov5" title="40">
                j.closeBrackets()</span>
        }
        <span class="cov6" title="80">j.lastWasRune = true</span>
}

// closeBrackets is what based on the jsonLineStruct information
// will update the parent path and make necessary updates on its structure
func (j *jsonLineStruct) closeBrackets() <span class="cov5" title="40">{
        lenPathArr := len(j.pathArr)
        lenNoRemove := len(j.noremoveidx)
        // check if there are elements in the pathArr
        if lenPathArr &gt; 0 </span><span class="cov5" title="40">{
                // check if there are elements in the no noremoveidx
                if lenNoRemove &gt; 0 </span><span class="cov1" title="2">{
                        // if the last elements in pathArr and noremoveidx differ,
                        // than the last element on pathArr was already closed and can
                        // be removed
                        if j.pathArr[lenPathArr-1] != j.noremoveidx[lenNoRemove-1] </span><span class="cov0" title="0">{
                                j.pathArr = j.pathArr[:lenPathArr-1]
                        }</span> else<span class="cov1" title="2"> {
                                // the last element was not closed but should be closed
                                // on the next closing delim
                                // remove from noremoveidx
                                j.noremoveidx = j.noremoveidx[:lenNoRemove-1]
                        }</span>
                } else<span class="cov5" title="38"> {
                        // this last element in the pathArr was closed
                        // it can now be removed from the pathArr
                        j.pathArr = j.pathArr[:lenPathArr-1]
                }</span>
        }
        // update parent string path
        <span class="cov5" title="40">j.parent = strings.Join(j.pathArr, ".")</span>
}

// setLineInfo will set the line information of keys in json based on the line Information map
func (j *jsonLine) setLineInfo(doc map[string]interface{}) map[string]interface{} <span class="cov3" title="9">{
        // set the line info for keys in root level
        doc["_kics_lines"] = j.setLine(doc, 0, "")
        return doc
}</span>

// setLine returns the line information for the key containing values
// def is the line of the key
// index is used in case of an array, otherwhise should be 0
// father is the path to the key
func (j *jsonLine) setLine(val map[string]interface{}, def int, father string) map[string]model.LineObject <span class="cov4" title="16">{
        lineMap := make(map[string]model.LineObject)
        // set the line information of val
        lineMap["_kics__default"] = model.LineObject{
                Line: def,
                Arr:  []map[string]model.LineObject{},
        }

        // iterate through the values of the object
        for key, val := range val </span><span class="cov4" title="17">{
                // if the key with father path was not found ignore
                if _, ok2 := j.LineInfo[key][father]; !ok2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="17">line := j.LineInfo[key][father]
                lineArr := make([]map[string]model.LineObject, 0)
                lineNr := line.(*fifo).head()

                switch v := val.(type) </span>{
                // value is an array and must call func setSeqLines to set element lines
                case []interface{}:<span class="cov2" title="5">
                        lineArr = j.setSeqLines(v, lineNr, father, key, lineArr)</span>
                // value is an object and must setLines for each element of the object
                case map[string]interface{}:<span class="cov3" title="6">
                        v["_kics_lines"] = j.setLine(v, lineNr, father+"."+key)</span>
                default:<span class="cov3" title="6">
                        // value as no childs
                        lineMap["_kics_"+key] = model.LineObject{
                                Line: lineNr,
                                Arr:  lineArr,
                        }
                        continue</span>
                }

                // set line information of value with its default line and
                // if present array elements line informations
                <span class="cov3" title="11">lineMap["_kics_"+key] = model.LineObject{
                        Line: lineNr,
                        Arr:  lineArr,
                }</span>
        }
        <span class="cov4" title="16">return lineMap</span>
}

// setSeqLines sets the elements lines information for value of type array
func (j *jsonLine) setSeqLines(v []interface{}, def int, father, key string,
        lineArr []map[string]model.LineObject) []map[string]model.LineObject <span class="cov2" title="5">{
        // update father path with key
        fatherKey := father + "." + key

        defaultLineArr := j.getMapDefaultLine(v, fatherKey)
        if defaultLineArr == -1 </span><span class="cov2" title="4">{
                defaultLineArr = def
        }</span>
        // iterate over each element of the array
        <span class="cov2" title="5">for _, contentEntry := range v </span><span class="cov3" title="10">{
                switch con := contentEntry.(type) </span>{
                // case element is a map/object call func setLine
                case map[string]interface{}:<span class="cov1" title="1">

                        lineArr = append(lineArr, j.setLine(con, defaultLineArr, fatherKey))</span>
                // case element is a string
                default:<span class="cov3" title="9">
                        stringedCon := fmt.Sprint(con)
                        // check if element is present in line info map
                        if lineStr, ok2 := j.LineInfo[stringedCon][father+"."+key]; ok2 </span><span class="cov3" title="9">{
                                lineArr = append(lineArr, map[string]model.LineObject{
                                        "_kics__default": {
                                                Line: lineStr.(*fifo).pop(),
                                        },
                                })
                        }</span>
                }
        }
        <span class="cov2" title="5">return lineArr</span>
}

// must get all and choose the smallest one
func (j *jsonLine) getMapDefaultLine(v []interface{}, father string) int <span class="cov2" title="5">{
        returnNumber := -1
        for _, contentEntry := range v </span><span class="cov3" title="10">{
                linesNumbers := make([]int, 0)
                if c, ok := contentEntry.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                        for key := range c </span><span class="cov1" title="1">{
                                if _, ok2 := j.LineInfo[key][father]; !ok2 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov1" title="1">linesNumbers = append(linesNumbers, j.LineInfo[key][father].(*fifo).head())</span>
                        }
                        <span class="cov1" title="1">if len(linesNumbers) &gt; 0 </span><span class="cov1" title="1">{
                                sort.Ints(linesNumbers)
                                returnNumber = linesNumbers[0]
                        }</span>
                }
        }
        <span class="cov2" title="5">return returnNumber</span>
}

// SET OF TOOLS TO ASSIST WITH JSON LINE

func (f *fifo) add(elements ...int) <span class="cov5" title="64">{
        f.Value = append(f.Value, elements...)
}</span>

func (f *fifo) pop() int <span class="cov3" title="10">{
        firstElement := f.Value[0]
        f.Value = f.Value[1:]
        return firstElement
}</span>

func (f *fifo) head() int <span class="cov4" title="19">{
        return f.Value[0]
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package json

import (
        "encoding/json"

        "github.com/Checkmarx/kics/pkg/model"
)

// Parser defines a parser type
type Parser struct {
}

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string) (*[]byte, error) <span class="cov8" title="1">{
        return &amp;fileContent, nil
}</span>

// Parse parses json file and returns it as a Document
func (p *Parser) Parse(_ string, fileContent []byte) ([]model.Document, error) <span class="cov8" title="1">{
        r := model.Document{}
        err := json.Unmarshal(fileContent, &amp;r)
        if err != nil </span><span class="cov0" title="0">{
                r := []model.Document{}
                err = json.Unmarshal(fileContent, &amp;r)
                return r, err
        }</span>

        <span class="cov8" title="1">jLine := initializeJSONLine(fileContent)
        dd := jLine.setLineInfo(r)

        return []model.Document{dd}, nil</span>
}

// SupportedExtensions returns extensions supported by this parser, which is json extension
func (p *Parser) SupportedExtensions() []string <span class="cov8" title="1">{
        return []string{".json"}
}</span>

// GetKind returns JSON constant kind
func (p *Parser) GetKind() model.FileKind <span class="cov8" title="1">{
        return model.KindJSON
}</span>

// SupportedTypes returns types supported by this parser, which are cloudFormation
func (p *Parser) SupportedTypes() []string <span class="cov8" title="1">{
        return []string{"CloudFormation", "OpenAPI", "AzureResourceManager"}
}</span>

// GetCommentToken return an empty string, since JSON does not have comment token
func (p *Parser) GetCommentToken() string <span class="cov8" title="1">{
        return ""
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package parser

import (
        "errors"
        "path/filepath"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

type kindParser interface {
        GetKind() model.FileKind
        GetCommentToken() string
        SupportedExtensions() []string
        SupportedTypes() []string
        Parse(filePath string, fileContent []byte) ([]model.Document, error)
        Resolve(fileContent []byte, filename string) (*[]byte, error)
}

// Builder is a representation of parsers that will be construct
type Builder struct {
        parsers []kindParser
}

// NewBuilder creates a new Builder's reference
func NewBuilder() *Builder <span class="cov6" title="5">{
        log.Debug().Msg("parser.NewBuilder()")
        return &amp;Builder{}
}</span>

// Add is a function that adds a new parser to the caller and returns it
func (b *Builder) Add(p kindParser) *Builder <span class="cov8" title="11">{
        b.parsers = append(b.parsers, p)
        return b
}</span>

// Build prepares parsers and associates a parser to its extension and returns it
func (b *Builder) Build(types, cloudProviders []string) ([]*Parser, error) <span class="cov6" title="5">{
        parserSlice := make([]*Parser, 0, len(b.parsers))
        for _, parser := range b.parsers </span><span class="cov8" title="11">{
                var parsers kindParser
                extensions := make(model.Extensions, len(b.parsers))
                platforms := parser.SupportedTypes()
                if _, _, ok := contains(types, parser.SupportedTypes()); ok </span><span class="cov8" title="11">{
                        parsers = parser
                        for _, ext := range parser.SupportedExtensions() </span><span class="cov10" title="17">{
                                extensions[ext] = struct{}{}
                        }</span>
                        <span class="cov8" title="11">parserSlice = append(parserSlice, &amp;Parser{
                                parsers:    parsers,
                                extensions: extensions,
                                Platform:   platforms,
                        })</span>
                }
        }

        <span class="cov6" title="5">return parserSlice, nil</span>
}

// ErrNotSupportedFile represents an error when a file is not supported by KICS
var ErrNotSupportedFile = errors.New("unsupported file to parse")

// Parser is a struct that associates a parser to its supported extensions
type Parser struct {
        parsers    kindParser
        extensions model.Extensions
        Platform   []string
}

// CommentsCommands gets commands on comments in the file beginning, before the code starts
func (c *Parser) CommentsCommands(filePath string, fileContent []byte) model.CommentsCommands <span class="cov1" title="1">{
        if c.isValidExtension(filePath) </span><span class="cov1" title="1">{
                commentsCommands := make(model.CommentsCommands)
                commentToken := c.parsers.GetCommentToken()
                if commentToken != "" </span><span class="cov1" title="1">{
                        lines := strings.Split(string(fileContent), "\n")
                        for _, line := range lines </span><span class="cov5" title="4">{
                                line = strings.TrimSpace(line)
                                if line == "" </span><span class="cov1" title="1">{
                                        continue</span>
                                }
                                <span class="cov4" title="3">if !strings.HasPrefix(line, commentToken) </span><span class="cov1" title="1">{
                                        break</span>
                                }
                                <span class="cov3" title="2">fields := strings.Fields(strings.TrimSpace(strings.TrimPrefix(line, commentToken)))
                                if len(fields) &gt; 1 &amp;&amp; fields[0] == "kics-scan" &amp;&amp; fields[1] != "" </span><span class="cov3" title="2">{
                                        commandParameters := strings.SplitN(fields[1], "=", 2)
                                        if len(commandParameters) &gt; 1 </span><span class="cov1" title="1">{
                                                commentsCommands[commandParameters[0]] = commandParameters[1]
                                        }</span> else<span class="cov1" title="1"> {
                                                commentsCommands[commandParameters[0]] = ""
                                        }</span>
                                }
                        }
                }
                <span class="cov1" title="1">return commentsCommands</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Parse executes a parser on the fileContent and returns the file content as a Document, the file kind and
// an error, if an error has occurred
func (c *Parser) Parse(filePath string, fileContent []byte) ([]model.Document, model.FileKind, error) <span class="cov4" title="3">{
        if c.isValidExtension(filePath) </span><span class="cov4" title="3">{
                resolved, err := c.parsers.Resolve(fileContent, filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>
                <span class="cov4" title="3">obj, err := c.parsers.Parse(filePath, *resolved)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", err
                }</span>

                <span class="cov4" title="3">return obj, c.parsers.GetKind(), nil</span>
        }
        <span class="cov0" title="0">return nil, "break", ErrNotSupportedFile</span>
}

// SupportedExtensions returns extensions supported by KICS
func (c *Parser) SupportedExtensions() model.Extensions <span class="cov5" title="4">{
        return c.extensions
}</span>

func contains(types, supportedTypes []string) (invalidArgsRes []string, contRes, supportedRes bool) <span class="cov8" title="11">{
        if types[0] == "" </span><span class="cov8" title="11">{
                return []string{}, true, true
        }</span>
        <span class="cov0" title="0">set := make(map[string]struct{}, len(supportedTypes))
        for _, s := range supportedTypes </span><span class="cov0" title="0">{
                set[strings.ToUpper(s)] = struct{}{}
        }</span>
        <span class="cov0" title="0">cont := true
        supported := false
        var invalidArgs []string
        for _, item := range types </span><span class="cov0" title="0">{
                _, ok := set[strings.ToUpper(item)]
                if !ok </span><span class="cov0" title="0">{
                        cont = false
                        invalidArgs = append(invalidArgs, item)
                }</span> else<span class="cov0" title="0"> {
                        supported = true
                }</span>
        }
        <span class="cov0" title="0">return invalidArgs, cont, supported</span>
}

func (c *Parser) isValidExtension(filePath string) bool <span class="cov7" title="7">{
        ext := filepath.Ext(filePath)
        if ext == "" </span><span class="cov4" title="3">{
                ext = filepath.Base(filePath)
        }</span>
        <span class="cov7" title="7">_, ok := c.extensions[ext]
        return ok</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package converter

import (
        "fmt"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser/terraform/functions"
        "github.com/getsentry/sentry-go"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
        ctyconvert "github.com/zclconf/go-cty/cty/convert"
        ctyjson "github.com/zclconf/go-cty/cty/json"
)

// InputVariableMap represents a set of terraform input variables
type InputVariableMap map[string]cty.Value

var inputVarMap = make(InputVariableMap)

// This file is attributed to https://github.com/tmccombs/hcl2json.
// convertBlock() is manipulated for combining the both blocks and labels for one given resource.

// DefaultConverted an hcl File to a toJson serializable object
// This assumes that the body is a hclsyntax.Body
var DefaultConverted = func(file *hcl.File, inputVariables InputVariableMap) (model.Document, error) <span class="cov4" title="6">{
        inputVarMap = inputVariables
        c := converter{bytes: file.Bytes}
        body, err := c.convertBody(file.Body.(*hclsyntax.Body), 0)

        if err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                if er, ok := err.(*hcl.Diagnostic); ok &amp;&amp; er.Subject != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov4" title="6">return body, nil</span>
}

type converter struct {
        bytes []byte
}

func (c *converter) rangeSource(r hcl.Range) string <span class="cov8" title="35">{
        return string(c.bytes[r.Start.Byte:r.End.Byte])
}</span>

func (c *converter) convertBody(body *hclsyntax.Body, defLine int) (model.Document, error) <span class="cov7" title="23">{
        var err error
        out := make(model.Document)
        kicsS := make(map[string]model.LineObject)
        // set kics line for the body
        kicsS["_kics__default"] = model.LineObject{
                Line: defLine,
        }
        for key, value := range body.Attributes </span><span class="cov8" title="33">{
                out[key], err = c.convertExpression(value.Expr)
                // set kics line for the body value
                kicsS["_kics_"+key] = model.LineObject{
                        Line: value.SrcRange.Start.Line,
                        Arr:  c.getArrLines(value.Expr),
                }
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        return nil, err
                }</span>
        }

        <span class="cov7" title="23">for _, block := range body.Blocks </span><span class="cov6" title="15">{
                // set kics line for block
                kicsS["_kics_"+block.Type] = model.LineObject{
                        Line: block.TypeRange.Start.Line,
                }
                err = c.convertBlock(block, out, block.TypeRange.Start.Line)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        return nil, err
                }</span>
        }

        <span class="cov7" title="23">out["_kics_lines"] = kicsS

        return out, nil</span>
}

// getArrLines will get line information for the array elements
func (c *converter) getArrLines(expr hclsyntax.Expression) []map[string]model.LineObject <span class="cov8" title="33">{
        arr := make([]map[string]model.LineObject, 0)
        if v, ok := expr.(*hclsyntax.TupleConsExpr); ok </span><span class="cov2" title="2">{
                for _, ex := range v.Exprs </span><span class="cov5" title="7">{
                        arrEx := make(map[string]model.LineObject)
                        // set default line of array
                        arrEx["_kics__default"] = model.LineObject{
                                Line: ex.Range().Start.Line,
                        }
                        switch valType := ex.(type) </span>{
                        case *hclsyntax.ObjectConsExpr:<span class="cov3" title="3">
                                arrEx["_kics__default"] = model.LineObject{
                                        Line: ex.Range().Start.Line + 1,
                                }
                                // set lines for array elements
                                for _, item := range valType.Items </span><span class="cov4" title="6">{
                                        key, err := c.convertKey(item.KeyExpr)
                                        if err != nil </span><span class="cov0" title="0">{
                                                sentry.CaptureException(err)
                                                return nil
                                        }</span>
                                        <span class="cov4" title="6">arrEx["_kics_"+key] = model.LineObject{
                                                Line: item.KeyExpr.Range().Start.Line,
                                        }</span>
                                }
                        case *hclsyntax.TupleConsExpr:<span class="cov0" title="0">
                                // set lines for array elements if type is different than array, map/object
                                arrEx["_kics__default"] = model.LineObject{
                                        Arr: c.getArrLines(valType),
                                }</span>
                        }

                        <span class="cov5" title="7">arr = append(arr, arrEx)</span>
                }
        }
        <span class="cov8" title="33">return arr</span>
}

func (c *converter) convertBlock(block *hclsyntax.Block, out model.Document, defLine int) error <span class="cov6" title="15">{
        var key = block.Type
        value, err := c.convertBody(block.Body, defLine)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="15">for _, label := range block.Labels </span><span class="cov6" title="14">{
                if inner, exists := out[key]; exists </span><span class="cov2" title="2">{
                        var ok bool
                        out, ok = inner.(model.Document)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unable to convert Block to JSON: %v.%v", block.Type, strings.Join(block.Labels, "."))
                        }</span>
                } else<span class="cov6" title="12"> {
                        obj := make(model.Document)
                        out[key] = obj
                        out = obj
                }</span>
                <span class="cov6" title="14">key = label</span>
        }

        <span class="cov6" title="15">if current, exists := out[key]; exists </span><span class="cov3" title="3">{
                if list, ok := current.([]interface{}); ok </span><span class="cov1" title="1">{
                        out[key] = append(list, value)
                }</span> else<span class="cov2" title="2"> {
                        out[key] = []interface{}{current, value}
                }</span>
        } else<span class="cov6" title="12"> {
                out[key] = value
        }</span>

        <span class="cov6" title="15">return nil</span>
}

func (c *converter) convertExpression(expr hclsyntax.Expression) (interface{}, error) <span class="cov10" title="60">{
        // assume it is hcl syntax (because, um, it is)
        switch value := expr.(type) </span>{
        case *hclsyntax.LiteralValueExpr:<span class="cov6" title="10">
                return ctyjson.SimpleJSONValue{Value: value.Val}, nil</span>
        case *hclsyntax.TemplateExpr:<span class="cov7" title="23">
                return c.convertTemplate(value)</span>
        case *hclsyntax.TemplateWrapExpr:<span class="cov2" title="2">
                return c.convertExpression(value.Wrapped)</span>
        case *hclsyntax.TupleConsExpr:<span class="cov2" title="2">
                var list []interface{}
                for _, ex := range value.Exprs </span><span class="cov5" title="7">{
                        elem, err := c.convertExpression(ex)
                        if err != nil </span><span class="cov0" title="0">{
                                sentry.CaptureException(err)
                                return nil, err
                        }</span>
                        <span class="cov5" title="7">list = append(list, elem)</span>
                }
                <span class="cov2" title="2">return list, nil</span>
        case *hclsyntax.ObjectConsExpr:<span class="cov4" title="5">
                return c.objectConsExpr(value)</span>
        case *hclsyntax.FunctionCallExpr:<span class="cov4" title="6">
                return c.evalFunction(expr)</span>
        default:<span class="cov6" title="12">
                // try to evaluate with variables
                valueConverted, _ := expr.Value(&amp;hcl.EvalContext{
                        Variables: inputVarMap,
                })
                if !valueConverted.Type().HasDynamicTypes() &amp;&amp; valueConverted.IsKnown() </span><span class="cov4" title="6">{
                        return ctyjson.SimpleJSONValue{Value: valueConverted}, nil
                }</span>
                <span class="cov4" title="6">return c.wrapExpr(expr)</span>
        }
}

func (c *converter) objectConsExpr(value *hclsyntax.ObjectConsExpr) (model.Document, error) <span class="cov4" title="5">{
        m := make(model.Document)
        for _, item := range value.Items </span><span class="cov7" title="18">{
                key, err := c.convertKey(item.KeyExpr)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        return nil, err
                }</span>
                <span class="cov7" title="18">m[key], err = c.convertExpression(item.ValueExpr)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        return nil, err
                }</span>
        }
        <span class="cov4" title="5">return m, nil</span>
}

func (c *converter) convertKey(keyExpr hclsyntax.Expression) (string, error) <span class="cov7" title="24">{
        // a key should never have dynamic input
        if k, isKeyExpr := keyExpr.(*hclsyntax.ObjectConsKeyExpr); isKeyExpr </span><span class="cov7" title="24">{
                keyExpr = k.Wrapped
                if _, isTraversal := keyExpr.(*hclsyntax.ScopeTraversalExpr); isTraversal </span><span class="cov7" title="20">{
                        return c.rangeSource(keyExpr.Range()), nil
                }</span>
        }
        <span class="cov4" title="4">return c.convertStringPart(keyExpr)</span>
}

func (c *converter) convertTemplate(t *hclsyntax.TemplateExpr) (string, error) <span class="cov8" title="31">{
        if t.IsStringLiteral() </span><span class="cov7" title="24">{
                // safe because the value is just the string
                v, err := t.Value(nil)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        return "", err
                }</span>
                <span class="cov7" title="24">return v.AsString(), nil</span>
        }
        <span class="cov5" title="7">var builder strings.Builder
        for _, part := range t.Parts </span><span class="cov7" title="23">{
                s, err := c.convertStringPart(part)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        return "", err
                }</span>
                <span class="cov7" title="23">builder.WriteString(s)</span>
        }
        <span class="cov5" title="7">return builder.String(), nil</span>
}

func (c *converter) convertStringPart(expr hclsyntax.Expression) (string, error) <span class="cov8" title="33">{
        switch v := expr.(type) </span>{
        case *hclsyntax.LiteralValueExpr:<span class="cov6" title="15">
                s, err := ctyconvert.Convert(v.Val, cty.String)
                if err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        return "", err
                }</span>
                <span class="cov6" title="15">return s.AsString(), nil</span>
        case *hclsyntax.TemplateExpr:<span class="cov5" title="8">
                return c.convertTemplate(v)</span>
        case *hclsyntax.TemplateWrapExpr:<span class="cov1" title="1">
                return c.convertStringPart(v.Wrapped)</span>
        case *hclsyntax.ConditionalExpr:<span class="cov2" title="2">
                return c.convertTemplateConditional(v)</span>
        case *hclsyntax.TemplateJoinExpr:<span class="cov1" title="1">
                return c.convertTemplateFor(v.Tuple.(*hclsyntax.ForExpr))</span>
        default:<span class="cov4" title="6">
                // try to evaluate with variables
                valueConverted, _ := expr.Value(&amp;hcl.EvalContext{
                        Variables: inputVarMap,
                })
                if valueConverted.Type().FriendlyName() == "string" </span><span class="cov1" title="1">{
                        return valueConverted.AsString(), nil
                }</span>
                // treating as an embedded expression
                <span class="cov4" title="5">return c.wrapExpr(expr)</span>
        }
}

func (c *converter) convertTemplateConditional(expr *hclsyntax.ConditionalExpr) (string, error) <span class="cov2" title="2">{
        var builder strings.Builder
        builder.WriteString("%{if ")
        builder.WriteString(c.rangeSource(expr.Condition.Range()))
        builder.WriteString("}")
        trueResult, err := c.convertStringPart(expr.TrueResult)
        if err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                return "", nil
        }</span>
        <span class="cov2" title="2">builder.WriteString(trueResult)
        falseResult, err := c.convertStringPart(expr.FalseResult)
        if err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                return "", nil
        }</span>
        <span class="cov2" title="2">if len(falseResult) &gt; 0 </span><span class="cov1" title="1">{
                builder.WriteString("%{else}")
                builder.WriteString(falseResult)
        }</span>
        <span class="cov2" title="2">builder.WriteString("%{endif}")

        return builder.String(), nil</span>
}

func (c *converter) convertTemplateFor(expr *hclsyntax.ForExpr) (string, error) <span class="cov1" title="1">{
        var builder strings.Builder
        builder.WriteString("%{for ")
        if len(expr.KeyVar) &gt; 0 </span><span class="cov0" title="0">{
                builder.WriteString(expr.KeyVar)
                builder.WriteString(", ")
        }</span>
        <span class="cov1" title="1">builder.WriteString(expr.ValVar)
        builder.WriteString(" in ")
        builder.WriteString(c.rangeSource(expr.CollExpr.Range()))
        builder.WriteString("}")
        templ, err := c.convertStringPart(expr.ValExpr)
        if err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                return "", err
        }</span>
        <span class="cov1" title="1">builder.WriteString(templ)
        builder.WriteString("%{endfor}")

        return builder.String(), nil</span>
}

func (c *converter) wrapExpr(expr hclsyntax.Expression) (string, error) <span class="cov6" title="11">{
        expression := c.rangeSource(expr.Range())
        if strings.HasPrefix(expression, "var.") </span><span class="cov3" title="3">{
                log.Trace().Msgf("Variable ${%s} value not found", expression)
        }</span>
        <span class="cov6" title="11">return "${" + expression + "}", nil</span>
}

func (c *converter) evalFunction(expression hclsyntax.Expression) (interface{}, error) <span class="cov4" title="6">{
        expressionEvaluated, err := expression.Value(&amp;hcl.EvalContext{
                Variables: inputVarMap,
                Functions: functions.TerraformFuncs,
        })
        if err != nil </span><span class="cov1" title="1">{
                for _, expressionError := range err </span><span class="cov1" title="1">{
                        if expressionError.Summary == "Unknown variable" </span><span class="cov1" title="1">{
                                jsonPath := c.rangeSource(expressionError.Expression.Range())
                                rootKey := strings.Split(jsonPath, ".")[0]
                                if strings.Contains(jsonPath, ".") </span><span class="cov1" title="1">{
                                        jsonCtyValue, convertErr := createEntryInputVar(strings.Split(jsonPath, ".")[1:], jsonPath)
                                        if convertErr != nil </span><span class="cov0" title="0">{
                                                return c.wrapExpr(expression)
                                        }</span>
                                        <span class="cov1" title="1">inputVarMap[rootKey] = jsonCtyValue</span>
                                } else<span class="cov0" title="0"> {
                                        inputVarMap[rootKey] = cty.StringVal(jsonPath)
                                }</span>
                        }
                }
                <span class="cov1" title="1">expressionEvaluated, err = expression.Value(&amp;hcl.EvalContext{
                        Variables: inputVarMap,
                        Functions: functions.TerraformFuncs,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return c.wrapExpr(expression)
                }</span>
        }
        <span class="cov4" title="6">return ctyjson.SimpleJSONValue{Value: expressionEvaluated}, nil</span>
}

func createEntryInputVar(path []string, defaultValue string) (cty.Value, error) <span class="cov1" title="1">{
        mapJSON := "{"
        closeMap := "}"
        for idx, key := range path </span><span class="cov1" title="1">{
                if idx+1 &lt; len(path) </span><span class="cov0" title="0">{
                        mapJSON += fmt.Sprintf("\"%s\":{", key)
                        closeMap += "}"
                }</span> else<span class="cov1" title="1"> {
                        mapJSON += fmt.Sprintf("\"%s\": \"%s\"", key, defaultValue)
                }</span>
        }
        <span class="cov1" title="1">mapJSON += closeMap
        jsonType, err := ctyjson.ImpliedType([]byte(mapJSON))
        if err != nil </span><span class="cov0" title="0">{
                return cty.NilVal, err
        }</span>
        <span class="cov1" title="1">value, err := ctyjson.Unmarshal([]byte(mapJSON), jsonType)
        if err != nil </span><span class="cov0" title="0">{
                return cty.NilVal, err
        }</span>
        <span class="cov1" title="1">return value, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package terraform

import (
        "path/filepath"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser/terraform/converter"
        "github.com/Checkmarx/kics/pkg/parser/utils"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/pkg/errors"
)

// RetriesDefaultValue is default number of times a parser will retry to execute
const RetriesDefaultValue = 50

// Converter returns content json, error line, error
type Converter func(file *hcl.File, inputVariables converter.InputVariableMap) (model.Document, error)

// Parser struct that contains the function to parse file and the number of retries if something goes wrong
type Parser struct {
        convertFunc  Converter
        numOfRetries int
}

// NewDefault initializes a parser with Parser default values
func NewDefault() *Parser <span class="cov5" title="2">{
        return &amp;Parser{
                numOfRetries: RetriesDefaultValue,
                convertFunc:  converter.DefaultConverted,
        }
}</span>

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string) (*[]byte, error) <span class="cov1" title="1">{
        getInputVariables(filepath.Dir(filename))
        return &amp;fileContent, nil
}</span>

func processContent(elements model.Document, content, path string) <span class="cov1" title="1">{
        var certInfo map[string]interface{}
        if content != "" </span><span class="cov1" title="1">{
                certInfo = utils.AddCertificateInfo(path, content)
                if certInfo != nil </span><span class="cov1" title="1">{
                        elements["certificate_body"] = certInfo
                }</span>
        }
}

func processElements(elements model.Document, path string) <span class="cov1" title="1">{
        for k, v3 := range elements </span><span class="cov10" title="4">{ // resource elements
                if k != "certificate_body" </span><span class="cov10" title="4">{
                        continue</span>
                }
                <span class="cov0" title="0">content := utils.CheckCertificate(v3.(string))
                processContent(elements, content, path)</span>
        }
}

func processResources(doc model.Document, path string) error <span class="cov1" title="1">{
        var resourcesElements model.Document
        for _, resources := range doc </span><span class="cov1" title="1">{ // iterate over resources
                resourcesElements = resources.(model.Document)
                for _, v2 := range resourcesElements </span><span class="cov1" title="1">{ // resource name
                        switch t := v2.(type) </span>{
                        case []interface{}:<span class="cov0" title="0">
                                return errors.New("failed to process resources")</span>
                        case interface{}:<span class="cov1" title="1">
                                if elements, ok := t.(model.Document); ok </span><span class="cov1" title="1">{
                                        processElements(elements, path)
                                }</span>
                        }
                }
        }
        <span class="cov1" title="1">return nil</span>
}

func addExtraInfo(json []model.Document, path string) ([]model.Document, error) <span class="cov1" title="1">{
        for _, documents := range json </span><span class="cov1" title="1">{ // iterate over documents
                if documents["resource"] != nil </span><span class="cov1" title="1">{
                        err := processResources(documents["resource"].(model.Document), path)
                        if err != nil </span><span class="cov0" title="0">{
                                return []model.Document{}, err
                        }</span>
                }
        }

        <span class="cov1" title="1">return json, nil</span>
}

// Parse execute parser for the content in a file
func (p *Parser) Parse(path string, content []byte) ([]model.Document, error) <span class="cov1" title="1">{
        file, diagnostics := hclsyntax.ParseConfig(content, filepath.Base(path), hcl.Pos{Byte: 0, Line: 1, Column: 1})

        if diagnostics != nil &amp;&amp; diagnostics.HasErrors() &amp;&amp; len(diagnostics.Errs()) &gt; 0 </span><span class="cov0" title="0">{
                err := diagnostics.Errs()[0]
                return nil, err
        }</span>

        <span class="cov1" title="1">fc, parseErr := p.convertFunc(file, inputVariableMap)
        json, err := addExtraInfo([]model.Document{fc}, path)
        if err != nil </span><span class="cov0" title="0">{
                return json, errors.Wrap(err, "failed terraform parse")
        }</span>

        <span class="cov1" title="1">return json, errors.Wrap(parseErr, "failed terraform parse")</span>
}

// SupportedExtensions returns Terraform extensions
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{".tf"}
}</span>

// SupportedTypes returns types supported by this parser, which are terraform
func (p *Parser) SupportedTypes() []string <span class="cov1" title="1">{
        return []string{"Terraform"}
}</span>

// GetKind returns Terraform kind parser
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindTerraform
}</span>

// GetCommentToken return the comment token of Terraform - #
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return "#"
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package terraform

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/Checkmarx/kics/pkg/parser/terraform/converter"
        "github.com/hashicorp/hcl/v2"
        "github.com/hashicorp/hcl/v2/hclsyntax"
        "github.com/rs/zerolog/log"
        "github.com/zclconf/go-cty/cty"
)

var inputVariableMap = make(converter.InputVariableMap)

func mergeMaps(baseMap, newItems converter.InputVariableMap) <span class="cov6" title="6">{
        for key, value := range newItems </span><span class="cov7" title="8">{
                baseMap[key] = value
        }</span>
}

func parseFile(filename string) (*hcl.File, error) <span class="cov10" title="16">{
        file, err := os.ReadFile(filename)
        if err != nil </span><span class="cov4" title="3">{
                return nil, err
        }</span>

        <span class="cov9" title="13">parsedFile, _ := hclsyntax.ParseConfig(file, filename, hcl.Pos{Line: 1, Column: 1})

        return parsedFile, nil</span>
}

func setInputVariablesDefaultValues(filename string) (converter.InputVariableMap, error) <span class="cov7" title="7">{
        parsedFile, err := parseFile(filename)
        if err != nil || parsedFile == nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov6" title="6">content, _, _ := parsedFile.Body.PartialContent(&amp;hcl.BodySchema{
                Blocks: []hcl.BlockHeaderSchema{
                        {
                                Type:       "variable",
                                LabelNames: []string{"name"},
                        },
                },
        })
        defaultValuesMap := make(converter.InputVariableMap)
        for _, block := range content.Blocks </span><span class="cov7" title="8">{
                if len(block.Labels) == 0 || block.Labels[0] == "" </span><span class="cov3" title="2">{
                        continue</span>
                }
                <span class="cov6" title="6">attr, _ := block.Body.JustAttributes()
                if attr == nil || len(attr) == 0 </span><span class="cov3" title="2">{
                        continue</span>
                }
                <span class="cov5" title="4">if defaultValue, exists := attr["default"]; exists </span><span class="cov5" title="4">{
                        defaultVar, _ := defaultValue.Expr.Value(nil)
                        defaultValuesMap[block.Labels[0]] = defaultVar
                }</span>
        }
        <span class="cov6" title="6">return defaultValuesMap, nil</span>
}

func checkTfvarsValid(f *hcl.File, filename string) error <span class="cov6" title="5">{
        content, _, _ := f.Body.PartialContent(&amp;hcl.BodySchema{
                Blocks: []hcl.BlockHeaderSchema{
                        {
                                Type:       "variable",
                                LabelNames: []string{"name"},
                        },
                },
        })
        if len(content.Blocks) &gt; 0 </span><span class="cov3" title="2">{
                return fmt.Errorf("failed to get variables from %s, .tfvars file is used to assing values not to declare new variables", filename)
        }</span>
        <span class="cov4" title="3">return nil</span>
}

func getInputVariablesFromFile(filename string) (converter.InputVariableMap, error) <span class="cov6" title="6">{
        parsedFile, err := parseFile(filename)
        if err != nil || parsedFile == nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov6" title="5">err = checkTfvarsValid(parsedFile, filename)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov4" title="3">attrs := parsedFile.Body.(*hclsyntax.Body).Attributes
        variables := make(converter.InputVariableMap)
        for name, attr := range attrs </span><span class="cov8" title="9">{
                value, _ := attr.Expr.Value(&amp;hcl.EvalContext{})
                variables[name] = value
        }</span>
        <span class="cov4" title="3">return variables, nil</span>
}

func getInputVariables(currentPath string) <span class="cov3" title="2">{
        variablesMap := make(converter.InputVariableMap)
        tfFiles, err := filepath.Glob(filepath.Join(currentPath, "*.tf"))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msg("Error getting .tf files")
        }</span>
        <span class="cov3" title="2">for _, tfFile := range tfFiles </span><span class="cov4" title="3">{
                variables, errDefaultValues := setInputVariablesDefaultValues(tfFile)
                if errDefaultValues != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("Error getting default values from %s", tfFile)
                        log.Err(errDefaultValues)
                        continue</span>
                }
                <span class="cov4" title="3">mergeMaps(variablesMap, variables)</span>
        }
        <span class="cov3" title="2">tfVarsFiles, err := filepath.Glob(filepath.Join(currentPath, "*.auto.tfvars"))
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Msg("Error getting .auto.tfvars files")
        }</span>

        <span class="cov3" title="2">_, err = os.Stat(filepath.Join(currentPath, "terraform.tfvars"))
        if err != nil </span><span class="cov1" title="1">{
                log.Trace().Msgf("terraform.tfvars not found on %s", currentPath)
        }</span> else<span class="cov1" title="1"> {
                tfVarsFiles = append(tfVarsFiles, filepath.Join(currentPath, "terraform.tfvars"))
        }</span>

        <span class="cov3" title="2">for _, tfVarsFile := range tfVarsFiles </span><span class="cov4" title="3">{
                variables, errInputVariables := getInputVariablesFromFile(tfVarsFile)
                if errInputVariables != nil </span><span class="cov1" title="1">{
                        log.Error().Msgf("Error getting values from %s", tfVarsFiles)
                        log.Err(errInputVariables)
                        continue</span>
                }
                <span class="cov3" title="2">mergeMaps(variablesMap, variables)</span>
        }
        <span class="cov3" title="2">inputVariableMap["var"] = cty.ObjectVal(variablesMap)</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package utils

import (
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "os"
        "path/filepath"
        "regexp"

        "github.com/rs/zerolog/log"
)

type certInfo struct {
        date        [3]int
        rsaKeyBytes int
}

// CheckCertificate verifies if the attribute 'certificate_body' refers a file
func CheckCertificate(content string) string <span class="cov1" title="1">{
        var re = regexp.MustCompile(`[0-9a-zA-Z-/\\_.]+\.pem`)

        match := re.FindString(content)

        return match
}</span>

func getCertificateInfo(filePath string) (certInfo, error) <span class="cov10" title="2">{
        certPEM, err := os.ReadFile(filePath)

        if err != nil </span><span class="cov0" title="0">{
                return certInfo{}, err
        }</span>

        <span class="cov10" title="2">block, _ := pem.Decode(certPEM)
        if block == nil </span><span class="cov0" title="0">{
                return certInfo{}, errors.New("failed to parse the certificate PEM")
        }</span>
        <span class="cov10" title="2">cert, err := x509.ParseCertificate(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return certInfo{}, err
        }</span>

        <span class="cov10" title="2">var certDate [3]int
        certDate[0] = cert.NotAfter.Year()
        certDate[1] = int(cert.NotAfter.Month())
        certDate[2] = cert.NotAfter.Day()

        var rsaBytes int

        switch t := cert.PublicKey.(type) </span>{
        case *rsa.PublicKey:<span class="cov10" title="2">
                _ = t
                rsaBytes = cert.PublicKey.(*rsa.PublicKey).Size()</span>
        default:<span class="cov0" title="0">
                rsaBytes = -1</span>
        }

        <span class="cov10" title="2">return certInfo{date: certDate, rsaKeyBytes: rsaBytes}, nil</span>
}

// AddCertificateInfo gets and adds certificate information of a certificate file
func AddCertificateInfo(path, content string) map[string]interface{} <span class="cov1" title="1">{
        var filePath string

        _, err := os.Stat(content)

        if err != nil </span><span class="cov1" title="1">{ // content is not a full valid path or is an incomplete path
                log.Trace().Msgf("path to the certificate content is not a valid: %s", content)
                filePath = filepath.Join(filepath.Dir(path), content)
        }</span> else<span class="cov0" title="0"> { // content is a full valid path
                filePath = content
        }</span>

        <span class="cov1" title="1">date, err := getCertificateInfo(filePath)

        if err == nil </span><span class="cov1" title="1">{
                attributes := make(map[string]interface{})
                attributes["file"] = filePath
                attributes["expiration_date"] = date.date

                if date.rsaKeyBytes != -1 </span><span class="cov1" title="1">{
                        attributes["rsa_key_bytes"] = date.rsaKeyBytes
                }</span>

                <span class="cov1" title="1">return attributes</span>
        }

        <span class="cov0" title="0">log.Error().Msgf("Failed to get certificate path %s: %s", filePath, err)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package utils

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "github.com/rs/zerolog/log"
        "gopkg.in/yaml.v3"
)

func convert(m map[interface{}]interface{}) map[string]interface{} <span class="cov5" title="3">{
        res := map[string]interface{}{}
        for k, v := range m </span><span class="cov10" title="9">{
                switch v2 := v.(type) </span>{
                case map[interface{}]interface{}:<span class="cov0" title="0">
                        res[fmt.Sprint(k)] = convert(v2)</span>
                default:<span class="cov10" title="9">
                        res[fmt.Sprint(k)] = v</span>
                }
        }
        <span class="cov5" title="3">return res</span>
}

func readFile(filePath string) (map[string]interface{}, error) <span class="cov3" title="2">{
        var result map[string]interface{}

        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Trace().Msgf("failed to read %s", filePath)
                return nil, err
        }</span>

        <span class="cov3" title="2">fileExtension := filepath.Ext(filePath)

        if fileExtension == ".json" </span><span class="cov0" title="0">{
                err := json.Unmarshal(content, &amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("Failed to unmarshal '%s'", filePath)
                        return nil, err
                }</span>
        } else<span class="cov3" title="2"> if fileExtension == ".yaml" || fileExtension == ".yml" </span><span class="cov3" title="2">{
                var resultYaml map[interface{}]interface{}
                err := yaml.Unmarshal(content, &amp;resultYaml)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("Failed to unmarshal '%s'", filePath)
                        return nil, err
                }</span>
                <span class="cov3" title="2">result = convert(resultYaml)</span>
        }

        <span class="cov3" title="2">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package utils

import (
        "os"
        "path/filepath"

        "github.com/rs/zerolog/log"
)

// AddSwaggerInfo gets and adds the content of a swagger file
func AddSwaggerInfo(path, swaggerPath string) map[string]interface{} <span class="cov8" title="1">{
        var filePath string

        _, err := os.Stat(swaggerPath)

        if err != nil </span><span class="cov8" title="1">{ // content is not a full valid path or is an incomplete path
                log.Trace().Msgf("path to the swagger content specification is not a valid: %s", swaggerPath)
                filePath = filepath.Join(filepath.Dir(path), swaggerPath)
        }</span> else<span class="cov0" title="0"> { // content is a full valid path
                filePath = swaggerPath
        }</span>

        <span class="cov8" title="1">swaggerContent, err := readFile(filePath)

        if err == nil </span><span class="cov8" title="1">{
                attributes := make(map[string]interface{})
                attributes["file"] = filePath
                attributes["content"] = swaggerContent
                return attributes
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package json

import (
        "bytes"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/Checkmarx/kics/pkg/parser/utils"
        "github.com/pkg/errors"
        "gopkg.in/yaml.v3"
)

// Parser defines a parser type
type Parser struct {
}

// Resolve - replace or modifies in-memory content before parsing
func (p *Parser) Resolve(fileContent []byte, filename string) (*[]byte, error) <span class="cov1" title="1">{
        return &amp;fileContent, nil
}</span>

// Parse parses yaml/yml file and returns it as a Document
func (p *Parser) Parse(filePath string, fileContent []byte) ([]model.Document, error) <span class="cov7" title="5">{
        var documents []model.Document
        dec := yaml.NewDecoder(bytes.NewReader(fileContent))

        doc := &amp;model.Document{}
        for dec.Decode(doc) == nil </span><span class="cov6" title="4">{
                if doc != nil </span><span class="cov6" title="4">{
                        documents = append(documents, *doc)
                }</span>
                <span class="cov6" title="4">doc = &amp;model.Document{}</span>
        }

        <span class="cov7" title="5">if len(documents) == 0 </span><span class="cov3" title="2">{
                return nil, errors.Wrap(errors.New("invalid yaml"), "failed to parse yaml")
        }</span>

        <span class="cov5" title="3">return convertKeysToString(addExtraInfo(documents, filePath)), nil</span>
}

// convertKeysToString goes through every document to convert map[interface{}]interface{}
// to map[string]interface{}
func convertKeysToString(docs []model.Document) []model.Document <span class="cov5" title="3">{
        documents := make([]model.Document, 0, len(docs))
        for _, doc := range docs </span><span class="cov6" title="4">{
                for key, value := range doc </span><span class="cov9" title="9">{
                        doc[key] = convert(value)
                }</span>
                <span class="cov6" title="4">documents = append(documents, doc)</span>
        }
        <span class="cov5" title="3">return documents</span>
}

// convert goes recursively through the keys in the given value and converts nested maps type of map[interface{}]interface{}
// to map[string]interface{}
func convert(value interface{}) interface{} <span class="cov10" title="11">{
        switch t := value.(type) </span>{
        case map[interface{}]interface{}:<span class="cov0" title="0">
                mapStr := map[string]interface{}{}
                for key, val := range t </span><span class="cov0" title="0">{
                        if t, ok := key.(string); ok </span><span class="cov0" title="0">{
                                mapStr[t] = convert(val)
                        }</span>
                }
                <span class="cov0" title="0">return mapStr</span>
        case []interface{}:<span class="cov3" title="2">
                for key, val := range t </span><span class="cov3" title="2">{
                        t[key] = convert(val)
                }</span>
        case model.Document:<span class="cov0" title="0">
                for key, val := range t </span><span class="cov0" title="0">{
                        t[key] = convert(val)
                }</span>
        }
        <span class="cov10" title="11">return value</span>
}

// SupportedExtensions returns extensions supported by this parser, which are yaml and yml extension
func (p *Parser) SupportedExtensions() []string <span class="cov1" title="1">{
        return []string{".yaml", ".yml"}
}</span>

// SupportedTypes returns types supported by this parser, which are ansible, cloudFormation, k8s
func (p *Parser) SupportedTypes() []string <span class="cov1" title="1">{
        return []string{"Ansible", "CloudFormation", "Kubernetes", "OpenAPI"}
}</span>

// GetKind returns YAML constant kind
func (p *Parser) GetKind() model.FileKind <span class="cov1" title="1">{
        return model.KindYAML
}</span>

func processSwaggerContent(elements map[string]interface{}, filePath string) <span class="cov1" title="1">{
        swaggerInfo := utils.AddSwaggerInfo(filePath, elements["swagger_file"].(string))
        if swaggerInfo != nil </span><span class="cov0" title="0">{
                elements["swagger_file"] = swaggerInfo
        }</span>
}

func processCertContent(elements map[string]interface{}, content, filePath string) <span class="cov1" title="1">{
        var certInfo map[string]interface{}
        if content != "" </span><span class="cov1" title="1">{
                certInfo = utils.AddCertificateInfo(filePath, content)
                if certInfo != nil </span><span class="cov1" title="1">{
                        elements["certificate"] = certInfo
                }</span>
        }
}

func processElements(elements map[string]interface{}, filePath string) <span class="cov3" title="2">{
        if elements["certificate"] != nil </span><span class="cov1" title="1">{
                processCertContent(elements, utils.CheckCertificate(elements["certificate"].(string)), filePath)
        }</span>
        <span class="cov3" title="2">if elements["swagger_file"] != nil </span><span class="cov1" title="1">{
                processSwaggerContent(elements, filePath)
        }</span>
}

func addExtraInfo(documents []model.Document, filePath string) []model.Document <span class="cov5" title="3">{
        for _, documentPlaybooks := range documents </span><span class="cov6" title="4">{ // iterate over documents
                if playbooks, ok := documentPlaybooks["playbooks"]; ok </span><span class="cov1" title="1">{
                        for _, resources := range playbooks.([]interface{}) </span><span class="cov1" title="1">{ // iterate over playbooks
                                for _, v := range resources.(map[string]interface{}) </span><span class="cov3" title="2">{
                                        _, ok := v.(map[string]interface{})
                                        if ok </span><span class="cov1" title="1">{
                                                processElements(v.(map[string]interface{}), filePath)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov5" title="3">return documents</span>
}

// GetCommentToken return the comment token of YAML - #
func (p *Parser) GetCommentToken() string <span class="cov1" title="1">{
        return "#"
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package circle

import (
        "fmt"
        "io"
        "sync"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/cheggaaa/pb/v3"
)

const (
        barWidth = 0
)

// ProgressBar is a struct that holds the required feilds for
// a Circle Progress Bar
type ProgressBar struct {
        label string
        pBar  *pb.ProgressBar
        close func() error
}

// NewProgressBar creates a new instance of a Circle Progress Bar
func NewProgressBar(label string, silent bool) ProgressBar <span class="cov10" title="3">{
        newPb := pb.New64(constants.MaxInteger)
        tmp := fmt.Sprintf(`{{ "%s" }} {{(cycle . "\\" "-" "|" "/" "-" "|" )}}`, label)
        newPb.SetWidth(barWidth)
        newPb.SetTemplateString(tmp)
        if silent </span><span class="cov1" title="1">{
                newPb.SetWriter(io.Discard)
        }</span>
        <span class="cov10" title="3">newPb.Start()

        return ProgressBar{
                label: label,
                pBar:  newPb,
                close: func() error </span><span class="cov1" title="1">{
                        newPb.Finish()
                        return nil
                }</span>,
        }
}

// Start initializes the Circle Progress Bar
func (p ProgressBar) Start() <span class="cov1" title="1">{
        wg := &amp;sync.WaitGroup{}
        go p.incrementProgress(wg)

        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        wg.Wait()
                }</span>()
        }()
}

func (p ProgressBar) incrementProgress(wg *sync.WaitGroup) <span class="cov0" title="0">{
        wg.Add(1)
        defer wg.Done()
        for </span><span class="cov0" title="0">{ // increment until the Close func is called
                p.pBar.Increment()
        }</span>
}

// Close stops the Circle Progress Bar and
// changes the template to done
func (p ProgressBar) Close() error <span class="cov1" title="1">{
        p.pBar.SetTemplateString(fmt.Sprintf("%sDone", p.label))
        return p.close()
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package counter

import (
        "io"
        "sync"

        "github.com/cheggaaa/pb/v3"
        "github.com/rs/zerolog/log"
)

// ProgressBar is a struct that holds the required feilds for
// a Counter Progress Bar
type ProgressBar struct {
        label           string
        total           int64
        currentProgress int64
        progress        chan int64
        pBar            *pb.ProgressBar
        close           func() error
        wg              *sync.WaitGroup
}

const (
        barWidth = 80
)

// NewProgressBar creates a new instance of a Counter Progress Bar
func NewProgressBar(label string, total int64, progress chan int64, wg *sync.WaitGroup, silent bool) ProgressBar <span class="cov3" title="2">{
        newPb := pb.New64(total)
        newPb.SetMaxWidth(barWidth)
        newPb.Set("prefix", label)
        newPb.SetTemplateString(`{{string . "prefix"}}{{bar . }} {{percent . }}`)
        if silent </span><span class="cov1" title="1">{
                newPb.SetWriter(io.Discard)
        }</span>
        <span class="cov3" title="2">newPb.Start()

        return ProgressBar{
                label:    label,
                total:    total,
                progress: progress,
                pBar:     newPb,
                wg:       wg,
                close: func() error </span><span class="cov1" title="1">{
                        newPb.Finish()
                        return nil
                }</span>,
        }
}

// Start initializes the Counter Progress Bar
func (p ProgressBar) Start() <span class="cov3" title="2">{
        defer func() </span><span class="cov1" title="1">{
                err := p.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Msgf("failed to stop progress bar %v", err)
                }</span>
                <span class="cov0" title="0">p.wg.Done()</span>
        }()

        <span class="cov3" title="2">for </span><span class="cov10" title="20">{
                newProgress, ok := &lt;-p.progress
                p.currentProgress += newProgress
                p.pBar.Increment()
                if !ok || p.currentProgress &gt;= p.pBar.Total() </span><span class="cov1" title="1">{
                        break</span>
                }
        }
}

// Close stops the Counter Progress Bar
func (p ProgressBar) Close() error <span class="cov1" title="1">{ return p.close() }</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package progress

import (
        "sync"

        "github.com/Checkmarx/kics/pkg/progress/circle"
        "github.com/Checkmarx/kics/pkg/progress/counter"
)

// PBar is the interface for the types of available progress bars (Circle ,Counter)
// Start initializes the Progress Bar execution
// Close stops the Progress Bar execution
type PBar interface {
        Start()
        Close() error
}

// PbBuilder is the struct that contains the progress bar Builders
// Silent is set to true when all progress bars should be silent
type PbBuilder struct {
        Silent bool
}

// InitializePbBuilder creates an instace of a PbBuilder
func InitializePbBuilder(noProgress, ci, silentFlag bool) *PbBuilder <span class="cov10" title="2">{
        pbbuilder := PbBuilder{
                Silent: false,
        }
        if noProgress || ci || silentFlag </span><span class="cov1" title="1">{
                pbbuilder = PbBuilder{
                        Silent: true,
                }
        }</span>
        <span class="cov10" title="2">return &amp;pbbuilder</span>
}

// BuildCounter builds and returns a Counter Progress Bar
func (i *PbBuilder) BuildCounter(label string, total int, wg *sync.WaitGroup, progressChannel chan int64) PBar <span class="cov1" title="1">{
        return counter.NewProgressBar(label, int64(total), progressChannel, wg, i.Silent)
}</span>

// BuildCircle builds and returns a Circle Progress Bar
func (i *PbBuilder) BuildCircle(label string) PBar <span class="cov1" title="1">{
        return circle.NewProgressBar(label, i.Silent)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package report

import (
        "encoding/json"
        "fmt"
        "html/template"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

var (
        stringsSeverity = map[string]model.Severity{
                "high":   model.AllSeverities[0],
                "medium": model.AllSeverities[1],
                "low":    model.AllSeverities[2],
                "info":   model.AllSeverities[3],
        }

        templateFuncs = template.FuncMap{
                "lower":          strings.ToLower,
                "sprintf":        fmt.Sprintf,
                "severity":       getSeverities,
                "getCurrentTime": getCurrentTime,
                "trimSpaces":     trimSpaces,
                "toString":       toString,
        }
)

func toString(value interface{}) string <span class="cov1" title="1">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                return v</span>
        case int:<span class="cov0" title="0">
                return strconv.Itoa(v)</span>
        default:<span class="cov1" title="1">
                return fmt.Sprintf("%v", v)</span>
        }
}

func trimSpaces(value string) string <span class="cov0" title="0">{
        return strings.TrimPrefix(value, " ")
}</span>

func getSeverities(severity string) model.Severity <span class="cov7" title="4">{
        return stringsSeverity[severity]
}</span>

func getCurrentTime() string <span class="cov1" title="1">{
        dt := time.Now()
        return fmt.Sprint(dt.Format("01/02/2006 15:04"))
}</span>

func fileCreationReport(path, filename string) <span class="cov10" title="6">{
        log.Info().Str("fileName", filename).Msgf("Results saved to file %s", path)
        fmt.Printf("Results saved to file %s\n", path)
}</span>

func closeFile(path, filename string, file *os.File) <span class="cov7" title="4">{
        err := file.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Err(err).Msgf("Failed to close file %s", path)
        }</span>

        <span class="cov7" title="4">fileCreationReport(path, filename)</span>
}

func getPlatforms(queries model.VulnerableQuerySlice) string <span class="cov6" title="3">{
        platforms := make([]string, 0)
        alreadyAdded := make(map[string]string)
        for idx := range queries </span><span class="cov6" title="3">{
                if _, ok := alreadyAdded[queries[idx].Platform]; !ok </span><span class="cov6" title="3">{
                        alreadyAdded[queries[idx].Platform] = ""
                        platforms = append(platforms, queries[idx].Platform)
                }</span>
        }
        <span class="cov6" title="3">return strings.Join(platforms, ", ")</span>
}

// ExportJSONReport - encodes a given body to a JSON file in a given filepath
func ExportJSONReport(path, filename string, body interface{}) error <span class="cov6" title="3">{
        if !strings.Contains(filename, ".") </span><span class="cov1" title="1">{
                filename += jsonExtension
        }</span>
        <span class="cov6" title="3">fullPath := filepath.Join(path, filename)

        f, err := os.OpenFile(filepath.Clean(fullPath), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="3">defer closeFile(fullPath, filename, f)

        encoder := json.NewEncoder(f)
        encoder.SetIndent("", "\t")

        return encoder.Encode(body)</span>
}

func getSummary(body interface{}) (sum model.Summary, err error) <span class="cov6" title="3">{
        var summary model.Summary
        result, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return model.Summary{}, err
        }</span>
        <span class="cov6" title="3">if err := json.Unmarshal(result, &amp;summary); err != nil </span><span class="cov0" title="0">{
                return model.Summary{}, err
        }</span>

        <span class="cov6" title="3">return summary, nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/pkg/report/model"
)

// PrintGitlabSASTReport creates a report file on sarif format
func PrintGitlabSASTReport(path, filename string, body interface{}) error <span class="cov1" title="1">{
        filename = strings.ReplaceAll(filename, ".glsast", "")
        if !strings.HasSuffix(filename, jsonExtension) </span><span class="cov1" title="1">{
                filename += jsonExtension
        }</span>
        <span class="cov1" title="1">if !strings.HasPrefix(filename, "gl-sast-") </span><span class="cov1" title="1">{
                filename = "gl-sast-" + filename
        }</span>
        <span class="cov1" title="1">if body != "" </span><span class="cov1" title="1">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov1" title="1">gitlabSASTReport := reportModel.NewGitlabSASTReport(summary.Times.Start, summary.Times.End)

                for idxQuery := range summary.Queries </span><span class="cov1" title="1">{
                        for idxFile := range summary.Queries[idxQuery].Files </span><span class="cov10" title="2">{
                                gitlabSASTReport.BuildGitlabSASTVulnerability(&amp;summary.Queries[idxQuery], &amp;summary.Queries[idxQuery].Files[idxFile])
                        }</span>
                }
                <span class="cov1" title="1">body = gitlabSASTReport</span>
        }

        <span class="cov1" title="1">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package report

import (
        "bytes"
        _ "embed" // used for embedding report static files
        "html/template"
        "os"
        "path/filepath"
        "strings"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/tdewolff/minify/v2"
        minifyCSS "github.com/tdewolff/minify/v2/css"
        minifyHtml "github.com/tdewolff/minify/v2/html"
        minifyJS "github.com/tdewolff/minify/v2/js"
)

var (
        //go:embed template/html/report.tmpl
        htmlTemplate string
        //go:embed template/html/report.css
        cssTemplate string
        //go:embed template/html/report.js
        jsTemplate string
        //go:embed template/html/github.svg
        githubSVG string
        //go:embed template/html/info.svg
        infoSVG string
        //go:embed template/html/vulnerability_fill.svg
        vulnerabilityFillSVG string
        //go:embed template/html/vulnerability_out.svg
        vulnerabilityOutSVG string
)

const (
        textHTML = "text/html"
)

var svgMap = map[string]string{
        "github.svg":             githubSVG,
        "info.svg":               infoSVG,
        "vulnerability_fill.svg": vulnerabilityFillSVG,
        "vulnerability_out.svg":  vulnerabilityOutSVG,
}

func includeSVG(name string) template.HTML <span class="cov10" title="7">{
        return template.HTML(svgMap[name]) //nolint
}</span>

func includeCSS(name string) template.HTML <span class="cov1" title="1">{
        minifier := minify.New()
        minifier.AddFunc("text/css", minifyCSS.Minify)
        cssMinified, err := minifier.String("text/css", cssTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">return template.HTML("&lt;style&gt;" + cssMinified + "&lt;/style&gt;")</span> //nolint
}

func includeJS(name string) template.HTML <span class="cov1" title="1">{
        minifier := minify.New()
        minifier.AddFunc("text/javascript", minifyJS.Minify)
        jsMinified, err := minifier.String("text/javascript", jsTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov1" title="1">return template.HTML("&lt;script&gt;" + jsMinified + "&lt;/script&gt;")</span> //nolint
}

func getPaths(paths []string) string <span class="cov1" title="1">{
        return strings.Join(paths, ", ")
}</span>

func getVersion() string <span class="cov1" title="1">{
        return constants.Version
}</span>

// PrintHTMLReport creates a report file on HTML format
func PrintHTMLReport(path, filename string, body interface{}) error <span class="cov1" title="1">{
        if !strings.HasSuffix(filename, ".html") </span><span class="cov1" title="1">{
                filename += ".html"
        }</span>

        <span class="cov1" title="1">templateFuncs["includeSVG"] = includeSVG
        templateFuncs["includeCSS"] = includeCSS
        templateFuncs["includeJS"] = includeJS
        templateFuncs["getPaths"] = getPaths
        templateFuncs["getPlatforms"] = getPlatforms
        templateFuncs["getVersion"] = getVersion

        fullPath := filepath.Join(path, filename)
        t := template.Must(template.New("report.tmpl").Funcs(templateFuncs).Parse(htmlTemplate))

        f, err := os.OpenFile(filepath.Clean(fullPath), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer closeFile(fullPath, filename, f)
        var buffer bytes.Buffer

        err = t.Execute(&amp;buffer, body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">minifier := minify.New()
        minifier.AddFunc(textHTML, minifyHtml.Minify)
        minifier.Add(textHTML, &amp;minifyHtml.Minifier{
                KeepDocumentTags: true,
                KeepEndTags:      true,
                KeepQuotes:       true,
        })

        minifierWriter := minifier.Writer(textHTML, f)
        defer minifierWriter.Close()

        _, err = minifierWriter.Write(buffer.Bytes())
        return err</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package report

import "github.com/Checkmarx/kics/internal/constants"

const jsonExtension = ".json"

// PrintJSONReport prints on JSON file the summary results
func PrintJSONReport(path, filename string, body interface{}) error <span class="cov8" title="1">{
        if body != "" </span><span class="cov8" title="1">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for idx := range summary.Queries </span><span class="cov8" title="1">{
                        summary.Queries[idx].CISBenchmarkName = ""
                        summary.Queries[idx].CISBenchmarkVersion = ""
                        summary.Queries[idx].CISDescriptionID = ""
                        summary.Queries[idx].CISDescriptionText = ""
                        summary.Queries[idx].CISRationaleText = ""
                }</span>
                <span class="cov8" title="1">summary.Version = constants.Version
                body = summary</span>
        }

        <span class="cov8" title="1">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package model

import (
        "fmt"
        "strings"
        "time"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
)

const timeFormat = "2006-01-02T15:04:05" // YYYY-MM-DDTHH:MM:SS a.k.a ISO8601

type gitlabSASTReport struct {
        Schema          string                    `json:"schema"`
        SchemaVersion   string                    `json:"version"`
        Scan            gitlabSASTScan            `json:"scan"`
        Vulnerabilities []gitlabSASTVulnerability `json:"vulnerabilities"`
}

type gitlabSASTScan struct {
        StartTime string            `json:"start_time"`
        EndTime   string            `json:"end_time"`
        Status    string            `json:"status"`
        Scantype  string            `json:"type"`
        Scanner   gitlabSASTScanner `json:"scanner"`
}

type gitlabSASTScanner struct {
        ID      string                  `json:"id"`
        Name    string                  `json:"name"`
        URL     string                  `json:"url"`
        Version string                  `json:"version"`
        Vendor  gitlabSASTScannerVendor `json:"vendor"`
}

type gitlabSASTScannerVendor struct {
        Name string `json:"name"`
}

type gitlabSASTVulnerabilityDetails map[string]interface{}

type gitlabSASTVulnerability struct {
        ID          string                              `json:"id"`
        Category    string                              `json:"category"`
        Severity    string                              `json:"severity"`
        CVE         string                              `json:"cve"`
        Scanner     gitlabSASTVulnerabilityScanner      `json:"scanner"`
        Name        string                              `json:"name"`
        Message     string                              `json:"message"`
        Links       []gitlabSASTVulnerabilityLink       `json:"links"`
        Location    gitlabSASTVulnerabilityLocation     `json:"location"`
        Identifiers []gitlabSASTVulnerabilityIdentifier `json:"identifiers"`
        Details     gitlabSASTVulnerabilityDetails      `json:"details,omitempty"`
}

type gitlabSASTVulnerabilityScanner struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

type gitlabSASTVulnerabilityLink struct {
        URL string `json:"url"`
}

type gitlabSASTVulnerabilityLocation struct {
        File  string `json:"file"`
        Start int    `json:"start_line"`
        End   int    `json:"end_line"`
}

type gitlabSASTVulnerabilityIdentifier struct {
        IdentifierType string `json:"type"`
        Name           string `json:"name"`
        URL            string `json:"url"`
        Value          string `json:"value"`
}

// GitlabSASTReport represents a usable gitlab sast report reference
type GitlabSASTReport interface {
        BuildGitlabSASTVulnerability(issue *model.VulnerableQuery, file *model.VulnerableFile)
}

// NewGitlabSASTReport initializes a new instance of GitlabSASTReport to be uses
func NewGitlabSASTReport(start, end time.Time) GitlabSASTReport <span class="cov10" title="3">{
        return &amp;gitlabSASTReport{
                Schema:          "https://gitlab.com/gitlab-org/security-products/security-report-schemas/-/raw/v13.1.0/dist/sast-report-format.json",
                SchemaVersion:   "13.1.0",
                Scan:            initGitlabSASTScan(start, end),
                Vulnerabilities: make([]gitlabSASTVulnerability, 0),
        }
}</span>

func initGitlabSASTScan(start, end time.Time) gitlabSASTScan <span class="cov10" title="3">{
        return gitlabSASTScan{
                Status:    "success",
                Scantype:  "sast",
                StartTime: start.Format(timeFormat),
                EndTime:   end.Format(timeFormat),
                Scanner: gitlabSASTScanner{
                        ID:   "keeping-infrastructure-as-code-secure",
                        Name: constants.Fullname,
                        URL:  constants.URL,
                        Vendor: gitlabSASTScannerVendor{
                                Name: "Checkmarx",
                        },
                        Version: constants.Version,
                },
        }
}</span>

// BuildGitlabSASTVulnerability adds a new vulnerability struct to vulnerability slice
func (glsr *gitlabSASTReport) BuildGitlabSASTVulnerability(issue *model.VulnerableQuery, file *model.VulnerableFile) <span class="cov6" title="2">{
        if len(issue.Files) &gt; 0 </span><span class="cov1" title="1">{
                vulnerability := gitlabSASTVulnerability{
                        ID:       file.SimilarityID,
                        Category: "sast",
                        Severity: strings.Title(strings.ToLower(string(issue.Severity))),
                        CVE:      file.SimilarityID,
                        Scanner: gitlabSASTVulnerabilityScanner{
                                ID:   "keeping_infrastructure_as_code_secure",
                                Name: constants.Fullname,
                        },
                        Name:    issue.QueryName,
                        Message: issue.Description,
                        Links: []gitlabSASTVulnerabilityLink{
                                {
                                        URL: issue.QueryURI,
                                },
                        },
                        Location: gitlabSASTVulnerabilityLocation{
                                File:  file.FileName,
                                Start: file.Line,
                                End:   file.Line,
                        },
                        Identifiers: []gitlabSASTVulnerabilityIdentifier{
                                {
                                        IdentifierType: "kics",
                                        Name:           constants.Fullname,
                                        URL:            fmt.Sprintf("https://docs.kics.io/latest/queries/%s-queries", strings.ToLower(issue.Platform)),
                                        Value:          issue.QueryID,
                                },
                        },
                }
                if issue.CISDescriptionID != "" </span><span class="cov0" title="0">{
                        vulnerability.Message = issue.CISDescriptionTextFormatted
                        vulnerability.Details = gitlabSASTVulnerabilityDetails{
                                "cisTitle": issue.CISDescriptionTitle,
                                "cisId":    issue.CISDescriptionIDFormatted,
                        }
                }</span>
                <span class="cov1" title="1">glsr.Vulnerabilities = append(glsr.Vulnerabilities, vulnerability)</span>
        }
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package model

import (
        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

var categoriesNotFound = make(map[string]bool)

var severityLevelEquivalence = map[model.Severity]string{
        "INFO":   "none",
        "LOW":    "note",
        "MEDIUM": "warning",
        "HIGH":   "error",
}

var targetTemplate = sarifDescriptorReference{
        ToolComponent: sarifComponentReference{
                ComponentReferenceGUID:  "58cdcc6f-fe41-4724-bfb3-131a93df4c3f",
                ComponentReferenceName:  "Categories",
                ComponentReferenceIndex: 0,
        },
}

type sarifProperties map[string]interface{}

type ruleMetadata struct {
        queryID          string
        queryName        string
        queryDescription string
        queryURI         string
        queryCategory    string
        severity         model.Severity
}

type ruleCISMetadata struct {
        descriptionText string
        id              string
        title           string
}

type sarifMessage struct {
        Text string `json:"text"`
}

type sarifComponentReference struct {
        ComponentReferenceName  string `json:"name"`
        ComponentReferenceGUID  string `json:"guid"`
        ComponentReferenceIndex int    `json:"index"`
}

type sarifDescriptorReference struct {
        ReferenceID    string                  `json:"id"`
        ReferenceIndex int                     `json:"index"`
        ToolComponent  sarifComponentReference `json:"toolComponent"`
}

type sarifDescriptorRelationship struct {
        Target sarifDescriptorReference `json:"target"`
}

type sarifConfiguration struct {
        Level string `json:"level"`
}

type sarifRule struct {
        RuleID               string                        `json:"id"`
        RuleName             string                        `json:"name"`
        RuleShortDescription sarifMessage                  `json:"shortDescription"`
        RuleFullDescription  sarifMessage                  `json:"fullDescription"`
        DefaultConfiguration sarifConfiguration            `json:"defaultConfiguration"`
        HelpURI              string                        `json:"helpUri"`
        RuleRelationships    []sarifDescriptorRelationship `json:"relationships"`
        RuleProperties       sarifProperties               `json:"properties,omitempty"`
}

type sarifDriver struct {
        ToolName     string      `json:"name"`
        ToolVersion  string      `json:"version"`
        ToolFullName string      `json:"fullName"`
        ToolURI      string      `json:"informationUri"`
        Rules        []sarifRule `json:"rules"`
}

type sarifTool struct {
        Driver sarifDriver `json:"driver"`
}

type sarifRegion struct {
        StartLine int `json:"startLine"`
}

type sarifArtifactLocation struct {
        ArtifactURI string `json:"uri"`
}

type sarifPhysicalLocation struct {
        ArtifactLocation sarifArtifactLocation `json:"artifactLocation"`
        Region           sarifRegion           `json:"region"`
}

type sarifLocation struct {
        PhysicalLocation sarifPhysicalLocation `json:"physicalLocation"`
}

type sarifResult struct {
        ResultRuleID    string          `json:"ruleId"`
        ResultRuleIndex int             `json:"ruleIndex"`
        ResultKind      string          `json:"kind"`
        ResultMessage   sarifMessage    `json:"message"`
        ResultLocations []sarifLocation `json:"locations"`
}

type sarifTaxanomyDefinition struct {
        DefinitionID               string       `json:"id"`
        DefinitionName             string       `json:"name"`
        DefinitionShortDescription sarifMessage `json:"shortDescription"`
        DefinitionFullDescription  sarifMessage `json:"fullDescription"`
}

type sarifTaxonomy struct {
        TaxonomyGUID             string                    `json:"guid"`
        TaxonomyName             string                    `json:"name"`
        TaxonomyFullDescription  sarifMessage              `json:"fullDescription"`
        TaxonomyShortDescription sarifMessage              `json:"shortDescription"`
        TaxonomyDefinitions      []sarifTaxanomyDefinition `json:"taxa"`
}

// SarifRun - sarifRun is a component of the SARIF report
type SarifRun struct {
        Tool       sarifTool       `json:"tool"`
        Results    []sarifResult   `json:"results"`
        Taxonomies []sarifTaxonomy `json:"taxonomies"`
}

// SarifReport represents a usable sarif report reference
type SarifReport interface {
        BuildSarifIssue(issue *model.VulnerableQuery)
}

type sarifReport struct {
        Schema       string     `json:"$schema"`
        SarifVersion string     `json:"version"`
        Runs         []SarifRun `json:"runs"`
}

func initSarifTool() sarifTool <span class="cov4" title="5">{
        return sarifTool{
                Driver: sarifDriver{
                        ToolName:     "KICS",
                        ToolVersion:  constants.Version,
                        ToolFullName: constants.Fullname,
                        ToolURI:      constants.URL,
                        Rules:        make([]sarifRule, 0),
                },
        }
}</span>

func initSarifCategories() []sarifTaxanomyDefinition <span class="cov4" title="5">{
        allCategories := []sarifTaxanomyDefinition{noCategory}
        for _, category := range categories </span><span class="cov10" title="70">{
                allCategories = append(allCategories, category)
        }</span>
        <span class="cov4" title="5">return allCategories</span>
}

func initSarifTaxonomies() []sarifTaxonomy <span class="cov4" title="5">{
        return []sarifTaxonomy{
                {
                        TaxonomyGUID: targetTemplate.ToolComponent.ComponentReferenceGUID,
                        TaxonomyName: targetTemplate.ToolComponent.ComponentReferenceName,
                        TaxonomyShortDescription: sarifMessage{
                                Text: "Vulnerabilities categories",
                        },
                        TaxonomyFullDescription: sarifMessage{
                                Text: "This taxonomy contains the types an issue can assume",
                        },
                        TaxonomyDefinitions: initSarifCategories(),
                },
        }
}</span>

func initSarifRun() []SarifRun <span class="cov4" title="5">{
        return []SarifRun{
                {
                        Tool:       initSarifTool(),
                        Results:    make([]sarifResult, 0),
                        Taxonomies: initSarifTaxonomies(),
                },
        }
}</span>

// NewSarifReport creates and start a new sarif report with default values respecting SARIF schema 2.1.0
func NewSarifReport() SarifReport <span class="cov3" title="4">{
        return &amp;sarifReport{
                Schema:       "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
                SarifVersion: "2.1.0",
                Runs:         initSarifRun(),
        }
}</span>

func (sr *sarifReport) findSarifCategory(category string) int <span class="cov3" title="3">{
        for idx, taxonomy := range sr.Runs[0].Taxonomies[0].TaxonomyDefinitions </span><span class="cov9" title="45">{
                if taxonomy.DefinitionName == category </span><span class="cov0" title="0">{
                        return idx
                }</span>
        }
        <span class="cov3" title="3">return 0</span>
}

func (sr *sarifReport) buildSarifCategory(category string) sarifDescriptorReference <span class="cov3" title="3">{
        target := targetTemplate
        categoryIndex := sr.findSarifCategory(category)
        target.ReferenceIndex = categoryIndex
        target.ReferenceID = sr.Runs[0].Taxonomies[0].TaxonomyDefinitions[categoryIndex].DefinitionID
        if categoryIndex == 0 </span><span class="cov3" title="3">{
                if _, exists := categoriesNotFound[category]; !exists </span><span class="cov2" title="2">{
                        log.Warn().Msgf("Category %s not found.", category)
                        categoriesNotFound[category] = true
                }</span>
        }
        <span class="cov3" title="3">return target</span>
}

func (sr *sarifReport) findSarifRuleIndex(ruleID string) int <span class="cov3" title="4">{
        for idx := range sr.Runs[0].Tool.Driver.Rules </span><span class="cov2" title="2">{
                if sr.Runs[0].Tool.Driver.Rules[idx].RuleID == ruleID </span><span class="cov1" title="1">{
                        return idx
                }</span>
        }
        <span class="cov3" title="3">return -1</span>
}

func (sr *sarifReport) buildSarifRule(queryMetadata *ruleMetadata, cisMetadata ruleCISMetadata) int <span class="cov3" title="4">{
        index := sr.findSarifRuleIndex(queryMetadata.queryID)
        if index &lt; 0 </span><span class="cov3" title="3">{
                helpURI := "https://docs.kics.io/"
                if queryMetadata.queryURI != "" </span><span class="cov3" title="3">{
                        helpURI = queryMetadata.queryURI
                }</span>
                <span class="cov3" title="3">rule := sarifRule{
                        RuleID:               queryMetadata.queryID,
                        RuleName:             queryMetadata.queryName,
                        RuleShortDescription: sarifMessage{Text: queryMetadata.queryName},
                        RuleFullDescription:  sarifMessage{Text: queryMetadata.queryDescription},
                        DefaultConfiguration: sarifConfiguration{Level: severityLevelEquivalence[queryMetadata.severity]},
                        RuleRelationships:    []sarifDescriptorRelationship{{Target: sr.buildSarifCategory(queryMetadata.queryCategory)}},
                        HelpURI:              helpURI,
                        RuleProperties:       nil,
                }
                if cisMetadata.id != "" </span><span class="cov0" title="0">{
                        rule.RuleFullDescription.Text = cisMetadata.descriptionText
                        rule.RuleProperties = sarifProperties{
                                "cisId":    cisMetadata.id,
                                "cisTitle": cisMetadata.title,
                        }
                }</span>

                <span class="cov3" title="3">sr.Runs[0].Tool.Driver.Rules = append(sr.Runs[0].Tool.Driver.Rules, rule)
                index = len(sr.Runs[0].Tool.Driver.Rules) - 1</span>
        }
        <span class="cov3" title="4">return index</span>
}

// BuildSarifIssue creates a new entries in Results (one for each file) and new entry in Rules and Taxonomy if necessary
func (sr *sarifReport) BuildSarifIssue(issue *model.VulnerableQuery) <span class="cov4" title="5">{
        if len(issue.Files) &gt; 0 </span><span class="cov3" title="4">{
                metadata := ruleMetadata{
                        queryID:          issue.QueryID,
                        queryName:        issue.QueryName,
                        queryDescription: issue.Description,
                        queryURI:         issue.QueryURI,
                        queryCategory:    issue.Category,
                        severity:         issue.Severity,
                }
                cisDescriptions := ruleCISMetadata{
                        id:              issue.CISDescriptionIDFormatted,
                        title:           issue.CISDescriptionTitle,
                        descriptionText: issue.CISDescriptionTextFormatted,
                }
                ruleIndex := sr.buildSarifRule(&amp;metadata, cisDescriptions)

                kind := "fail"
                if severityLevelEquivalence[issue.Severity] == "none" </span><span class="cov1" title="1">{
                        kind = "informational"
                }</span>
                <span class="cov3" title="4">for idx := range issue.Files </span><span class="cov3" title="4">{
                        result := sarifResult{
                                ResultRuleID:    issue.QueryID,
                                ResultRuleIndex: ruleIndex,
                                ResultKind:      kind,
                                ResultMessage:   sarifMessage{Text: issue.Files[idx].KeyActualValue},
                                ResultLocations: []sarifLocation{
                                        {
                                                PhysicalLocation: sarifPhysicalLocation{
                                                        ArtifactLocation: sarifArtifactLocation{ArtifactURI: issue.Files[idx].FileName},
                                                        Region:           sarifRegion{StartLine: issue.Files[idx].Line},
                                                },
                                        },
                                },
                        }
                        sr.Runs[0].Results = append(sr.Runs[0].Results, result)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package model

const categoryIdentifier = "CAT"

var noCategory = sarifTaxanomyDefinition{
        DefinitionID:               categoryIdentifier + "000",
        DefinitionName:             "Undefined Category",
        DefinitionShortDescription: sarifMessage{Text: "Category is not defined"},
        DefinitionFullDescription:  sarifMessage{Text: "Category is not defined"},
}

func createSarifCategory(identifier, name, description string) sarifTaxanomyDefinition <span class="cov10" title="14">{
        return sarifTaxanomyDefinition{
                DefinitionID:   identifier,
                DefinitionName: name,
                DefinitionShortDescription: sarifMessage{
                        Text: description,
                },
                DefinitionFullDescription: sarifMessage{
                        Text: description,
                },
        }
}</span>

var categories = map[string]sarifTaxanomyDefinition{
        "Access Control": createSarifCategory(categoryIdentifier+"001", "Access Control", "Service permission and identity management"),
        "Availability":   createSarifCategory(categoryIdentifier+"002", "Availability", "Reliability and Scalability"),
        "Backup":         createSarifCategory(categoryIdentifier+"003", "Backup", "Survivability and Recovery"),
        "Best Practices": createSarifCategory(categoryIdentifier+"004", "Best Practices", "Metadata management"),
        "Build Process": createSarifCategory(
                categoryIdentifier+"005",
                "Build Process",
                "Insecure configurations when building/deploying",
        ),
        "Encryption": createSarifCategory(categoryIdentifier+"006", "Encryption", "Data Security and Encryption configuration"),
        "Insecure Configurations": createSarifCategory(
                categoryIdentifier+"007",
                "Insecure Configurations",
                "Configurations which expose the application unnecessarily",
        ),
        "Insecure Defaults": createSarifCategory(
                categoryIdentifier+"008",
                "Insecure Defaults",
                "Configurations that are insecure by default",
        ),
        "Networking and Firewall": createSarifCategory(
                categoryIdentifier+"009",
                "Networking and Firewall",
                "Network port exposure and firewall configuration",
        ),
        "Observability": createSarifCategory(categoryIdentifier+"010", "Observability", "Logging and Monitoring"),
        "Resource Management": createSarifCategory(
                categoryIdentifier+"011",
                "Resource Management",
                "Resource and privilege limit configuration",
        ),
        "Secret Management": createSarifCategory(categoryIdentifier+"012", "Secret Management", "Secret and Key management"),
        "Supply-Chain":      createSarifCategory(categoryIdentifier+"013", "Supply-Chain", "Dependency version management"),
        "Structure and Semantics": createSarifCategory(
                categoryIdentifier+"014",
                "Structure and Semantics",
                "Malformed document structure or inadequate semantics",
        ),
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package report

import (
        _ "embed" // used for embedding report static files
        "fmt"
        "path/filepath"
        "time"

        "github.com/Checkmarx/kics/internal/constants"
        "github.com/Checkmarx/kics/pkg/model"
        "github.com/johnfercher/maroto/pkg/color"
        "github.com/johnfercher/maroto/pkg/consts"
        "github.com/johnfercher/maroto/pkg/pdf"
        "github.com/johnfercher/maroto/pkg/props"
        "github.com/rs/zerolog/log"
)

const (
        defaultTextSize = 8
        pgMarginLeft    = 10
        pgMarginTop     = 15
        pgMarginRight   = 10
        rowXSmall       = 3
        rowSmall        = 4
        rowMedium       = 5
        rowLarge        = 8
        rowXLarge       = 15
        colOne          = 1
        colTwo          = 2
        colThree        = 3
        colFour         = 4
        colFive         = 5
        colSix          = 6
        colEight        = 8
        colNine         = 9
        colTen          = 10
        colFullPage     = 12
        colRuneSlitter  = 38
)

var (
        grayColor = getGrayColor()
        //go:embed assets/vuln
        vulnImageBase64 string
)

const (
        textSize = 10
)

func createQueryEntryMetadataField(m pdf.Maroto, label, value string, textSize int) <span class="cov8" title="6">{
        m.Col(colTwo, func() </span><span class="cov8" title="6">{
                m.Text(label, props.Text{
                        Size:        float64(textSize),
                        Align:       consts.Left,
                        Extrapolate: false,
                })
        }</span>)
        <span class="cov8" title="6">m.Col(colTwo, func() </span><span class="cov8" title="6">{
                m.Text(value, props.Text{
                        Size:        float64(textSize),
                        Align:       consts.Left,
                        Extrapolate: false,
                })
        }</span>)
}

func createQueriesTable(m pdf.Maroto, queries []model.VulnerableQuery) error <span class="cov4" title="2">{
        for i := range queries </span><span class="cov4" title="2">{
                m.SetBackgroundColor(color.NewWhite())
                queryName := queries[i].QueryName
                resultsCount := fmt.Sprint(len(queries[i].Files))
                severity := string(queries[i].Severity)
                platform := queries[i].Platform
                category := queries[i].Category
                var err error
                m.Row(rowLarge, func() </span><span class="cov4" title="2">{
                        m.Col(colOne, func() </span><span class="cov4" title="2">{
                                err = m.Base64Image(vulnImageBase64, consts.Png, props.Rect{
                                        Center:  false,
                                        Percent: 50,
                                        Left:    2,
                                })
                        }</span>)
                        <span class="cov4" title="2">m.Col(colNine, func() </span><span class="cov4" title="2">{
                                m.Text(queryName, props.Text{
                                        Size:        11,
                                        Style:       consts.Bold,
                                        Align:       consts.Left,
                                        Extrapolate: false,
                                })
                        }</span>)
                        <span class="cov4" title="2">m.Col(colOne, func() </span><span class="cov4" title="2">{
                                m.Text("Results", props.Text{
                                        Size:        8,
                                        Style:       consts.Bold,
                                        Align:       consts.Right,
                                        Extrapolate: false,
                                })
                        }</span>)
                        <span class="cov4" title="2">m.Col(colOne, func() </span><span class="cov4" title="2">{
                                m.Text(resultsCount, props.Text{
                                        Size:        8,
                                        Style:       consts.Bold,
                                        Align:       consts.Right,
                                        Extrapolate: false,
                                })
                        }</span>)
                })
                <span class="cov4" title="2">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="2">m.Row(colFour, func() </span><span class="cov4" title="2">{
                        createQueryEntryMetadataField(m, "Severity", severity, textSize)
                }</span>)
                <span class="cov4" title="2">m.Row(colThree, func() </span><span class="cov4" title="2">{
                        createQueryEntryMetadataField(m, "Platform", platform, defaultTextSize)
                }</span>)
                <span class="cov4" title="2">m.Row(colFive, func() </span><span class="cov4" title="2">{
                        createQueryEntryMetadataField(m, "Category", category, defaultTextSize)
                }</span>)
                <span class="cov4" title="2">if queries[i].CISDescriptionID != "" </span><span class="cov0" title="0">{
                        createCISRows(m, &amp;queries[i])
                }</span>
                <span class="cov4" title="2">createResultsTable(m, &amp;queries[i])</span>
        }
        <span class="cov4" title="2">return nil</span>
}

func createCISRows(m pdf.Maroto, query *model.VulnerableQuery) <span class="cov0" title="0">{
        cisID := query.CISDescriptionIDFormatted
        description := query.CISDescriptionTextFormatted
        title := query.CISDescriptionTitle

        m.Row(colFive, func() </span><span class="cov0" title="0">{
                m.Col(colTwo, func() </span><span class="cov0" title="0">{
                        m.Text("CIS ID", props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov0" title="0">m.Col(colEight, func() </span><span class="cov0" title="0">{
                        m.Text(cisID, props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov0" title="0">m.Row(colFive, func() </span><span class="cov0" title="0">{
                m.Col(colTwo, func() </span><span class="cov0" title="0">{
                        m.Text("Title", props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov0" title="0">m.Col(colEight, func() </span><span class="cov0" title="0">{
                        m.Text(title, props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov0" title="0">m.Row(colFive, func() </span><span class="cov0" title="0">{
                m.Col(colTwo, func() </span><span class="cov0" title="0">{
                        m.Text("Description", props.Text{
                                Size:        float64(textSize),
                                Align:       consts.Left,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov0" title="0">m.Row(getRowLength(description), func() </span><span class="cov0" title="0">{
                m.Col(colFullPage, func() </span><span class="cov0" title="0">{
                        m.Text(description, props.Text{
                                Size:        float64(defaultTextSize),
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
}

func getRowLength(value string) float64 <span class="cov0" title="0">{
        length := len(value)
        return float64(length / colRuneSlitter)
}</span>

func createResultsTable(m pdf.Maroto, query *model.VulnerableQuery) <span class="cov4" title="2">{
        for idx := range query.Files </span><span class="cov7" title="4">{
                if idx%2 == 0 </span><span class="cov4" title="2">{
                        m.SetBackgroundColor(grayColor)
                }</span> else<span class="cov4" title="2"> {
                        m.SetBackgroundColor(color.NewWhite())
                }</span>

                <span class="cov7" title="4">filePath := query.Files[idx].FileName
                fileLine := fmt.Sprintf("%s:%s", filePath, fmt.Sprint(query.Files[idx].Line))
                m.Row(colFive, func() </span><span class="cov7" title="4">{
                        m.Col(colFullPage, func() </span><span class="cov7" title="4">{
                                m.Text(fileLine, props.Text{
                                        Size:        defaultTextSize,
                                        Align:       consts.Left,
                                        Extrapolate: false,
                                })
                        }</span>)
                })
        }
        <span class="cov4" title="2">m.SetBackgroundColor(color.NewWhite())
        m.Line(1.0)</span>
}

func createHeaderArea(m pdf.Maroto) <span class="cov4" title="2">{
        m.SetBackgroundColor(getPurpleColor())
        m.Row(rowXLarge, func() </span><span class="cov4" title="2">{
                m.Col(colSix, func() </span><span class="cov4" title="2">{
                        m.Text(" KICS REPORT", props.Text{
                                Size:        25,
                                Style:       consts.Bold,
                                Align:       consts.Left,
                                Extrapolate: false,
                                Color:       color.NewWhite(),
                        })
                }</span>)
                <span class="cov4" title="2">m.Col(colSix, func() </span><span class="cov4" title="2">{
                        m.Text(fmt.Sprintf("v%s ", constants.Version), props.Text{
                                Size:        25,
                                Style:       consts.Bold,
                                Align:       consts.Right,
                                Extrapolate: false,
                                Color:       color.NewWhite(),
                        })
                }</span>)
        })
        <span class="cov4" title="2">m.SetBackgroundColor(color.NewWhite())
        m.Row(rowXSmall, func() </span><span class="cov4" title="2">{
                m.ColSpace(colFullPage)
        }</span>)
}

func createFooterArea(m pdf.Maroto) <span class="cov7" title="4">{
        m.Row(rowMedium, func() </span><span class="cov4" title="2">{
                m.Col(colOne, func() </span><span class="cov4" title="2">{
                        m.Text("https://kics.io")
                }</span>)
        })
}

// PrintPdfReport creates a report file on the PDF format
func PrintPdfReport(path, filename string, body interface{}) error <span class="cov4" title="2">{
        startTime := time.Now()
        log.Info().Msg("Started generating pdf report")

        summary := body.(*model.Summary)

        m := pdf.NewMaroto(consts.Portrait, consts.A4)
        m.SetPageMargins(pgMarginLeft, pgMarginTop, pgMarginRight)

        m.SetFirstPageNb(1)
        m.SetAliasNbPages("{total}")

        m.RegisterHeader(func() </span><span class="cov4" title="2">{
                createHeaderArea(m)
        }</span>)
        <span class="cov4" title="2">m.RegisterFooter(func() </span><span class="cov7" title="4">{
                createFooterArea(m)
        }</span>)

        <span class="cov4" title="2">m.SetBackgroundColor(color.NewWhite())

        createFirstPageHeader(m, summary)

        m.Line(1.0)

        err := createQueriesTable(m, summary.Queries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">err = m.OutputFileAndClose(filepath.Join(path, fmt.Sprintf("%s.pdf", filename)))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">log.Info().Msgf("Generate report duration: %v", time.Since(startTime))

        fileCreationReport(filepath.Join(path, filename+".pdf"), filename)

        return err</span>
}

func createDateField(m pdf.Maroto, label string, summary *model.Summary) <span class="cov7" title="4">{
        m.Row(colFour, func() </span><span class="cov7" title="4">{
                m.Col(colTwo, func() </span><span class="cov7" title="4">{
                        m.Text(label, props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov7" title="4">m.Col(colTwo, func() </span><span class="cov7" title="4">{
                        m.Text(summary.Start.Format("15:04:05, Jan 02 2006"), props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
}

func createDateArea(m pdf.Maroto, summary *model.Summary) <span class="cov4" title="2">{
        createDateField(m, "START TIME", summary)
        createDateField(m, "END TIME", summary)
}</span>

func createPlatformsArea(m pdf.Maroto, summary *model.Summary) <span class="cov4" title="2">{
        m.Row(rowSmall, func() </span><span class="cov4" title="2">{
                m.Col(colTwo, func() </span><span class="cov4" title="2">{
                        m.Text("PLATFORMS", props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov4" title="2">m.Col(colTen, func() </span><span class="cov4" title="2">{
                        m.Text(getPlatforms(summary.Queries), props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
}

func createSummaryResultsField(m pdf.Maroto, label, value string, mColor color.Color) <span class="cov10" title="8">{
        m.Col(colOne, func() </span><span class="cov10" title="8">{
                m.Text(label, props.Text{
                        Size:        defaultTextSize,
                        Align:       consts.Left,
                        Style:       consts.Bold,
                        Extrapolate: false,
                        Color:       mColor,
                })
        }</span>)
        <span class="cov10" title="8">m.Col(colOne, func() </span><span class="cov10" title="8">{
                m.Text(value, props.Text{
                        Size:        defaultTextSize,
                        Align:       consts.Left,
                        Style:       consts.Bold,
                        Extrapolate: false,
                        Color:       mColor,
                })
        }</span>)
}

func createSummaryArea(m pdf.Maroto, summary *model.Summary) <span class="cov4" title="2">{
        highSeverityCount := fmt.Sprint(summary.SeverityCounters["HIGH"])
        mediumSeverityCount := fmt.Sprint(summary.SeverityCounters["MEDIUM"])
        lowSeverityCount := fmt.Sprint(summary.SeverityCounters["LOW"])
        infoSeverityCount := fmt.Sprint(summary.SeverityCounters["INFO"])
        totalCount := fmt.Sprint(summary.TotalCounter)

        m.Row(rowMedium, func() </span><span class="cov4" title="2">{
                createSummaryResultsField(m, "HIGH", highSeverityCount, getRedColor())
                createSummaryResultsField(m, "MEDIUM", mediumSeverityCount, getOrangeColor())
                createSummaryResultsField(m, "LOW", lowSeverityCount, getYellowColor())
                createSummaryResultsField(m, "INFO", infoSeverityCount, getBlueColor())

                m.ColSpace(colTwo)

                m.Col(colOne, func() </span><span class="cov4" title="2">{
                        m.Text("TOTAL", props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Right,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
                <span class="cov4" title="2">m.Col(colOne, func() </span><span class="cov4" title="2">{
                        m.Text(totalCount, props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Right,
                                Style:       consts.Bold,
                                Extrapolate: false,
                        })
                }</span>)
        })
}

func createFirstPageHeader(m pdf.Maroto, summary *model.Summary) <span class="cov4" title="2">{
        createSummaryArea(m, summary)
        createPlatformsArea(m, summary)
        createDateArea(m, summary)
        m.Row(rowSmall, func() </span><span class="cov4" title="2">{
                m.Col(colTwo, func() </span><span class="cov4" title="2">{
                        m.Text("SCANNED PATHS:", props.Text{
                                Size:        defaultTextSize,
                                Align:       consts.Left,
                                Extrapolate: false,
                        })
                }</span>)
        })
        <span class="cov4" title="2">for i := range summary.ScannedPaths </span><span class="cov4" title="2">{
                scannedPaths := summary.ScannedPaths[i]
                m.Row(rowSmall, func() </span><span class="cov4" title="2">{
                        m.Col(colFullPage, func() </span><span class="cov4" title="2">{
                                m.Text(fmt.Sprintf("- %s", scannedPaths), props.Text{
                                        Size:        defaultTextSize,
                                        Align:       consts.Left,
                                        Extrapolate: true,
                                })
                        }</span>)
                })
        }
        <span class="cov4" title="2">m.Row(rowXSmall, func() </span><span class="cov4" title="2">{
                m.ColSpace(colFullPage)
        }</span>)
}

func getGrayColor() color.Color <span class="cov1" title="1">{
        return color.Color{
                Red:   200,
                Green: 200,
                Blue:  200,
        }
}</span>

func getRedColor() color.Color <span class="cov4" title="2">{
        return color.Color{
                Red:   200,
                Green: 0,
                Blue:  0,
        }
}</span>

func getYellowColor() color.Color <span class="cov4" title="2">{
        return color.Color{
                Red:   206,
                Green: 182,
                Blue:  26,
        }
}</span>

func getOrangeColor() color.Color <span class="cov4" title="2">{
        return color.Color{
                Red:   255,
                Green: 165,
                Blue:  0,
        }
}</span>

func getBlueColor() color.Color <span class="cov4" title="2">{
        return color.Color{
                Red:   0,
                Green: 0,
                Blue:  200,
        }
}</span>

func getPurpleColor() color.Color <span class="cov4" title="2">{
        return color.Color{
                Red:   80,
                Green: 62,
                Blue:  158,
        }
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package report

import (
        "strings"

        reportModel "github.com/Checkmarx/kics/pkg/report/model"
)

// PrintSarifReport creates a report file on sarif format
func PrintSarifReport(path, filename string, body interface{}) error <span class="cov8" title="1">{
        if !strings.HasSuffix(filename, ".sarif") </span><span class="cov8" title="1">{
                filename += ".sarif"
        }</span>
        <span class="cov8" title="1">if body != "" </span><span class="cov8" title="1">{
                summary, err := getSummary(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">sarifReport := reportModel.NewSarifReport()
                for idx := range summary.Queries </span><span class="cov8" title="1">{
                        sarifReport.BuildSarifIssue(&amp;summary.Queries[idx])
                }</span>
                <span class="cov8" title="1">body = sarifReport</span>
        }

        <span class="cov8" title="1">return ExportJSONReport(path, filename, body)</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package helm

import (
        "fmt"
        "io"
        "log"
        "os"
        "strings"

        "github.com/pkg/errors"
        "helm.sh/helm/v3/pkg/action"
        "helm.sh/helm/v3/pkg/chart"
        "helm.sh/helm/v3/pkg/chart/loader"
        "helm.sh/helm/v3/pkg/chartutil"
        "helm.sh/helm/v3/pkg/cli"
        "helm.sh/helm/v3/pkg/cli/values"
        "helm.sh/helm/v3/pkg/getter"
        "helm.sh/helm/v3/pkg/release"
)

// credit: https://github.com/helm/helm

var (
        settings = cli.New()
)

func runInstall(args []string, client *action.Install,
        valueOpts *values.Options) (*release.Release, error) <span class="cov2" title="3">{
        log.SetOutput(io.Discard)
        defer log.SetOutput(os.Stderr)
        if client.Version == "" &amp;&amp; client.Devel </span><span class="cov0" title="0">{
                client.Version = "&gt;0.0.0-0"
        }</span>

        <span class="cov2" title="3">name, charts, err := client.NameAndChart(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="3">client.ReleaseName = name

        cp, err := client.ChartPathOptions.LocateChart(charts, settings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="3">p := getter.All(settings)
        vals, err := valueOpts.MergeValues(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check chart dependencies to make sure all are present in /charts
        <span class="cov2" title="3">chartRequested, err := loader.Load(cp)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="2">chartRequested = setID(chartRequested)

        if err := checkIfInstallable(chartRequested); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">client.Namespace = "kics-namespace"
        return client.Run(chartRequested, vals)</span>
}

// checkIfInstallable validates if a chart can be installed
//
// Application chart type is only installable
func checkIfInstallable(ch *chart.Chart) error <span class="cov2" title="2">{
        switch ch.Metadata.Type </span>{
        case "", "application":<span class="cov2" title="2">
                return nil</span>
        }
        <span class="cov0" title="0">return errors.Errorf("%s charts are not installable", ch.Metadata.Type)</span>
}

// newClient will create a new instance on helm client used to render the chart
func newClient() *action.Install <span class="cov2" title="3">{
        cfg := new(action.Configuration)
        client := action.NewInstall(cfg)
        client.DryRun = true
        client.ReleaseName = "kics-helm"
        client.Replace = true // Skip the name check
        client.ClientOnly = true
        client.APIVersions = chartutil.VersionSet([]string{})
        client.IncludeCRDs = false
        return client
}</span>

// setID will add auxiliary lines for each template as well as its dependencies
func setID(chartReq *chart.Chart) *chart.Chart <span class="cov2" title="3">{
        for _, temp := range chartReq.Templates </span><span class="cov4" title="9">{
                temp = addID(temp) //nolint
                if temp != nil </span><span class="cov4" title="9">{
                        continue</span>
                }
        }
        <span class="cov2" title="3">for _, dep := range chartReq.Dependencies() </span><span class="cov1" title="1">{
                dep = setID(dep) //nolint
                if dep != nil </span><span class="cov1" title="1">{
                        continue</span>
                }
        }
        <span class="cov2" title="3">return chartReq</span>
}

// addID will add auxiliary lines used to detect line
// one for each "apiVersion:" where the id will be the line
func addID(file *chart.File) *chart.File <span class="cov4" title="9">{
        split := strings.Split(string(file.Data), "\n")
        for i := 0; i &lt; len(split); i++ </span><span class="cov10" title="303">{
                if strings.Contains(split[i], "apiVersion:") </span><span class="cov2" title="3">{
                        split = append(split, "")
                        copy(split[i+1:], split[i:])
                        split[i] = fmt.Sprintf("# KICS_HELM_ID_%d:", i)
                        i++
                }</span>
        }
        <span class="cov4" title="9">file.Data = []byte(strings.Join(split, "\n"))
        return file</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package helm

import (
        "path/filepath"
        "strconv"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/pkg/errors"
        "helm.sh/helm/v3/pkg/chart"
        "helm.sh/helm/v3/pkg/cli/values"
        "helm.sh/helm/v3/pkg/release"
)

// Resolver is an instance of the helm resolver
type Resolver struct {
}

// splitManifest keeps the information of the manifest splitted by source
type splitManifest struct {
        path       string
        content    []byte
        original   []byte
        splitID    string
        splitIDMap map[int]interface{}
}

const (
        kicsHelmID = "# KICS_HELM_ID_"
)

// Resolve will render the passed helm chart and return its content ready for parsing
func (r *Resolver) Resolve(filePath string) (model.ResolvedFiles, error) <span class="cov3" title="3">{
        var rfiles = model.ResolvedFiles{}
        splits, err := renderHelm(filePath)
        if err != nil </span><span class="cov1" title="1">{ // return error to be logged
                return model.ResolvedFiles{}, errors.New("failed to render helm chart")
        }</span>
        <span class="cov2" title="2">for _, split := range *splits </span><span class="cov3" title="3">{
                origpath := filepath.Join(filepath.Dir(filePath), split.path)
                rfiles.File = append(rfiles.File, model.ResolvedFile{
                        FileName:     origpath,
                        Content:      split.content,
                        OriginalData: split.original,
                        SplitID:      split.splitID,
                        IDInfo:       split.splitIDMap,
                })
        }</span>
        <span class="cov2" title="2">return rfiles, nil</span>
}

// SupportedTypes returns the supported fileKinds for this resolver
func (r *Resolver) SupportedTypes() []model.FileKind <span class="cov1" title="1">{
        return []model.FileKind{model.KindHELM}
}</span>

// renderHelm will use helm library to render helm charts
func renderHelm(path string) (*[]splitManifest, error) <span class="cov3" title="3">{
        client := newClient()
        manifest, err := runInstall([]string{path}, client, &amp;values.Options{})
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov2" title="2">return splitManifestYAML(manifest)</span>
}

// splitManifestYAML will split the rendered file and return its content by template as well as the template path
func splitManifestYAML(template *release.Release) (*[]splitManifest, error) <span class="cov2" title="2">{
        sources := make([]*chart.File, 0)
        sources = updateName(sources, template.Chart, template.Chart.Name())
        splitedManifest := []splitManifest{}
        splitedSource := strings.Split(template.Manifest, "---") // split manifest by '---'
        origData := toMap(sources)
        for _, splited := range splitedSource </span><span class="cov4" title="5">{
                var lineID string
                for _, line := range strings.Split(splited, "\n") </span><span class="cov6" title="11">{
                        if strings.Contains(line, kicsHelmID) </span><span class="cov3" title="3">{
                                lineID = line // get auxiliary line id
                                break</span>
                        }
                }
                <span class="cov4" title="5">path := strings.Split(strings.TrimLeft(splited, "\n# Source:"), "\n") // get source of splitted yaml
                // ignore auxiliary files used to render chart
                if path[0] == "" </span><span class="cov2" title="2">{
                        continue</span>
                }
                <span class="cov3" title="3">if origData[filepath.FromSlash(path[0])] == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov3" title="3">idMap, err := getIDMap(origData[filepath.FromSlash(path[0])])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="3">splitedManifest = append(splitedManifest, splitManifest{
                        path:       path[0],
                        content:    []byte(strings.ReplaceAll(splited, "\r", "")),
                        original:   origData[filepath.FromSlash(path[0])], // get original data from template
                        splitID:    lineID,
                        splitIDMap: idMap,
                })</span>
        }
        <span class="cov2" title="2">return &amp;splitedManifest, nil</span>
}

// toMap will convert to map original data having the path as it's key
func toMap(files []*chart.File) map[string][]byte <span class="cov2" title="2">{
        mapFiles := make(map[string][]byte)
        for _, file := range files </span><span class="cov6" title="9">{
                mapFiles[file.Name] = []byte(strings.ReplaceAll(string(file.Data), "\r", ""))
        }</span>
        <span class="cov2" title="2">return mapFiles</span>
}

// updateName will update the templates name as well as its dependecies
func updateName(template []*chart.File, charts *chart.Chart, name string) []*chart.File <span class="cov3" title="3">{
        if name != charts.Name() </span><span class="cov1" title="1">{
                name = filepath.Join(name, charts.Name())
        }</span>
        <span class="cov3" title="3">for _, temp := range charts.Templates </span><span class="cov6" title="9">{
                temp.Name = filepath.Join(name, temp.Name)
        }</span>
        <span class="cov3" title="3">template = append(template, charts.Templates...)
        for _, dep := range charts.Dependencies() </span><span class="cov1" title="1">{
                template = updateName(template, dep, filepath.Join(name, "charts"))
        }</span>
        <span class="cov3" title="3">return template</span>
}

// getIdMap will construct a map with ids with the corresponding lines as keys
// for use in detector
func getIDMap(originalData []byte) (map[int]interface{}, error) <span class="cov3" title="3">{
        ids := make(map[int]interface{})
        mapLines := make(map[int]int)
        idHelm := -1
        for line, stringLine := range strings.Split(string(originalData), "\n") </span><span class="cov10" title="48">{
                if strings.Contains(stringLine, kicsHelmID) </span><span class="cov3" title="3">{
                        id, err := strconv.Atoi(strings.TrimSuffix(strings.TrimPrefix(stringLine, kicsHelmID), ":"))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov3" title="3">if idHelm == -1 </span><span class="cov3" title="3">{
                                idHelm = id
                                mapLines[line] = line
                        }</span> else<span class="cov0" title="0"> {
                                ids[idHelm] = mapLines
                                mapLines = make(map[int]int)
                                idHelm = id
                                mapLines[line] = line
                        }</span>
                } else<span class="cov9" title="45"> if idHelm != -1 </span><span class="cov9" title="44">{
                        mapLines[line] = line
                }</span>
        }
        <span class="cov3" title="3">ids[idHelm] = mapLines

        return ids, nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package resolver

import (
        "os"
        "path/filepath"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/rs/zerolog/log"
)

// kindResolver is a type of resolver interface (ex: helm resolver)
// Resolve will render file/template
// SupportedTypes will return the file kinds that the resolver supports
type kindResolver interface {
        Resolve(filePath string) (model.ResolvedFiles, error)
        SupportedTypes() []model.FileKind
}

// Resolver is a struct containing the resolvers by file kind
type Resolver struct {
        resolvers map[model.FileKind]kindResolver
}

// Builder is a struct used to create a new resolver
type Builder struct {
        resolvers []kindResolver
}

// NewBuilder creates a new Builder's reference
func NewBuilder() *Builder <span class="cov10" title="2">{
        return &amp;Builder{}
}</span>

// Add will add kindResolvers for building the resolver
func (b *Builder) Add(p kindResolver) *Builder <span class="cov10" title="2">{
        log.Debug().Msgf("resolver.Add()")
        b.resolvers = append(b.resolvers, p)
        return b
}</span>

// Build will create a new intance of a resolver
func (b *Builder) Build() (*Resolver, error) <span class="cov10" title="2">{
        log.Debug().Msg("resolver.Build()")

        resolvers := make(map[model.FileKind]kindResolver, len(b.resolvers))
        for _, resolver := range b.resolvers </span><span class="cov10" title="2">{
                for _, typeRes := range resolver.SupportedTypes() </span><span class="cov10" title="2">{
                        resolvers[typeRes] = resolver
                }</span>
        }

        <span class="cov10" title="2">return &amp;Resolver{
                resolvers: resolvers,
        }, nil</span>
}

// Resolve will resolve the files according to its type
func (r *Resolver) Resolve(filePath string, kind model.FileKind) (model.ResolvedFiles, error) <span class="cov1" title="1">{
        if r, ok := r.resolvers[kind]; ok </span><span class="cov1" title="1">{
                obj, err := r.Resolve(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return model.ResolvedFiles{}, nil
                }</span>
                <span class="cov1" title="1">log.Debug().Msgf("resolver.Resolve() rendered file: %s", filePath)
                return obj, nil</span>
        }
        // need to log here
        <span class="cov0" title="0">return model.ResolvedFiles{}, nil</span>
}

// GetType will analyze the filepath to determine which resolver to use
func (r *Resolver) GetType(filePath string) model.FileKind <span class="cov10" title="2">{
        _, err := os.Stat(filepath.Join(filePath, "Chart.yaml"))
        if err == nil </span><span class="cov1" title="1">{
                return model.KindHELM
        }</span>
        <span class="cov1" title="1">return model.KindCOMMON</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package scanner

import (
        "context"
        "fmt"
        "sync"

        "github.com/Checkmarx/kics/internal/metrics"
        "github.com/Checkmarx/kics/pkg/kics"
        "github.com/Checkmarx/kics/pkg/progress"
)

type serviceSlice []*kics.Service

func PrepareAndScan(ctx context.Context, scanID string, proBarBuilder progress.PbBuilder, services serviceSlice) error <span class="cov0" title="0">{
        metrics.Metric.Start("prepare_sources")
        var wg sync.WaitGroup
        wgDone := make(chan bool)
        errCh := make(chan error)
        var wgProg sync.WaitGroup

        for _, service := range services </span><span class="cov0" title="0">{
                wg.Add(1)
                go service.PrepareSources(ctx, scanID, &amp;wg, errCh)
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        close(wgDone)
                }</span>()
                <span class="cov0" title="0">wg.Wait()
                wgProg.Wait()</span>
        }()

        <span class="cov0" title="0">select </span>{
        case &lt;-wgDone:<span class="cov0" title="0">
                metrics.Metric.Stop()
                err := StartScan(ctx, scanID, proBarBuilder, services)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">break</span>
        case err := &lt;-errCh:<span class="cov0" title="0">
                close(errCh)
                return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// StartScan will run concurrent scans by parser
func StartScan(ctx context.Context, scanID string, proBarBuilder progress.PbBuilder, services serviceSlice) error <span class="cov1" title="1">{
        defer metrics.Metric.Stop()
        metrics.Metric.Start("start_scan")
        var wg sync.WaitGroup
        wgDone := make(chan bool)
        errCh := make(chan error)
        currentQuery := make(chan int64, 1)
        var wgProg sync.WaitGroup

        total := services.GetQueriesLength()
        if total != 0 </span><span class="cov1" title="1">{
                startProgressBar(total, &amp;wgProg, currentQuery, proBarBuilder)
        }</span>

        <span class="cov1" title="1">for _, service := range services </span><span class="cov10" title="4">{
                wg.Add(1)
                go service.StartScan(ctx, scanID, errCh, &amp;wg, currentQuery)
        }</span>

        <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                defer func() </span><span class="cov1" title="1">{
                        close(currentQuery)
                        close(wgDone)
                        fmt.Println("\r")
                }</span>()
                <span class="cov1" title="1">wg.Wait()
                wgProg.Wait()</span>
        }()

        <span class="cov1" title="1">select </span>{
        case &lt;-wgDone:<span class="cov1" title="1">
                break</span>
        case err := &lt;-errCh:<span class="cov0" title="0">
                close(errCh)
                return err</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// GetQueriesLength returns the Total of queries for all Services
func (s serviceSlice) GetQueriesLength() int <span class="cov1" title="1">{
        count := 0
        for _, service := range s </span><span class="cov10" title="4">{
                count += service.Inspector.LenQueriesByPlat(service.Parser.Platform)
                count += service.SecretsInspector.GetQueriesLength()
        }</span>
        <span class="cov1" title="1">return count</span>
}

func startProgressBar(total int, wg *sync.WaitGroup, progressChannel chan int64, proBarBuilder progress.PbBuilder) <span class="cov1" title="1">{
        wg.Add(1)
        progressBar := proBarBuilder.BuildCounter("Executing queries: ", total, wg, progressChannel)
        go progressBar.Start()
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package utils

import "sort"

// SortedKeys returns a sorted slice with all map keys
func SortedKeys(mapToSort map[string]string) []string <span class="cov1" title="1">{
        keys := make([]string, 0, len(mapToSort))
        for k := range mapToSort </span><span class="cov10" title="3">{
                keys = append(keys, k)
        }</span>
        <span class="cov1" title="1">sort.Strings(keys)
        return keys</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package test

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/Checkmarx/kics/pkg/model"
        "github.com/spf13/cobra"
)

const (
        // ValidUUIDRegex is a constant representing a regular expression rule to validate UUID string
        ValidUUIDRegex = `(?i)^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$`
        positive       = "positive.tf"
)

type execute func() error

// CaptureOutput changes default stdout to intercept into a buffer, converts it to string and returns it
func CaptureOutput(funcToExec execute) (string, error) <span class="cov0" title="0">{
        old := os.Stdout
        r, w, _ := os.Pipe()
        os.Stdout = w

        err := funcToExec()

        outC := make(chan string)

        go func() </span><span class="cov0" title="0">{
                var buf bytes.Buffer
                if _, errors := io.Copy(&amp;buf, r); errors != nil </span><span class="cov0" title="0">{ // nolint
                        return
                }</span>
                <span class="cov0" title="0">outC &lt;- buf.String()</span>
        }()

        <span class="cov0" title="0">if errors := w.Close(); errors != nil </span><span class="cov0" title="0">{
                return "", errors
        }</span>
        <span class="cov0" title="0">os.Stdout = old
        out := &lt;-outC

        return out, err</span>
}

// CaptureCommandOutput set cobra command args, if necessary, then capture the output
func CaptureCommandOutput(cmd *cobra.Command, args []string) (string, error) <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                cmd.SetArgs(args)
        }</span>

        <span class="cov0" title="0">return CaptureOutput(cmd.Execute)</span>
}

// ChangeCurrentDir gets current working directory and changes to its parent until finds the desired directory
// or fail
func ChangeCurrentDir(desiredDir string) error <span class="cov0" title="0">{
        for currentDir, err := os.Getwd(); GetCurrentDirName(currentDir) != desiredDir; currentDir, err = os.Getwd() </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        if err = os.Chdir(".."); err != nil </span><span class="cov0" title="0">{
                                fmt.Print(formatCurrentDirError(err))
                                return fmt.Errorf(formatCurrentDirError(err))
                        }</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf(formatCurrentDirError(err))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func formatCurrentDirError(err error) string <span class="cov0" title="0">{
        return fmt.Sprintf("change path error = %v", err)
}</span>

// GetCurrentDirName returns current working directory
func GetCurrentDirName(path string) string <span class="cov0" title="0">{
        dirs := strings.Split(path, string(os.PathSeparator))
        if dirs[len(dirs)-1] == "" &amp;&amp; len(dirs) &gt; 1 </span><span class="cov0" title="0">{
                return dirs[len(dirs)-2]
        }</span>
        <span class="cov0" title="0">return dirs[len(dirs)-1]</span>
}

// StringifyStruct stringify struct for pretty print
func StringifyStruct(v interface{}) (string, error) <span class="cov0" title="0">{
        jsonValue, err := json.MarshalIndent(v, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(jsonValue), nil</span>
}

// MapToStringSlice extract slice of keys from a map[string]string
func MapToStringSlice(stringKeyMap map[string]string) []string <span class="cov3" title="2">{
        keys := make([]string, len(stringKeyMap))

        i := 0
        for k := range stringKeyMap </span><span class="cov10" title="22">{
                keys[i] = k
                i++
        }</span>
        <span class="cov3" title="2">return keys</span>
}

var queryHigh = model.VulnerableQuery{
        QueryName:                   "ALB protocol is HTTP",
        QueryID:                     "de7f5e83-da88-4046-871f-ea18504b1d43",
        Description:                 "ALB protocol is HTTP Description",
        DescriptionID:               "504b1d43",
        CISDescriptionIDFormatted:   "testCISID",
        CISDescriptionTitle:         "testCISTitle",
        CISDescriptionTextFormatted: "testCISDescription",
        Severity:                    model.SeverityHigh,
        Files: []model.VulnerableFile{
                {
                        FileName:         positive,
                        Line:             25,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is missing",
                        Value:            nil,
                },
                {
                        FileName:         positive,
                        Line:             19,
                        IssueType:        "IncorrectValue",
                        SearchKey:        "aws_alb_listener[front_end].default_action.redirect",
                        KeyExpectedValue: "'default_action.redirect.protocol' is equal 'HTTPS'",
                        KeyActualValue:   "'default_action.redirect.protocol' is equal 'HTTP'",
                        Value:            nil,
                },
        },
}

var queryMedium = model.VulnerableQuery{
        QueryName: "AmazonMQ Broker Encryption Disabled",
        QueryID:   "3db3f534-e3a3-487f-88c7-0a9fbf64b702",
        Severity:  model.SeverityMedium,
        Files: []model.VulnerableFile{
                {
                        FileName:         positive,
                        Line:             1,
                        IssueType:        "MissingAttribute",
                        SearchKey:        "resource.aws_mq_broker[positive1]",
                        KeyExpectedValue: "resource.aws_mq_broker[positive1].encryption_options is defined",
                        KeyActualValue:   "resource.aws_mq_broker[positive1].encryption_options is not defined",
                        Value:            nil,
                },
        },
}

// SummaryMock a summary to be used without running kics scan
var SummaryMock = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           1,
                ParsedFiles:            1,
                FailedToScanFiles:      0,
                TotalQueries:           1,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.VulnerableQuery{
                queryHigh,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:   0,
                        model.SeverityLow:    0,
                        model.SeverityMedium: 0,
                        model.SeverityHigh:   2,
                },
                TotalCounter: 2,
        },
        ScannedPaths: []string{
                "./",
        },
}

// ComplexSummaryMock a summary with more results to be used without running kics scan
var ComplexSummaryMock = model.Summary{
        Counters: model.Counters{
                ScannedFiles:           2,
                ParsedFiles:            2,
                FailedToScanFiles:      0,
                TotalQueries:           2,
                FailedToExecuteQueries: 0,
        },
        Queries: []model.VulnerableQuery{
                queryHigh,
                queryMedium,
        },
        SeveritySummary: model.SeveritySummary{
                ScanID: "console",
                SeverityCounters: map[model.Severity]int{
                        model.SeverityInfo:   0,
                        model.SeverityLow:    0,
                        model.SeverityMedium: 1,
                        model.SeverityHigh:   2,
                },
                TotalCounter: 3,
        },
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
